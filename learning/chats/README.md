I will now proceed with optimizing the index.html file based on your detailed requirements.

The optimization strategy focuses on:

Batch Processing and Debouncing: Using requestAnimationFrame to group DOM updates for new messages, reducing redraws.
Message Deduplication and Caching: Implementing a Set for fast message ID lookups and ensuring proper cache size limits.
Strategy Pattern Optimization: Refactoring the onSocketMessage logic using an object mapping for better maintainability.
Performance Optimization: Utilizing requestIdleCallback for processing historical messages in chunks, avoiding main thread blockage.
Memory Management: Explicitly managing message ids in a Set and ensuring the messageHeights map stays in sync with the allMessages array.
Error Handling Optimization: Replacing intrusive alert() calls with a more user-friendly, non-blocking notification system.
I will provide the complete, optimized index.html content.

Optimized index.html (frontend)

--- START OF FILE index.html ---

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>ÂÆûÊó∂ËÅäÂ§©ÂÆ§</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
;(function(){
  /* 1. passive-patch ‰øùÊåÅÂéüÊ†∑ */
  const PASSIVE_EVENTS = new Set([
      'scroll',
      'wheel',
      'mousewheel',  // for older browsers
      'touchstart',
      'touchmove',
      'touchenter',
      'touchend',
      'touchleave',
      'touchcancel'
    ]);
  const _orig = EventTarget.prototype.addEventListener;
  EventTarget.prototype.addEventListener = function(type, fn, opts){
    if (PASSIVE_EVENTS.has(type)){
      if (opts===undefined) opts={passive:true};
      else if (typeof opts==='boolean') opts={capture:opts, passive:true};
      else if (typeof opts==='object' && opts.passive===undefined) opts.passive=true;
    }
    return _orig.call(this, type, fn, opts);
  };
  /* 2. Á≠â DOM ÂÆåÂÖ®Â∞±Áª™ÂêéÂÜçËß£ÈîÅ AudioContext */
  document.addEventListener('DOMContentLoaded', ()=>{
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    function unlockAudioContext(e){
      if (e.type==='touchend') e.preventDefault();
      const ac = new AudioCtx();
      if (ac.state==='suspended') ac.resume();
      new Audio("data:audio/mp3;base64,SUQz‚Ä¶").play().catch(()=>{});
      document.body.removeEventListener('click', unlockAudioContext);
      document.body.removeEventListener('touchend', unlockAudioContext);
    }
    document.body.addEventListener('click', unlockAudioContext, { once: true });
    document.body.addEventListener('touchend', unlockAudioContext, { once: true, passive: false });
  });
})();
</script>
    <style>
        /* --- BASE STYLES --- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            overscroll-behavior: none; /* Èò≤Ê≠¢Êï¥È°µÊ©°ÁöÆÁ≠ãÊïàÊûú */
        }
        
        .chat-container {
            width: 90%;
            max-width: 800px;
            height: 100%;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            display: flex;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            width: 280px;
            background: linear-gradient(180deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 0;
            border-right: none;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        }
        
        .sidebar-header {
            padding: 20px;
            background: rgba(0,0,0,0.1);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .sidebar h2 {
            margin: 0;
            font-size: 1.2em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .online-indicator {
            width: 8px;
            height: 8px;
            background: #2ecc71;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .user-list-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .user-list-title {
            font-size: 0.9em;
            font-weight: 600;
            margin-bottom: 12px;
            color: rgba(255, 255, 255, 0.9);
            padding-bottom: 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .user-row {
            display: flex;
            align-items: flex-start;
            margin-bottom: 16px;
            gap: 16px;
        }
        
        .user-names {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            align-items: flex-start;
        }
        
        .user-item {
            padding: 6px 10px;
            font-size: 0.8em;
            background: rgba(255,255,255,0.15);
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .user-item::before { content: 'üë§'; font-size: 10px; }
        .user-item:hover { background: rgba(255,255,255,0.25); transform: scale(1.05); box-shadow: 0 2px 8px rgba(0,0,0,0.2); }
        .user-info { flex: 1; display: flex; flex-direction: column; gap: 8px; font-size: 0.75em; }
        .info-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; background: rgba(255,255,255,0.08); border-radius: 8px; transition: all 0.3s ease; border: 1px solid rgba(255,255,255,0.05); }
        .info-row:hover { background: rgba(255,255,255,0.15); box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
        .info-label { color: rgba(255,255,255,0.8); font-weight: 500; }
        .info-value { color: white; font-weight: 600; text-align: right; }
        .online-count { color: #2ecc71; font-size: 1.1em; }
        .room-name-sidebar { color: #f39c12; font-size: 0.9em; }

        .user-stats-container {
            padding: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-top: auto; /* Push to bottom */
            max-height: 50vh; /* ËÆæÁΩÆ‰∏Ä‰∏™ÊúÄÂ§ßÈ´òÂ∫¶Ôºå‰æãÂ¶Ç 250px */
            overflow-y: auto;  /* ÂΩìÂÜÖÂÆπË∂ÖÂá∫ÊúÄÂ§ßÈ´òÂ∫¶Êó∂ÔºåÂûÇÁõ¥ÊñπÂêëÊòæÁ§∫ÊªöÂä®Êù° */
        }
        .user-stats-item {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            color: white;
            font-size: 0.85em;
            border: 1px solid rgba(255,255,255,0.05);
        }
        .user-stats-item:last-child { margin-bottom: 0; }
        .user-stats-item strong { color: #f39c12; }
        .user-stats-item .stat-label { opacity: 0.8; font-size: 0.9em; }
        .user-stats-item .stat-value { font-weight: 600; }
        .user-stats-item .stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .user-stats-item .stat-row:last-child { margin-bottom: 0; }
        .user-stats-item .online-status { color: #2ecc71; font-weight: 600; }
        .user-stats-item .offline-status { color: #e74c3c; font-weight: 600; }
        
        /* --- MAIN CHAT AREA --- */
        .main-chat { flex: 1; display: flex; flex-direction: column; min-width: 0; height: 100%; }
        .chat-header { padding: 12px 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; display: flex; align-items: center; justify-content: space-between; flex-shrink: 0; box-shadow: 0 2px 15px rgba(102, 126, 234, 0.2); position: relative; }
        .sidebar-toggle { display: none; align-items: center; justify-content: center; width: 36px; height: 36px; background: rgba(255, 255, 255, 0.2); border: none; border-radius: 8px; font-size: 16px; color: white; cursor: pointer; transition: all 0.3s ease; flex-shrink: 0; }
        .sidebar-toggle:hover { background: rgba(255, 255, 255, 0.3); }
        .chat-info { display: flex; align-items: center; gap: 12px; flex: 0 0 auto; }
        .room-icon { width: 32px; height: 32px; background: rgba(255, 255, 255, 0 ); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 16px; flex-shrink: 0; }
        .chat-details { display: flex; flex-direction: column; min-width: 0; }
        .room-name { font-size: 1.1em; font-weight: 700; margin: 0; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.3); }
        .user-status { font-size: 0.8em; opacity: 0.9; margin: 2px 0 0 0; display: flex; align-items: center; gap: 6px; }
        #username-display {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-underline-offset: 3px;
            transition: color 0.3s;
        }
        #username-display:hover {
            color: #f39c12;
        }
        .connection-dot { width: 6px; height: 6px; background: #2ecc71; border-radius: 50%; animation: pulse 2s infinite; }
        .connection-dot.disconnected { background: #e74c3c; animation: none; }
        .online-users-display { cursor: pointer; user-select: none; font-size: 0.8em; font-weight: 500; color: rgba(255, 255, 255, 0.9); background: rgba(255,255,255,0.15); padding: 6px 10px; border-radius: 12px; backdrop-filter: blur(10px); flex-shrink: 0; white-space: nowrap; transition: all 0.3s ease; }
        .online-users-display:hover { background: rgba(255,255,255,0.25); }
        .users-menu { display: none; position: absolute; top: 100%; right: 25px; background: white; border: 1px solid #ddd; box-shadow: 0 4px 12px rgba(0,0,0,0.15); border-radius: 8px; max-height: 200px; overflow-y: auto; z-index: 200; margin-top: 8px; min-width: 160px; }
        .users-menu.show { display: block; }
        .users-menu ul { list-style: none; margin: 0; padding: 8px 0; }
        .users-menu li { padding: 8px 12px; font-size: 0.9em; color: #333; white-space: nowrap; display: flex; align-items: center; gap: 6px; }
        .users-menu li::before { content: 'üë§'; font-size: 12px; }
        .users-menu li:hover { background: #f5f5f5; }

        /* --- CHAT WINDOW --- */
        #chat-window { 
            flex: 1; 
            padding: 20px 25px;
            padding-bottom: calc(20px + env(safe-area-inset-bottom, 0px)); 
            overflow-y: auto; 
            min-height: 0; 
            background: #f8f9fa; 
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch; /* ÂÖ≥ÈîÆ: ‰ΩøiOSËÆæÂ§á‰∏äÁöÑÊªöÂä®Êõ¥ÊµÅÁïÖ */
            overscroll-behavior: contain; /* Á°Æ‰øùÊªöÂä®Ë°å‰∏∫Ë¢´ÂåÖÂê´ */
            touch-action: pan-y; /* ÊòéÁ°ÆÂêØÁî®ÂûÇÁõ¥Âπ≥Áßª */
            position: relative; /* Á°Æ‰øùÊ≠£Á°ÆÂÆö‰Ωç */
        }
        #chat-window::-webkit-scrollbar { width: 4px; }
        #chat-window::-webkit-scrollbar-track { background: transparent; }
        #chat-window::-webkit-scrollbar-thumb { background: #ccc; border-radius: 2px; }
        #chat-window::-webkit-scrollbar-thumb:hover { background: #999; }
        /* ËôöÊãüÊªöÂä®Â°´ÂÖÖÂÖÉÁ¥† */
        .virtual-scroll-spacer {
            flex-shrink: 0; /* ‰∏ç‰ºöË¢´ÂéãÁº© */
            width: 100%;
        }
        .virtual-scroll-spacer.top { order: 1; } /* È°∂ÈÉ®Â°´ÂÖÖÂú®ÊúÄÂâçÈù¢ */
        .virtual-scroll-spacer.bottom { order: 3; } /* Â∫ïÈÉ®Â°´ÂÖÖÂú®ÊúÄÂêéÈù¢ */
        .message-container-wrapper {
            order: 2; /* ÂÆûÈôÖÊ∂àÊÅØÂÆπÂô®Âú®‰∏≠Èó¥ */
            width: 100%;
            position: relative; /* Ê∂àÊÅØÁõ∏ÂØπËøô‰∏™ÂÆπÂô®ÂÆö‰Ωç */
        }


        /* --- MESSAGE STYLES --- */
        .message { margin-bottom: 16px; display: flex; flex-direction: column; animation: fadeInUp 0.3s ease; }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        .message .info { margin-bottom: 5px; }
        .message .info .username { font-size: 0.85em; font-weight: 700; color: #495057; }
        .message .info .timestamp { font-size: 0.65em; color: #999; }
        .message .text { padding: 10px 10px; background: white; border-radius: 16px; max-width: 75%; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 6px rgba(0,0,0,0.08); border: 1px solid #e9ecef; position: relative; }
        .message.self { align-items: flex-end; }
        .message.self .text { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border: none; }
        .message.self .info { text-align: right; }

        /* --- MARKDOWN STYLES --- */
        .message .text { line-height: 1.6; }
        .message .text h1, .message .text h2, .message .text h3 { margin-top: 0.5em; margin-bottom: 0.5em; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        .message.self .text h1, .message.self .text h2, .message.self .text h3 { border-bottom-color: rgba(255, 255, 255, 0.3); }
        .message .text p { margin-top: 0; margin-bottom: 0; }
        .message .text ul, .message .text ol { padding-left: 1.5em; margin-bottom: 1em; }
        .message .text li { margin-bottom: 0.25em; }
        .message .text pre { background-color: #2d2d2d; color: #f8f8f2; padding: 1em; border-radius: 8px; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.9em; margin: 1em 0; }
        .message.self .text pre { background-color: rgba(0, 0, 0, 0.2); }
        .message .text code { background-color: rgba(0,0,0,0.05); padding: 0.2em 0.4em; border-radius: 4px; font-family: 'Courier New', Courier, monospace; }
        .message.self .text code { background-color: rgba(255, 255, 255, 0.2); }
        .message .text pre > code { background-color: transparent; padding: 0; }
        .message .text blockquote { border-left: 4px solid #ccc; padding-left: 1em; margin: 1em 0; color: #666; }
        .message.self .text blockquote { border-left-color: rgba(255, 255, 255, 0.5); color: rgba(255, 255, 255, 0.8); }
        .message .text table { border-collapse: collapse; width: 100%; margin: 1em 0; }
        .message .text th, .message .text td { border: 1px solid #ddd; padding: 0.5em; }
        .message.self .text th, .message.self .text td { border-color: rgba(255, 255, 255, 0.3); }
        .message .text th { background-color: #f2f2f2; }
        .message.self .text th { background-color: rgba(0, 0, 0, 0.1); }
        .message .text a { color: #007bff; text-decoration: none; }
        .message .text a:hover { text-decoration: underline; }
        .message.self .text a { color: #a0c8ff; }

        /* --- MEDIA MESSAGE STYLES --- */
        .message-image { padding: 4px; background: white; border-radius: 16px; max-width: 300px; box-shadow: 0 1px 6px rgba(0,0,0,0.08); border: 1px solid #e9ecef; overflow: hidden; cursor: pointer; transition: all 0.3s ease; position: relative; }
        .message-image:hover { transform: scale(1.02); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
        .message-image img { width: 100%; height: auto; border-radius: 12px; display: block; }
        .message.self .message-image { background: rgba(255,255,255,0.1); border: none; }
        .message-audio { display: flex; align-items: center; gap: 10px; padding: 8px 12px; background: #f1f3f5; border-radius: 16px; border: 1px solid #e9ecef; }
        .message.self .message-audio { background: #7783EA; border: none; }
        .message-audio audio { outline: none; }
        
        /* --- IMAGE MODAL & PREVIEW --- */
        .image-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000; justify-content: center; align-items: center; animation: fadeIn 0.3s ease; }
        .image-modal.show { display: flex; }
        .image-modal img { max-width: 90%; max-height: 90%; border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        .image-modal-close { position: absolute; top: 20px; right: 20px; background: rgba(255,255,255,0.2); border: none; color: white; font-size: 24px; width: 40px; height: 40px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.3s ease; }
        .image-modal-close:hover { background: rgba(255,255,255,0.3); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* --- INPUT AREA --- */
        #message-form { position: sticky; bottom: env(safe-area-inset-bottom, 0); display: flex; padding: 12px 15px; gap: 8px; align-items: center; border-top: 1px solid #e9ecef; background: white; box-shadow: 0 -2px 15px rgba(0,0,0,0.08); z-index: 100; }
        .icon-btn {
            background: none;
            border: none;
            color: #6c757d;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
            width: 44px;
            height: 44px;
        }
        .icon-btn:hover {
            background: #f1f3f5;
            color: #667eea;
        }
        .input-wrapper { flex: 1; position: relative; }
        #message-input { width: 100%; padding: 12px 18px; border: 2px solid #e9ecef; border-radius: 22px; outline: none; font-size: 0.95em; font-family: inherit; resize: none; min-height: 20px; max-height: 100px; line-height: 1.4; transition: all 0.3s ease; box-sizing: border-box; }
        #message-input:focus { border-color: #667eea; box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
        #image-input { display: none; }
        .image-preview { position: absolute; bottom: 100%; left: 0; right: 0; background: white; border: 2px solid #667eea; border-radius: 12px; padding: 12px; margin-bottom: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.15); display: none; }
        .image-preview.show { display: block; }
        .preview-content { display: flex; align-items: center; gap: 12px; }
        .preview-image { width: 60px; height: 60px; border-radius: 8px; object-fit: cover; border: 1px solid #e9ecef; }
        .preview-info { flex: 1; min-width: 0; }
        .preview-name { font-size: 0.9em; font-weight: 600; color: #333; margin-bottom: 4px; word-break: break-all; }
        .preview-size { font-size: 0.8em; color: #6c757d; }
        .preview-remove { background: #e74c3c; color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; transition: all 0.3s ease; }
        .preview-remove:hover { background: #c0392b; }
        .uploading { opacity: 0.6; pointer-events: none; }
        .upload-progress { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(102, 126, 234, 0.9); color: white; padding: 8px 12px; border-radius: 8px; font-size: 0.8em; font-weight: 500; }
        #send-button { padding: 10px 20px; border: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; border-radius: 22px; cursor: pointer; font-size: 0.9em; font-weight: 600; transition: all 0.3s ease; box-shadow: 0 3px 12px rgba(102, 126, 234, 0.3); min-width: 70px; }
        #send-button:hover { transform: translateY(-1px); box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4); }
        #send-button:active { transform: translateY(0); }
        #send-button:disabled { opacity: 0.6; cursor: not-allowed; transform: none; }
        
        /* --- CONTEXT MENU & AI EXPLANATION STYLES --- */
        .context-menu { display: none; position: absolute; background-color: #f1f1f1; border: 1px solid #ccc; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.15); z-index: 1000; }
        .context-menu ul { list-style: none; padding: 5px 0; margin: 0; }
        .context-menu ul li { padding: 8px 15px; cursor: pointer; }
        .context-menu ul li:hover { background-color: #ddd; }

        /* Call Controls */
        #call-controls-container {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 1001;
        }
        .call-control-panel {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .hang-up-btn {
            background: #e74c3c;
            color: white;
            border: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
        }
        .user-menu-item-with-call {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .call-btn {
            background: #2ecc71;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            margin-left: 10px;
        }
        .unmute-notice {
            background: #f39c12;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
        }

        /* (ÂèØÈÄâ) ‰∏∫AIËèúÂçïÈ°πÊ∑ªÂä†ÂõæÊ†á */
        .context-menu .ai-explain-option {
            display: flex;
            align-items: center;
            gap: 8px; /* ÂõæÊ†áÂíåÊñáÂ≠óÁöÑÈó¥Ë∑ù */
        }

        .context-menu .ai-explain-option::before {
            content: 'ü§ñ'; /* AIÂ∞èÊú∫Âô®‰∫∫ÂõæÊ†á */
            font-size: 14px;
        }   
        .ai-explanation { position: relative; background-color: #f0f4f8; border: 1px solid #d1d9e6; border-radius: 12px; padding: 12px 16px; margin-top: 8px; font-size: 0.85em; color: #334; line-height: 1.5; animation: fadeInUp 0.4s ease; box-shadow: 0 2px 5px rgba(0,0,0,0.05); max-width: 75%; box-sizing: border-box; align-self: flex-start; }
        .message.self .ai-explanation { align-self: flex-end; }
        .ai-explanation::before { content: 'ü§ñ AI Ëß£Èáä:'; font-weight: 600; color: #556; display: block; margin-bottom: 6px; font-size: 0.9em; }
        .ai-explanation p { margin: 0; }
        .ai-explanation-close { background: none; border: none; color: #889; font-size: 16px; cursor: pointer; width: 24px; height: 24px; line-height: 24px; text-align: center; border-radius: 50%; transition: all 0.2s ease; }
        .ai-explanation-close:hover { background-color: #e1e5e9; color: #333; }
        .ai-explanation-copy { background: none; border: none; color: #889; font-size: 16px; cursor: pointer; width: 24px; height: 24px; line-height: 24px; text-align: center; border-radius: 50%; transition: all 0.2s ease; margin-right: 5px; }
        .ai-explanation-copy:hover { background-color: #e1e5e9; color: #333; }
        .ai-explanation-buttons { position: absolute; top: 6px; right: 6px; display: flex; gap: 5px; }
        
        .ai-explanation .markdown-content { font-size: 0.9em; line-height: 1.6; text-align: left; }
        .ai-explanation .markdown-content p { margin-bottom: 12px; }
        .ai-explanation .markdown-content p:last-child { margin-bottom: 0; }
        .ai-explanation .markdown-content h1, .ai-explanation .markdown-content h2, .ai-explanation .markdown-content h3 { margin-top: 16px; margin-bottom: 8px; border-bottom: 1px solid #d1d9e6; padding-bottom: 4px; }
        .ai-explanation .markdown-content pre { background-color: #2d2d2d; color: #f8f8f2; padding: 12px; border-radius: 8px; overflow-x: auto; font-family: 'Courier New', Courier, monospace; font-size: 0.85em; }
        .ai-explanation .markdown-content code { background-color: #e8e8e8; padding: 2px 5px; border-radius: 4px; font-family: 'Courier New', Courier, monospace; }
        .ai-explanation .markdown-content pre code { background-color: transparent; padding: 0; }
        .ai-explanation .markdown-content ul, .ai-explanation .markdown-content ol { padding-left: 20px; margin-top: 8px; margin-bottom: 12px; }
        .ai-explanation .markdown-content blockquote { border-left: 4px solid #b0c4de; padding-left: 12px; margin: 12px 0; color: #556; background-color: #f9f9f9; }
        .ai-explanation .markdown-content a { color: #007bff; text-decoration: none; }
        .ai-explanation .markdown-content a:hover { text-decoration: underline; }

        .loading-dots {
            display: inline-block;
            width: 1.5em;
            text-align: left;
        }
        .loading-dots::after {
            content: '.';
            animation: dots 1s steps(5, end) infinite;
        }
        @keyframes dots {
            0%, 20% { color: rgba(0,0,0,0); text-shadow:
                .25em 0 0 rgba(0,0,0,0),
                .5em 0 0 rgba(0,0,0,0); }
            40% { color: black; text-shadow:
                .25em 0 0 rgba(0,0,0,0),
                .5em 0 0 rgba(0,0,0,0); }
            60% { text-shadow:
                .25em 0 0 black,
                .5em 0 0 rgba(0,0,0,0); }
            80%, 100% { text-shadow:
                .25em 0 0 black,
                .5em 0 0 black; }
        }

        /* --- RESPONSIVE --- */
        @media (max-width: 768px) {
            html, body { 
                height: 100%; /* ‰ΩøÁî®Âõ∫ÂÆöÈ´òÂ∫¶ */
                overflow: hidden; /* Èò≤Ê≠¢Êï¥È°µÊªöÂä® */
                position: fixed; /* Âõ∫ÂÆöÊï¥‰∏™È°µÈù¢ */
                width: 100%; /* Á°Æ‰øùÂÆΩÂ∫¶100% */
                top: 0;
                left: 0;
            }
            .chat-container { 
                width: 100%; 
                height: 100%; 
                max-width: 100%; /* Ë¶ÜÁõñÊ°åÈù¢Á´ØÁöÑ max-width */
                border-radius: 0;
                box-shadow: none;
                position: absolute; /* Âõ∫ÂÆöËÅäÂ§©ÂÆπÂô® */
                top: 0;
                left: 0;
                display: flex;
                flex-direction: column; /* ÁßªÂä®Á´ØÊîπ‰∏∫ÂàóÂ∏ÉÂ±Ä */
            }
            .main-chat {
                flex: 1;
                width: 100%;
                position: relative;
                overflow: hidden; /* Èò≤Ê≠¢ÂÆπÂô®Â§ñÊ∫¢Âá∫ */
                display: flex;
                flex-direction: column;
            }
            #chat-window {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch; /* ÂÖ≥ÈîÆÂ±ûÊÄß */
                position: relative;
                z-index: 1; /* Á°Æ‰øùÊªöÂä®Âå∫ÂüüÂú®È°∂ÈÉ® */
            }
            .sidebar { 
                position: fixed; 
                left: -280px; 
                top: 0; 
                height: 100%; 
                z-index: 1000; 
                transition: left 0.3s ease; 
            }
            .sidebar.open { left: 0; }
            .sidebar-toggle { display: flex; }
            .chat-header { padding: 10px 15px; }
            .chat-info { gap: 10px; }
            .room-icon { width: 28px; height: 28px; font-size: 14px; }
            .room-name { font-size: 1em; }
            .user-status { font-size: 0.75em; }
            .online-users-display { margin-left: auto; font-size: 0.75em; padding: 4px 8px; }
            #message-form { 
                padding: 12px 15px; 
                padding-bottom: calc(12px + env(safe-area-inset-bottom, 0px));
                position: relative;
                z-index: 2; /* Á°Æ‰øùËæìÂÖ•Âå∫ÂüüÂú®È°∂ÈÉ® */
            }
            #message-input { padding: 10px 40px 10px 15px; font-size: 16px; }
            .users-menu { right: 15px; }
            .overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 999; }
            .overlay.show { display: block; }
            .user-row { flex-direction: column; align-items: stretch; gap: 12px; }
            .user-names, .user-info { flex: none; width: 100%; }
            .message-image { max-width: 250px; }
        }
            .header-users {
                display: none;
            }

        /* Ë∞ÉËØïÊó•ÂøóÊ†∑Âºè */
        .debug-log-container {
            padding: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            background: rgba(0,0,0,0.2);
            max-height: 950px;
            overflow-y: auto;
        }

        .debug-log-content {
            font-family: 'Courier New', monospace;
            font-size: 0.75em;
            color: #e0e0e0;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 920px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .debug-log-content:empty::before {
            content: "ÊöÇÊó†Êó•ÂøóÊï∞ÊçÆ";
            color: rgba(255,255,255,0.5);
            font-style: italic;
        }

        .debug-log-entry {
            margin-bottom: 5px;
            padding: 2px 5px;
            border-radius: 3px;
            animation: fadeIn 0.3s ease;
        }

        .debug-log-entry.info { color: #90caf9; border-left: 3px solid #90caf9; }
        .debug-log-entry.success { color: #a5d6a7; border-left: 3px solid #a5d6a7; }
        .debug-log-entry.warning { color: #ffcc80; border-left: 3px solid #ffcc80; }
        .debug-log-entry.error { color: #ef9a9a; border-left: 3px solid #ef9a9a; }

        .debug-controls {
            display: inline-flex;
            gap: 5px;
            float: right;
        }

        .debug-controls button {
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 4px;
            margin-right: 8px; 
            color: white;
            width: 24px;
            height: 24px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .debug-controls button:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .copy-feedback, .app-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .copy-feedback.show, .app-notification.show {
            opacity: 1;
        }

        .log-timestamp {
            color: rgba(255,255,255,0.5);
            margin-right: 5px;
            font-size: 0.85em;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="overlay" id="overlay"></div>
        
        <div class="image-modal" id="image-modal">
            <button class="image-modal-close" id="modal-close">√ó</button>
            <img id="modal-image" src="" alt="Preview">
        </div>
        
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2><span class="online-indicator"></span> Ê¥ªË∑ÉÁî®Êà∑</h2>
            </div>
            <div class="user-list-container">
                <div class="user-list-title">Áî®Êà∑ & ÊàøÈó¥‰ø°ÊÅØ</div>
                <div class="user-row">
                    <div class="user-names" id="user-names"></div>
                    <div class="user-info">
                        <div class="info-row">
                            <span class="info-label">Ê¥ªË∑É</span>
                            <span class="info-value online-count" id="online-count">0</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">ÊàøÈó¥</span>
                            <span class="info-value room-name-sidebar" id="sidebar-room-name">--</span>
                        </div>
                    </div>
                </div>
                <ul id="user-list" style="display: none;"></ul>
            </div>
            <div class="user-stats-container">
                <div class="user-list-title">Áî®Êà∑Ê¥ªÂä®ÁªüËÆ°</div>
                <div id="user-stats-list"></div>
            </div>
            <div class="debug-log-container">
                <div class="user-list-title">Ë∞ÉËØïÊó•Âøó
                    <div class="debug-controls">
                        <button id="clear-logs-btn" title="Ê∏ÖÁ©∫Êó•Âøó">üóëÔ∏è</button>
                        <button id="copy-logs-btn" title="Â§çÂà∂ÂÖ®ÈÉ®Êó•Âøó">üìã</button>
                        <button id="toggle-logs-btn" title="ÊòæÁ§∫/ÈöêËóèÊó•Âøó">üëÅÔ∏è</button>
                    </div>
                </div>
                <div id="debug-log-content" class="debug-log-content"></div>
            </div>
        </aside>

        <main class="main-chat">
            <header class="chat-header">
                <button class="sidebar-toggle" id="sidebar-toggle">‚ò∞</button>
                <div class="chat-info">
                    <div class="room-icon">üí¨</div>
                    <div class="chat-details">
                        <h1 class="room-name" id="room-name">Room: test</h1>
                        <p class="user-status">
                            <span class="connection-dot" id="connection-dot"></span>
                            <span id="status">Ê≠£Âú®ËøûÊé•...</span>
                            <span id="username-display" title="ÁÇπÂáª‰øÆÊîπÁî®Êà∑Âêç"></span>
                        </p>
                    </div>
                </div>
                <div class="online-users-display" id="online-users-display">Ê¥ªË∑É: 0</div>
                <div class="users-menu" id="users-menu">
                    <ul id="users-menu-list"></ul>
                </div>
            </header>

            <div id="chat-window"></div>

            <form id="message-form">
                <button type="button" class="icon-btn" id="attachment-btn">üìé</button>
                <input type="file" id="image-input" accept="image/*">
                <div class="input-wrapper">
                    <div class="image-preview" id="image-preview">
                        <div class="upload-progress" id="upload-progress" style="display: none;"></div>
                        <div class="preview-content">
                            <img class="preview-image" id="preview-image" src="" alt="Preview">
                            <div class="preview-info">
                                <div class="preview-name" id="preview-name"></div>
                                <div class="preview-size" id="preview-size"></div>
                            </div>
                            <button type="button" class="preview-remove" id="preview-remove">√ó</button>
                        </div>
                    </div>
                    <textarea id="message-input" placeholder="ËØ∑ËæìÂÖ•..." rows="1"></textarea>
                </div>
                <button type="button" class="icon-btn" id="record-button">üé§</button>
                <button id="send-button" type="submit" disabled>ÂèëÈÄÅ</button>
            </form>
        </main>
    </div>

<div id="context-menu" class="context-menu">
    <ul>
        <li class="ai-explain-option" data-ai="gemini" data-action="text-explain">ÈóÆGemini</li>
        <li class="ai-explain-option" data-ai="deepseek" data-action="text-explain">DeepSeek</li>
        <li class="ai-explain-option" data-ai="gemini" data-action="image-describe">ÈóÆGemini (ÂõæÁâá)</li>
        <li id="copy-option">üìù Â§ç Âà∂</li>
        <li id="delete-option">‚ùå Âà† Èô§</li>
    </ul>
</div>
<div id="call-controls-container"></div>
<div id="remote-audio-container"></div>
<div id="app-notification" class="app-notification"></div>


<script type="module">
    // --- DOM Elements ---
const sidebarToggle = document.getElementById('sidebar-toggle');
const sidebar = document.getElementById('sidebar');
const overlay = document.getElementById('overlay');
const onlineDisplay = document.getElementById('online-users-display');
const usersMenu = document.getElementById('users-menu');
const attachmentBtn = document.getElementById('attachment-btn');
const imageInput = document.getElementById('image-input');
const imagePreview = document.getElementById('image-preview');
const previewImage = document.getElementById('preview-image');
const previewName = document.getElementById('preview-name');
const previewSize = document.getElementById('preview-size');
const previewRemove = document.getElementById('preview-remove');
const uploadProgress = document.getElementById('upload-progress');
const imageModal = document.getElementById('image-modal');
const modalImage = document.getElementById('modal-image');
const modalClose = document.getElementById('modal-close');
const recordButton = document.getElementById('record-button');
const messageInput = document.getElementById('message-input');
const roomNameEl = document.getElementById('room-name');
const statusEl = document.getElementById('status');
const usernameDisplayEl = document.getElementById('username-display');
const connectionDot = document.getElementById('connection-dot');
const chatWindowEl = document.getElementById('chat-window');
const messageForm = document.getElementById('message-form');
const sendButton = document.getElementById('send-button');
const contextMenu = document.getElementById('context-menu');
const copyOption = document.getElementById('copy-option');
const deleteOption = document.getElementById('delete-option');
const callControlsContainer = document.getElementById('call-controls-container');
const remoteAudioContainer = document.getElementById('remote-audio-container');
const debugLogContent = document.getElementById('debug-log-content');
const clearLogsBtn = document.getElementById('clear-logs-btn');
const copyLogsBtn = document.getElementById('copy-logs-btn');
const toggleLogsBtn = document.getElementById('toggle-logs-btn');
const appNotification = document.getElementById('app-notification'); // New notification element


// --- ÂÖ®Â±ÄÁä∂ÊÄÅÂèòÈáè ---
let allMessages = []; // Â≠òÂÇ®ÊâÄÊúâÊ∂àÊÅØÊï∞ÊçÆ
let messageIdSet = new Set(); // ‚ú® Êñ∞Â¢ûÔºöÁî®‰∫éÂø´ÈÄüÂéªÈáç
let messageQueue = []; // ‚ú® Êñ∞Â¢ûÔºöÊ∂àÊÅØÈòüÂàóÔºåÁî®‰∫éÊâπÈáèÂ§ÑÁêÜÊñ∞Ê∂àÊÅØ
let rafScheduled = false; // ‚ú® Êñ∞Â¢ûÔºörequestAnimationFrame Ë∞ÉÂ∫¶Ê†áÂøó
const MESSAGE_BATCH_SIZE = 5; // ‚ú® Êñ∞Â¢ûÔºöÊâπÈáèÂ§ÑÁêÜÊ∂àÊÅØÁöÑÊúÄÂ∞èÊï∞Èáè
const MESSAGE_BATCH_DEBOUNCE_MS = 50; // ‚ú® Êñ∞Â¢ûÔºöÊâπÈáèÂ§ÑÁêÜÊ∂àÊÅØÁöÑÈò≤ÊäñÊó∂Èó¥

let isVirtualScrollInitialized = false; // Ê†áÂøó‰ΩçÔºåË∑üË∏™ËôöÊãüÊªöÂä®ÊòØÂê¶ÂáÜÂ§áÂ∞±Áª™
let historicalMessagesLoading = false; // ‚ú® Êñ∞Â¢ûÔºöÊ†áÂøó‰ΩçÔºåË°®Á§∫ÂéÜÂè≤Ê∂àÊÅØÊòØÂê¶Ê≠£Âú®Âä†ËΩΩ

let selectedFile = null;
let mediaRecorder;
let audioChunks = [];
let isRecording = false;
let currentMessageElement = null; // Áî®‰∫éÂ≠òÂÇ®ÂΩìÂâçÂè≥ÈîÆÁÇπÂáªÁöÑÊ∂àÊÅØÂÖÉÁ¥†
let socket;
let reconnectInterval = 1000;
const maxReconnectInterval = 30000;
let localStream = null;
const peerConnections = {};
const rtcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

// --- Êó•ÂøóÂäüËÉΩÂèòÈáè ---
const LOG_LEVELS = { INFO: 'info', SUCCESS: 'success', WARNING: 'warning', ERROR: 'error' };
const MAX_LOG_ENTRIES = 100;
let isDebugEnabled = true; // ÊéßÂà∂ÊòØÂê¶Âú®DOM‰∏≠ÊòæÁ§∫Ë∞ÉËØïÊó•Âøó


// --- ÂàùÂßãÂåñÁî®Êà∑ÂíåÊàøÈó¥‰ø°ÊÅØ ---
let username = localStorage.getItem('chat_username');
if (!username) {
    username = prompt("ËØ∑ËæìÂÖ•ÊÇ®ÁöÑÂßìÂêç:") || "ÂåøÂêçÁî®Êà∑";
    localStorage.setItem('chat_username', username);
}
const pathParts = window.location.pathname.split('/');
const roomName = pathParts.find(p => p.trim()) || 'general';


// --- Â∑•ÂÖ∑ÂáΩÊï∞ ---
function escapeHTML(str) {
    if (typeof str !== 'string') return '';
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
    };
    return str.replace(/[&<>"']/g, m => map[m]);
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
}

// ËäÇÊµÅÂáΩÊï∞
function throttle(func, delay) {
    let timeoutId;
    let lastArgs;
    let lastThis;

    return function(...args) {
        lastArgs = args;
        lastThis = this;

        if (!timeoutId) {
            timeoutId = setTimeout(() => {
                func.apply(lastThis, lastArgs);
                timeoutId = null;
                lastArgs = null;
                lastThis = null;
            }, delay);
        }
    };
}


// --- Ë∞ÉËØïÊó•ÂøóÁ≥ªÁªü (‰ºòÂåñÁâà) ---
function logDebug(message, level = LOG_LEVELS.INFO, data = null) {
    // ÊÄªÊòØËÆ∞ÂΩïÂà∞ÊéßÂà∂Âè∞ÔºåËøôÂØπË∞ÉËØïÂæàÈáçË¶Å
    const consoleMethod = level === LOG_LEVELS.ERROR ? 'error' : 
                          level === LOG_LEVELS.WARNING ? 'warn' : 'log';
    
    if (data) {
        console[consoleMethod](`[${level.toUpperCase()}] ${message}`, data);
    } else {
        console[consoleMethod](`[${level.toUpperCase()}] ${message}`);
    }
    
    // Â¶ÇÊûúË∞ÉËØïÊó•ÂøóË¢´Á¶ÅÁî®ÊàñÂÆπÂô®‰∏çÂ≠òÂú®ÔºåÂ∞±‰∏çËøõË°åDOMÊìç‰Ωú
    if (!isDebugEnabled || !debugLogContent) return;
    
    // ‰ΩøÁî®DocumentFragmentÂáèÂ∞ëDOMÊìç‰Ωú
    const fragment = document.createDocumentFragment();
    const timestamp = new Date().toLocaleTimeString();
    const logEntry = document.createElement('div');
    logEntry.className = `debug-log-entry ${level}`;
    
    let messageHTML = `<span class="log-timestamp">[${timestamp}]</span> <span>${message}</span>`;
    
    if (data) {
        // ÂØπ‰∫éÂ§ßÂûãÊï∞ÊçÆÔºåÈôêÂà∂ÊòæÁ§∫ÈïøÂ∫¶
        let dataString;
        try {
            if (typeof data === 'object' && data !== null) {
                // ÈôêÂà∂Êï∞ÊçÆÂ§ßÂ∞èÔºåÈÅøÂÖçJSON.stringifyÂç†Áî®ËøáÂ§öËµÑÊ∫ê
                const limitedData = JSON.parse(JSON.stringify(data, (k, v) => {
                    if (typeof v === 'string' && v.length > 500) {
                        return v.substring(0, 500) + '... [Êà™Êñ≠]';
                    }
                    return v;
                }));
                dataString = JSON.stringify(limitedData, null, 2);
            } else {
                dataString = String(data);
            }
        } catch (e) {
            dataString = `[Êó†Ê≥ïÂ∫èÂàóÂåñÁöÑÊï∞ÊçÆ: ${e.message}]`;
        }
        
        if (dataString.length > 1000) {
            dataString = dataString.substring(0, 1000) + '... [Êï∞ÊçÆËøáÂ§ßÔºåÂ∑≤Êà™Êñ≠]';
        }
        
        messageHTML += `<pre style="white-space: pre-wrap; word-break: break-all; margin-top: 5px; background: rgba(0,0,0,0.2); padding: 5px; border-radius: 4px;">${escapeHTML(dataString)}</pre>`;
    }
    
    logEntry.innerHTML = messageHTML;
    fragment.appendChild(logEntry);
    debugLogContent.appendChild(fragment);
    
    // ‰øùÊåÅÊó•ÂøóÊù°ÁõÆÊï∞ÈáèÂú®ÈôêÂà∂ËåÉÂõ¥ÂÜÖ
    while (debugLogContent.children.length > MAX_LOG_ENTRIES) {
        debugLogContent.removeChild(debugLogContent.firstChild);
    }
    
    // ‰ΩøÁî®requestAnimationFrame‰ºòÂåñÊªöÂä®Êìç‰Ωú
    requestAnimationFrame(() => {
        debugLogContent.scrollTop = debugLogContent.scrollHeight;
    });
}

function initDebugLog() {
    if (clearLogsBtn) clearLogsBtn.addEventListener('click', clearLogs);
    if (copyLogsBtn) copyLogsBtn.addEventListener('click', copyLogs);
    if (toggleLogsBtn) toggleLogsBtn.addEventListener('click', toggleLogsDisplay); // ÁªëÂÆöÂà∞Êñ∞ÁöÑÂàáÊç¢ÂáΩÊï∞
    logDebug('Ë∞ÉËØïÊó•ÂøóÁ≥ªÁªüÂàùÂßãÂåñÂÆåÊàê', LOG_LEVELS.SUCCESS);
    logDebug(`ÂΩìÂâçÁî®Êà∑: ${username}`, LOG_LEVELS.INFO);
    logDebug(`ÂΩìÂâçÊàøÈó¥: ${roomName}`, LOG_LEVELS.INFO);
}

function clearLogs() {
    debugLogContent.innerHTML = '';
    logDebug('Êó•ÂøóÂ∑≤Ê∏ÖÁ©∫', LOG_LEVELS.INFO);
}

function copyLogs() {
    const logText = Array.from(debugLogContent.children).map(entry => entry.textContent).join('\n');
    navigator.clipboard.writeText(logText).then(() => {
        showAppNotification('Êó•ÂøóÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø'); // Changed from showCopyFeedback
        logDebug('Êó•ÂøóÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø', LOG_LEVELS.SUCCESS);
    }).catch(err => logDebug(`Â§çÂà∂Â§±Ë¥•: ${err}`, LOG_LEVELS.ERROR));
}

// Êñ∞Â¢ûÔºöÂàáÊç¢Ë∞ÉËØïÊó•ÂøóÂú®DOM‰∏≠ÁöÑÊòæÁ§∫Áä∂ÊÄÅ
function toggleLogsDisplay() {
    isDebugEnabled = !isDebugEnabled; // ÂàáÊç¢ÂÖ®Â±ÄÊ†áÂøó
    if (debugLogContent) {
        debugLogContent.style.display = isDebugEnabled ? '' : 'none';
    }
    logDebug(`Ë∞ÉËØïÊó•ÂøóÊòæÁ§∫Â∑≤${isDebugEnabled ? 'ÂºÄÂêØ' : 'ÈöêËóè'}`, LOG_LEVELS.INFO);
}

// ‚ú® ‰ºòÂåñÂêéÁöÑÈÄöÁî®ÈÄöÁü•ÂáΩÊï∞
function showAppNotification(message, duration = 2000, isError = false) {
    if (!appNotification) return;

    appNotification.textContent = message;
    appNotification.style.backgroundColor = isError ? '#e74c3c' : 'rgba(102, 126, 234, 0.9)';
    appNotification.classList.add('show');

    setTimeout(() => appNotification.classList.remove('show'), duration);
}


// --- UI Ê∏≤ÊüìÂíåÊõ¥Êñ∞ÈÄªËæë ---
// ÂàõÂª∫‰∏Ä‰∏™ËäÇÊµÅÁâàÊú¨ÁöÑupdateUIFromMessagesÂáΩÊï∞ÔºåÈôêÂà∂Êõ¥Êñ∞È¢ëÁéá
const throttledUpdateUI = throttle(updateUIFromMessages, 1000); // 1ÁßíÂÜÖÊúÄÂ§öÊõ¥Êñ∞‰∏ÄÊ¨°UI

// Âà§Êñ≠Áî®Êà∑ÊòØÂê¶Ê¥ªË∑ÉÁöÑËæÖÂä©ÂáΩÊï∞
function isUserActive(lastSeenTimestamp) {
    if (!lastSeenTimestamp) return false;
    const fiveMinutesInMs = 5 * 60 * 1000;
    const fiveMinutesAgo = Date.now() - fiveMinutesInMs;
    return new Date(lastSeenTimestamp).getTime() > fiveMinutesAgo;
}

// ‰ºòÂåñ updateUIFromMessages ÂáΩÊï∞Ôºå‰ΩøÂÖ∂‰∏çÂÜçÈ¢ëÁπÅÂú∞ÈáçÁΩÆ innerHTML
function updateUIFromMessages() {
    // logDebug('Ê≠£Âú®‰ªé allMessages Êï∞ÁªÑÊõ¥Êñ∞UIÁïåÈù¢ (‰ºòÂåñÁâà)...', LOG_LEVELS.INFO); // ÈÅøÂÖçËøá‰∫éÈ¢ëÁπÅÁöÑÊó•Âøó

    const currentUserStates = new Map(); // { username: { lastSeen, messageCount, isActive } }
    const activeUsersSet = new Set();

    // Âè™Â§ÑÁêÜÊúÄËøëÁöÑ500Êù°Ê∂àÊÅØÊù•ÊèêÈ´òÊÄßËÉΩ (‰∏éÂêéÁ´ØÂêåÊ≠•)
    const recentMessages = allMessages.slice(-500); 
    
    recentMessages.forEach(msg => {
        const { username, timestamp } = msg;
        if (!username) return; // Ë∑≥ËøáÊó†ÊïàÁî®Êà∑

        const currentState = currentUserStates.get(username) || { lastSeen: 0, messageCount: 0 };
        currentState.lastSeen = Math.max(currentState.lastSeen, timestamp);
        currentState.messageCount++;
        currentUserStates.set(username, currentState);
    });

    // Á°ÆÂÆöÊ¥ªË∑ÉÁî®Êà∑ÂíåÊõ¥Êñ∞Ê¥ªË∑ÉÁä∂ÊÄÅ
    currentUserStates.forEach((state, username) => {
        state.isActive = isUserActive(state.lastSeen);
        if (state.isActive) {
            activeUsersSet.add(username);
        }
    });

    const sortedActiveUsernames = Array.from(activeUsersSet).sort((a, b) => a.localeCompare(b));

    // --- Êõ¥Êñ∞Áî®Êà∑ÊòµÁß∞ÂàóË°® (`#user-names`) ÂíåËèúÂçï (`#users-menu-list`) ---
    const userNamesEl = document.getElementById('user-names');
    const menuListEl = document.getElementById('users-menu-list');

    // ÁßªÈô§Â∑≤Á¶ªÂºÄÁöÑÁî®Êà∑ÔºöÈÅçÂéÜÂΩìÂâçDOM‰∏≠ÁöÑÁî®Êà∑ÔºåÂ¶ÇÊûú‰∏çÂú®Ê¥ªË∑ÉÂàóË°®‰∏≠ÔºåÂ∞±ÁßªÈô§
    Array.from(userNamesEl.children).forEach(el => {
        const name = el.dataset.username; // Ëé∑ÂèñÂ≠òÂÇ®Âú® dataset ‰∏≠ÁöÑÁî®Êà∑Âêç
        if (name && !activeUsersSet.has(name)) {
            el.remove();
            menuListEl.querySelector(`li[data-username="${escapeHTML(name)}"]`)?.remove();
        }
    });

    // Ê∑ªÂä†Êñ∞Áî®Êà∑ÂíåÊõ¥Êñ∞Áé∞ÊúâÁî®Êà∑ÔºöÈÅçÂéÜÊ¥ªË∑ÉÂàóË°®
    sortedActiveUsernames.forEach(name => {
        const safeName = escapeHTML(name);
        // Â¶ÇÊûúDOM‰∏≠‰∏çÂ≠òÂú®ËØ•Áî®Êà∑ÔºåÂàôÂàõÂª∫Âπ∂Ê∑ªÂä†
        if (!userNamesEl.querySelector(`.user-item[data-username="${safeName}"]`)) {
            // Ê∑ªÂä†Âà∞‰æßËæπÊ†èÁî®Êà∑ÂàóË°®
            const userItem = document.createElement('div');
            userItem.className = 'user-item';
            userItem.textContent = safeName;
            userItem.dataset.username = safeName; // Â≠òÂÇ®Áî®Êà∑Âêç‰æø‰∫éÊü•ÊâæÂíåÂà†Èô§
            userNamesEl.appendChild(userItem); // Áõ¥Êé•appendÔºåÊµèËßàÂô®‰ºö‰ºòÂåñÂ∞ëÈáèDOMÊìç‰Ωú

            // Ê∑ªÂä†Âà∞Â§¥ÈÉ®ËèúÂçïÂàóË°®
            const menuItem = document.createElement('li');
            menuItem.dataset.username = safeName; // Â≠òÂÇ®Áî®Êà∑Âêç
            if (name === username) {
                menuItem.textContent = `${safeName} (‰Ω†)`;
            } else {
                menuItem.className = 'user-menu-item-with-call';
                const nameSpan = document.createElement('span');
                nameSpan.textContent = safeName;
                menuItem.appendChild(nameSpan);
                const callBtn = document.createElement('button');
                callBtn.className = 'call-btn';
                callBtn.textContent = 'üìû';
                callBtn.dataset.username = safeName;
                // Ê≥®ÊÑèÔºöËøôÈáåcallBtnÁöÑÁÇπÂáª‰∫ã‰ª∂Êó†ÈúÄÂßîÊâòÔºåÂõ†‰∏∫ÂÆÉÊòØÈöèËèúÂçïÈ°πÂàõÂª∫Âπ∂Ê∑ªÂä†Âà∞DOMÁöÑ
                callBtn.onclick = (e) => {
                    e.stopPropagation();
                    startCall(callBtn.dataset.username);
                    usersMenu.classList.remove('show');
                };
                menuItem.appendChild(callBtn);
            }
            menuListEl.appendChild(menuItem);
        }
        // ÂØπ‰∫éÂ∑≤Â≠òÂú®ÁöÑÁî®Êà∑ÔºåÂ¶ÇÊûúÈúÄË¶ÅÔºåÂèØ‰ª•Âú®ËøôÈáåÊõ¥Êñ∞‰ªñ‰ª¨ÁöÑÁä∂ÊÄÅÊàñÊ†∑Âºè
    });

    // --- Êõ¥Êñ∞Ê¥ªË∑ÉÁî®Êà∑ËÆ°Êï∞ ---
    document.getElementById('online-count').textContent = sortedActiveUsernames.length;
    onlineDisplay.textContent = `Ê¥ªË∑É: ${sortedActiveUsernames.length}`;
    document.getElementById('sidebar-room-name').textContent = roomName; // Á°Æ‰øùÊàøÈó¥ÂêçÂßãÁªàÊòæÁ§∫

    // --- Êõ¥Êñ∞Áî®Êà∑Ê¥ªÂä®ÁªüËÆ° (`#user-stats-list`) ---
    const userStatsListEl = document.getElementById('user-stats-list');
    const allUsersSorted = Array.from(currentUserStates.keys()).sort((a, b) => {
        const aState = currentUserStates.get(a);
        const bState = currentUserStates.get(b);
        if (aState.isActive !== bState.isActive) return bState.isActive - aState.isActive; // Ê¥ªË∑ÉÁöÑÂú®Ââç
        return (bState.messageCount || 0) - (aState.messageCount || 0); // Ê∂àÊÅØÂ§öÁöÑÂú®Ââç
    });

    // ËøôÈáåÂèØ‰ª•ÈááÁî®Êõ¥ÁªÜËá¥ÁöÑÊõ¥Êñ∞Á≠ñÁï•Ôºå‰ΩÜÂ¶ÇÊûúÁî®Êà∑ÁªüËÆ°Êï∞ÈáèÊúâÈôêÔºåinnerHTMLÊ∏ÖÁ©∫ÈáçÁªòÂºÄÈîÄÂèØÊé•Âèó
    // ÊöÇÊó∂‰øùÊåÅÊ∏ÖÁ©∫ÈáçÁªòÔºåÂõ†‰∏∫ÂÆÉÂú®‰æßËæπÊ†èÂ∫ïÈÉ®Ôºå‰∏îÊõ¥Êñ∞È¢ëÁéáÈôç‰Ωé
    const statsFragment = document.createDocumentFragment();
    if (allUsersSorted.length === 0) {
        const emptyMsg = document.createElement('p');
        emptyMsg.style.color = 'rgba(255,255,255,0.7)';
        emptyMsg.style.fontSize = '0.8em';
        emptyMsg.textContent = 'ÊöÇÊó†Áî®Êà∑Ê¥ªÂä®„ÄÇ';
        statsFragment.appendChild(emptyMsg);
    } else {
        allUsersSorted.forEach(name => {
            const state = currentUserStates.get(name);
            if (!state) return; // Should not happen

            const item = document.createElement('div');
            item.className = 'user-stats-item';
            const isActive = state.isActive;
            const lastSeenString = state.lastSeen ? new Date(state.lastSeen).toLocaleString() : 'Êú™Áü•';
            
            item.innerHTML = `
                <div class="stat-row">
                    <strong>${escapeHTML(name)}</strong>
                    <span class="${isActive ? 'online-status' : 'offline-status'}">${isActive ? 'Ê¥ªË∑É' : 'Á¶ªÁ∫ø'}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ÂèëË®Ä:</span>
                    <span class="stat-value">${state.messageCount}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">ÊúÄËøëÂèëË®Ä:</span>
                    <span class="stat-value">${lastSeenString}</span>
                </div>`;
            statsFragment.appendChild(item);
        });
    }
    userStatsListEl.innerHTML = ''; // Ê∏ÖÁ©∫ÊóßÂÜÖÂÆπ
    userStatsListEl.appendChild(statsFragment); // ÊâπÈáèÊ∑ªÂä†Êñ∞ÂÜÖÂÆπ
}


// --- ËôöÊãüÊªöÂä®Áõ∏ÂÖ≥ÂèòÈáè ---
const AVERAGE_MESSAGE_HEIGHT = 80; // È¢Ñ‰º∞ÊØèÊù°Ê∂àÊÅØÁöÑÂπ≥ÂùáÈ´òÂ∫¶ (px)
const OVERSCAN_COUNT = 10; // Âú®ÂèØËßÅÂå∫Âüü‰∏äÊñπÂíå‰∏ãÊñπÈ¢ùÂ§ñÊ∏≤ÊüìÁöÑÊ∂àÊÅØÊï∞ÈáèÔºåÁî®‰∫éÂπ≥ÊªëÊªöÂä®
const messageHeights = new Map(); // Â≠òÂÇ®ÊØèÊù°Ê∂àÊÅØÂÆûÈôÖÈ´òÂ∫¶ÁöÑMap: { messageId: height }
let topSpacerEl;
let bottomSpacerEl;
let messageWrapperEl; // Áî®‰∫éÂåÖË£πÂÆûÈôÖÊ∂àÊÅØDOMÁöÑÂÆπÂô®

let prevScrollTop = 0; // Áî®‰∫éÂà§Êñ≠ÊªöÂä®ÊñπÂêëÂíåÊòØÂê¶ÈúÄË¶ÅÈáçÊñ∞Ê∏≤Êüì
let lastRenderedRange = { start: -1, end: -1 }; // ‰∏äÊ¨°Ê∏≤ÊüìÁöÑÊ∂àÊÅØËåÉÂõ¥


// --- ËôöÊãüÊªöÂä®Ê†∏ÂøÉÊ∏≤ÊüìÂáΩÊï∞ ---
function renderVirtualWindow(scrollToBottom = false) {
    if (!chatWindowEl || !messageWrapperEl) {
        logDebug('ËôöÊãüÊªöÂä®ÂàùÂßãÂåñÊú™ÂÆåÊàêÔºåÊó†Ê≥ïÊ∏≤Êüì', 'WARN');
        return;
    }

    const viewportHeight = chatWindowEl.clientHeight;
    const scrollTop = chatWindowEl.scrollTop;

    let currentScrollY = 0;
    let startIndex = 0;
    
    // ËÆ°ÁÆóËµ∑ÂßãÁ¥¢ÂºïÂíåÈ°∂ÈÉ®Â°´ÂÖÖÈ´òÂ∫¶
    for (let i = 0; i < allMessages.length; i++) {
        const msg = allMessages[i];
        const msgHeight = messageHeights.get(msg.id) || AVERAGE_MESSAGE_HEIGHT;
        if (currentScrollY + msgHeight > scrollTop) {
            startIndex = i;
            break;
        }
        currentScrollY += msgHeight;
    }

    // Â∫îÁî®overscan
    startIndex = Math.max(0, startIndex - OVERSCAN_COUNT);

    let endIndex = startIndex;
    let renderedHeight = 0;
    
    // ËÆ°ÁÆóÁªìÊùüÁ¥¢ÂºïÂíåÊ∏≤ÊüìÂå∫ÂüüÈ´òÂ∫¶
    for (let i = startIndex; i < allMessages.length; i++) {
        const msg = allMessages[i];
        const msgHeight = messageHeights.get(msg.id) || AVERAGE_MESSAGE_HEIGHT;
        renderedHeight += msgHeight;
        endIndex = i;
        if (renderedHeight >= viewportHeight + (OVERSCAN_COUNT * AVERAGE_MESSAGE_HEIGHT * 2)) { // ÂåÖÂê´‰∏ä‰∏ãoverscanÁöÑÈ´òÂ∫¶
            break;
        }
    }
    endIndex = Math.min(allMessages.length - 1, endIndex + OVERSCAN_COUNT);

    // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈáçÊñ∞Ê∏≤ÊüìÔºöÂ¶ÇÊûúËåÉÂõ¥Ê≤°ÊúâÂèòÂåñÔºåÂàô‰∏çÊìç‰Ωú
    if (lastRenderedRange.start === startIndex && lastRenderedRange.end === endIndex && !scrollToBottom) {
        return;
    }
    lastRenderedRange = { start: startIndex, end: endIndex };

    // ËÆ°ÁÆóÈ°∂ÈÉ®ÂíåÂ∫ïÈÉ®Â°´ÂÖÖÈ´òÂ∫¶
    let topPaddingHeight = 0;
    for (let i = 0; i < startIndex; i++) {
        topPaddingHeight += messageHeights.get(allMessages[i].id) || AVERAGE_MESSAGE_HEIGHT;
    }

    let totalContentHeight = topPaddingHeight; // Â∑≤ÁªèËÆ°ÁÆóÁöÑÈ°∂ÈÉ®È´òÂ∫¶
    for (let i = startIndex; i <= endIndex; i++) {
        totalContentHeight += messageHeights.get(allMessages[i].id) || AVERAGE_MESSAGE_HEIGHT;
    }

    let bottomPaddingHeight = 0;
    for (let i = endIndex + 1; i < allMessages.length; i++) {
        bottomPaddingHeight += messageHeights.get(allMessages[i].id) || AVERAGE_MESSAGE_HEIGHT;
    }
    
    topSpacerEl.style.height = `${topPaddingHeight}px`;
    bottomSpacerEl.style.height = `${bottomPaddingHeight}px`;

    // Ê∏ÖÁ©∫Âπ∂ÈáçÊñ∞Ê∑ªÂä†ÂèØËßÅÊ∂àÊÅØ
    messageWrapperEl.innerHTML = ''; // Ê∏ÖÁ©∫ÊâÄÊúâÊóßÁöÑDOMÊ∂àÊÅØ
    const fragment = document.createDocumentFragment();
    const currentRenderedIds = new Set(); // Áî®‰∫éË∑üË∏™ÂΩìÂâçÊ∏≤ÊüìÁöÑID

    for (let i = startIndex; i <= endIndex; i++) {
        const msg = allMessages[i];
        const existingEl = messageWrapperEl.querySelector(`[data-id="${msg.id}"]`); // Ê£ÄÊü•ÊòØÂê¶Â∑≤Â≠òÂú®
        if (existingEl) {
            fragment.appendChild(existingEl); 
        } else {
            const msgEl = createMessageElement(msg);
            fragment.appendChild(msgEl);
            currentRenderedIds.add(msg.id);
        }
    }
    messageWrapperEl.appendChild(fragment);

    // ÊµãÈáèÊñ∞Ê∑ªÂä†Ê∂àÊÅØÁöÑÂÆûÈôÖÈ´òÂ∫¶Âπ∂ÁºìÂ≠ò
    messageWrapperEl.querySelectorAll('.message').forEach(el => {
        const msgId = el.dataset.id;
        if (currentRenderedIds.has(msgId)) { // ‰ªÖÊµãÈáèÊñ∞Ê∑ªÂä†ÁöÑÊàñÂèØËÉΩÂèòÂåñÈ´òÂ∫¶ÁöÑ
            const actualHeight = el.offsetHeight + 16; // Âä†‰∏ämargin-bottom
            if (messageHeights.get(msgId) !== actualHeight) {
                messageHeights.set(msgId, actualHeight);
            }
        }
    });

    // Â¶ÇÊûúÊòØÊªöÂä®Âà∞Â∫ïÈÉ®ÔºåÁ°Æ‰øùÊªöÂä®Âà∞‰Ωç
    if (scrollToBottom) {
        requestAnimationFrame(() => {
            chatWindowEl.scrollTop = chatWindowEl.scrollHeight;
        });
    }

    // Ë∞ÉÊï¥‰∏Ä‰∏ãÊÄªÈ´òÂ∫¶Ôºå‰ª•Èò≤ÊµãÈáèÂêéÊÄªÈ´òÂ∫¶ÂèëÁîüÂèòÂåñ
    const newTotalHeight = topPaddingHeight + messageWrapperEl.offsetHeight + bottomPaddingHeight;
    // logDebug(`Ê∏≤ÊüìÁ™óÂè£Ôºö${startIndex}-${endIndex}, È°∂ÈÉ®: ${topPaddingHeight.toFixed(0)}, Â∫ïÈÉ®: ${bottomPaddingHeight.toFixed(0)}, ÊÄªÈ´ò: ${newTotalHeight.toFixed(0)}`, 'INFO');
}


// --- ÂàùÂßãÂåñËôöÊãüÊªöÂä®ÁªìÊûÑ ---
function initVirtualScrolling() {
    if (chatWindowEl.querySelector('.virtual-scroll-spacer')) { // ÈÅøÂÖçÈáçÂ§çÂàùÂßãÂåñ
        logDebug('ËôöÊãüÊªöÂä®Â∑≤ÂàùÂßãÂåñÔºåË∑≥Ëøá', 'INFO');
        return;
    }

    // Ê∏ÖÁ©∫ÂéüÂßãÂÜÖÂÆπ
    chatWindowEl.innerHTML = '';

    // ÂàõÂª∫È°∂ÈÉ®Â°´ÂÖÖÂÖÉÁ¥†
    topSpacerEl = document.createElement('div');
    topSpacerEl.className = 'virtual-scroll-spacer top';
    topSpacerEl.style.height = '0px';

    // ÂàõÂª∫Ê∂àÊÅØÂÆπÂô®ÔºåÁî®‰∫éÂÆπÁ∫≥ÂÆûÈôÖÊ∏≤ÊüìÁöÑÊ∂àÊÅØ
    messageWrapperEl = document.createElement('div');
    messageWrapperEl.className = 'message-container-wrapper';
    
    // ÂàõÂª∫Â∫ïÈÉ®Â°´ÂÖÖÂÖÉÁ¥†
    bottomSpacerEl = document.createElement('div');
    bottomSpacerEl.className = 'virtual-scroll-spacer bottom';
    bottomSpacerEl.style.height = '0px';

    // Â∞ÜËøô‰∫õÂÖÉÁ¥†Ê∑ªÂä†Âà∞ËÅäÂ§©Á™óÂè£
    chatWindowEl.appendChild(topSpacerEl);
    chatWindowEl.appendChild(messageWrapperEl);
    chatWindowEl.appendChild(bottomSpacerEl);

    // ÁªëÂÆöÊªöÂä®‰∫ã‰ª∂ÁõëÂê¨Âô®ÔºàËäÇÊµÅÔºâ
    chatWindowEl.addEventListener('scroll', throttle(() => {
        const currentScrollTop = chatWindowEl.scrollTop;
        const scrollDelta = Math.abs(currentScrollTop - prevScrollTop);

        // Âè™ÊúâÂΩìÊªöÂä®Ë∑ùÁ¶ªË∂ÖËøá‰∏ÄÂÆöÈòàÂÄºÔºàÂ¶Ç100pxÔºâÊó∂ÊâçÈáçÊñ∞Ê∏≤ÊüìÔºåÂáèÂ∞ë‰∏çÂøÖË¶ÅÁöÑÊ∏≤Êüì
        // ÊàñËÄÖÔºåÂú®ÊâÄÊúâÊ∂àÊÅØÈÉΩÂ∑≤ÊµãÈáèÈ´òÂ∫¶ÂêéÔºåÂèØ‰ª•Êõ¥Á≤æÁ°ÆÂú∞ËÆ°ÁÆóÊòØÂê¶ÈúÄË¶ÅÊ∏≤Êüì
        if (scrollDelta > AVERAGE_MESSAGE_HEIGHT / 2 || allMessages.length === 0) {
             renderVirtualWindow();
        }
        prevScrollTop = currentScrollTop;
    }, 100)); // ÊªöÂä®‰∫ã‰ª∂ËäÇÊµÅÔºåÊØè100msÊúÄÂ§öÊâßË°å‰∏ÄÊ¨°

    logDebug('ËôöÊãüÊªöÂä®ÁªìÊûÑÂàùÂßãÂåñÂÆåÊàê', 'SUCCESS');
    renderVirtualWindow(true); // È¶ñÊ¨°Ê∏≤ÊüìÂπ∂ÊªöÂä®Âà∞Â∫ïÈÉ®
}


// --- Ê∂àÊÅØÊ∏≤ÊüìÂáΩÊï∞ (‰ºòÂåñÁâàÔºåÁî®‰∫éÂàõÂª∫Âçï‰∏™DOMÂÖÉÁ¥†) ---
// Ê≠§ÂáΩÊï∞Âè™Ë¥üË¥£ÂàõÂª∫Ê∂àÊÅØDOMÔºå‰∏çË¥üË¥£Ê∑ªÂä†Âà∞DOMÊàñÊªöÂä®
function createMessageElement(msg) {
    const msgEl = document.createElement('div');
    msgEl.className = 'message';
    
    // Á°Æ‰øùÊâÄÊúâÁõ∏ÂÖ≥Êï∞ÊçÆÈÉΩÂ≠òÂÖ•dataset
    msgEl.dataset.id = msg.id;
    // ‰ºòÂÖà‰ΩøÁî® caption ‰Ωú‰∏∫ messageTextÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ΩøÁî® text
    msgEl.dataset.messageText = msg.caption || msg.text || ''; 
    msgEl.dataset.timestamp = msg.timestamp;
    msgEl.dataset.messageType = msg.type;
    if (msg.type === 'image') {
        msgEl.dataset.imageUrl = msg.imageUrl; // ÂõæÁâáÊ∂àÊÅØÈúÄË¶ÅÂ≠òÂÇ®URL
    }

    if (msg.username === username) msgEl.classList.add('self');
    
    const messageDate = new Date(msg.timestamp);
    const now = new Date();
    const diffSeconds = Math.floor((now - messageDate) / 1000);
    let displayTime;
    if (diffSeconds < 60) displayTime = 'ÂàöÂàö';
    else if (diffSeconds < 3600) displayTime = `${Math.floor(diffSeconds / 60)}ÂàÜÈíüÂâç`;
    else if (diffSeconds < 86400) displayTime = `${Math.floor(diffSeconds / 3600)}Â∞èÊó∂Ââç`;
    else displayTime = messageDate.toLocaleString([], { year: 'numeric', month: 'numeric', day: 'numeric', hour: '2-digit', minute: '2-digit' });
    
    let contentHTML = `<div class="info"><span class="username">${escapeHTML(msg.username)}</span> <span class="timestamp">${displayTime}</span></div>`;
            
    // Ê∂àÊÅØÂÜÖÂÆπÊ∏≤Êüì
    if (msg.type === 'image') {
        contentHTML += `<div class="message-image" onclick="showImageModal('${msg.imageUrl}')"><img src="${msg.imageUrl}" alt="${escapeHTML(msg.filename || 'Image')}" loading="lazy"></div>`;
        // Êó†ËÆ∫ caption ÊòØÂê¶‰∏∫Á©∫ÔºåÈÉΩÊ∑ªÂä†‰∏Ä‰∏™ .text div
        // marked.parse('') ‰ºöËøîÂõûÁ©∫Â≠óÁ¨¶‰∏≤Ôºå‰∏ç‰ºöÈÄ†ÊàêÈóÆÈ¢ò
        contentHTML += `<div class="text">${marked.parse(msg.caption || '')}</div>`; 
    } else if (msg.type === 'audio') {
        contentHTML += `<div class="message-audio"><audio controls src="${msg.audioUrl}"></audio></div>`;
        // Êó†ËÆ∫ text ÊòØÂê¶‰∏∫Á©∫ÔºåÈÉΩÊ∑ªÂä†‰∏Ä‰∏™ .text div
        contentHTML += `<div class="text">${marked.parse(msg.text || '')}</div>`; 
    } else { // text (ÂèäÂÖ∂‰ªñÊú™ÂÆö‰πâÁöÑÁ±ªÂûãÔºå‰ºö fallbackÂà∞textÂ§ÑÁêÜ)
        // Á°Æ‰øù text Â≠óÊÆµÂßãÁªàË¢´Â§ÑÁêÜÔºåÂç≥‰Ωø‰∏∫Á©∫Â≠óÁ¨¶‰∏≤
        contentHTML += `<div class="text">${marked.parse(msg.text || '')}</div>`;
    }
        
    msgEl.innerHTML = contentHTML;
    return msgEl;
}

// ‚ú® Ê∂àÊÅØÈòüÂàóÂ§ÑÁêÜÂáΩÊï∞ÔºåÂú® requestAnimationFrame ‰∏≠ÊâßË°å
function processMessageQueue() {
    if (messageQueue.length === 0) {
        rafScheduled = false;
        return;
    }

    const messagesToProcess = messageQueue.splice(0, Math.max(MESSAGE_BATCH_SIZE, messageQueue.length)); // Â§ÑÁêÜËá≥Â∞ëÊâπÊ¨°Â§ßÂ∞èÊàñÊâÄÊúâÂâ©‰ΩôÊ∂àÊÅØ

    logDebug(`Â§ÑÁêÜÊ∂àÊÅØÈòüÂàó: ÁßªÈô§ ${messagesToProcess.length} Êù°Ê∂àÊÅØ`, 'INFO');

    // ÊâπÈáèÊ∑ªÂä†Ê∂àÊÅØÂπ∂Êõ¥Êñ∞ÁºìÂ≠ò
    messagesToProcess.forEach(msg => {
        if (!messageIdSet.has(msg.id)) {
            allMessages.push(msg);
            messageIdSet.add(msg.id);
        } else {
            logDebug(`Ê∂àÊÅØ ${msg.id} Â∑≤Â≠òÂú®ÔºåË∑≥Ëøá`, 'INFO');
        }
    });

    // ÈôêÂà∂ÊÄªÊ∂àÊÅØÊï∞ÁªÑÁöÑÂ§ßÂ∞èÔºåÈò≤Ê≠¢ÂÜÖÂ≠òÊó†ÈôêÂ¢ûÈïø
    const MAX_ALL_MESSAGES = 500; // ‰øùÊåÅ‰∏éÂêéÁ´Ø‰∏ÄËá¥ÁöÑÁºìÂ≠òÁ≠ñÁï•ÔºåÈÅøÂÖçÂâçÁ´ØÁºìÂ≠òËøáÂ§öÂØºËá¥ÂÜÖÂ≠òÈóÆÈ¢ò
    while (allMessages.length > MAX_ALL_MESSAGES) {
        const removedMsg = allMessages.shift(); // ÁßªÈô§ÊúÄËÄÅÁöÑ‰∏ÄÊù°
        messageHeights.delete(removedMsg.id); // ‰ªéÈ´òÂ∫¶ÁºìÂ≠ò‰∏≠‰πüÁßªÈô§
        messageIdSet.delete(removedMsg.id); // ‚ú® ‰ªé ID ÈõÜÂêà‰∏≠ÁßªÈô§
    }

    // Ëß¶ÂèëËôöÊãüÁ™óÂè£Ê∏≤ÊüìÔºåÂπ∂Âº∫Âà∂ÊªöÂä®Âà∞Â∫ïÈÉ®
    renderVirtualWindow(true); 
    throttledUpdateUI(); // Ëß¶ÂèëÁî®Êà∑ÂàóË°®Êõ¥Êñ∞

    // Â¶ÇÊûúÈòüÂàó‰∏≠ËøòÊúâÊ∂àÊÅØÔºåÁªßÁª≠Ë∞ÉÂ∫¶‰∏ã‰∏Ä‰∏™ requestAnimationFrame
    if (messageQueue.length > 0) {
        requestAnimationFrame(processMessageQueue);
    } else {
        rafScheduled = false;
    }
}

// ‚ú® ‰øÆÊîπ appendChatMessageÔºåÂè™Ë¥üË¥£ÂÖ•ÈòüÂíåË∞ÉÂ∫¶
function appendChatMessage(msg) {
    if (!msg || !msg.id) {
        logDebug("appendChatMessage Êî∂Âà∞Êó†ÊïàÊ∂àÊÅØ", 'error', msg);
        return;
    }
    
    if (messageIdSet.has(msg.id)) {
        logDebug(`Êî∂Âà∞ÈáçÂ§çÊ∂àÊÅØ (ID: ${msg.id})ÔºåÂ∑≤ÂøΩÁï•`, 'INFO');
        return;
    }

    messageQueue.push(msg);
    logDebug(`Ê∂àÊÅØÂÖ•Èòü (ID: ${msg.id}). ÈòüÂàóÈïøÂ∫¶: ${messageQueue.length}`, 'INFO');

    // Â¶ÇÊûúËøòÊ≤°ÊúâË∞ÉÂ∫¶ÔºåÂàôË∞ÉÂ∫¶‰∏Ä‰∏™ requestAnimationFrame
    if (!rafScheduled) {
        rafScheduled = true;
        // ‰ΩøÁî® setTimeout ÂºïÂÖ•‰∏Ä‰∏™Â∞èÁöÑÈò≤ÊäñÔºåÈÅøÂÖçÊ∂àÊÅØÈ¢ëÁπÅÂà∞Êù•Êó∂Á´ãÂç≥Ëß¶Âèë RAF
        setTimeout(() => {
            if (rafScheduled) { // ÂÜçÊ¨°Ê£ÄÊü•Á°Æ‰øùÊ≤°ÊúâË¢´ÂèñÊ∂à
                requestAnimationFrame(processMessageQueue);
            }
        }, MESSAGE_BATCH_DEBOUNCE_MS);
    }
}


// --- ‰∏ä‰∏ãÊñáËèúÂçïÂíå AI Ëß£ÈáäÈÄªËæë ---
// (ËøôÈÉ®ÂàÜ‰øùÊåÅ‰∏çÂèòÔºåÂõ†‰∏∫ÂÆÉ‰∏çÁõ¥Êé•ÂΩ±ÂìçÊ∂àÊÅØÊ∏≤ÊüìÊÄßËÉΩÔºå‰ΩÜ‰∏éÊ∂àÊÅØÂÖÉÁ¥†‰∫íÂä®)
function showContextMenu(element, x, y) {
    currentMessageElement = element; // Â∞ÜÂΩìÂâçÂè≥ÈîÆÁÇπÂáªÁöÑÊ∂àÊÅØÂÖÉÁ¥†Â≠ò‰∏∫ÂÖ®Â±ÄÂèòÈáè
    
    // ÂÆö‰ΩçËèúÂçï
    contextMenu.style.top = `${y}px`;
    contextMenu.style.left = `${x}px`;
    contextMenu.style.display = 'block';

    const messageType = element.dataset.messageType;
    const isSelf = element.classList.contains('self'); // Âà§Êñ≠ÊòØÂê¶ÊòØËá™Â∑±ÂèëÁöÑÊ∂àÊÅØ

    // Ëé∑ÂèñÊâÄÊúâËèúÂçïÈ°π
    const geminiTextOption = contextMenu.querySelector('[data-ai="gemini"][data-action="text-explain"]');
    const deepseekTextOption = contextMenu.querySelector('[data-ai="deepseek"][data-action="text-explain"]');
    const geminiImageOption = contextMenu.querySelector('[data-ai="gemini"][data-action="image-describe"]');
    const copyOption = document.getElementById('copy-option');
    const deleteOption = document.getElementById('delete-option');

    // --- Ê†πÊçÆÊ∂àÊÅØÁ±ªÂûãÂä®ÊÄÅÊòæÁ§∫/ÈöêËóèËèúÂçïÈ°π ---

    // ÈªòËÆ§ÂÖàÈöêËóèÊâÄÊúâÁâπÂÆöÂäüËÉΩÁöÑËèúÂçïÈ°π
    geminiTextOption.style.display = 'none';
    deepseekTextOption.style.display = 'none';
    geminiImageOption.style.display = 'none';
    copyOption.style.display = 'none';
    
    // Ê†πÊçÆÁ±ªÂûãÂÜ≥ÂÆöÊòæÁ§∫Âì™‰∫õ
    if (messageType === 'image') {
        geminiImageOption.style.display = 'flex'; // ÊòæÁ§∫ÂõæÁâáËß£Èáä
    } else if (messageType === 'text') {
        geminiTextOption.style.display = 'flex'; // ÊòæÁ§∫ÊñáÊú¨Ëß£Èáä
        deepseekTextOption.style.display = 'flex';
        copyOption.style.display = 'flex';       // ÊòæÁ§∫Â§çÂà∂
    }
    // ÂØπ‰∫éÈü≥È¢ëÁ≠âÂÖ∂‰ªñÁ±ªÂûãÔºåÊâÄÊúâAIÂíåÂ§çÂà∂ÂäüËÉΩÈÉΩ‰øùÊåÅÈöêËóè

    // --- Ê†πÊçÆÊòØÂê¶‰∏∫Ëá™Â∑±ÁöÑÊ∂àÊÅØÔºåÂÜ≥ÂÆöÊòØÂê¶ÊòæÁ§∫Âà†Èô§ÊåâÈíÆ ---
    deleteOption.style.display = isSelf ? 'flex' : 'none';
    
    if (navigator.vibrate) navigator.vibrate(50); // ÁßªÂä®Á´ØÈúáÂä®ÂèçÈ¶à
}

contextMenu.addEventListener('click', async (e) => {
    const clickedOption = e.target;
    // Á°Æ‰øùÁÇπÂáªÁöÑÊòØËèúÂçïÈ°πÔºåËÄå‰∏çÊòØËèúÂçïËÉåÊôØÊàñÂÖ∂‰ªñÂú∞Êñπ
    if (!clickedOption.closest('li')) return; 

    const action = clickedOption.dataset.action;
    const model = clickedOption.dataset.ai;
    
    // Ëé∑ÂèñÂéüÂßãÊ∂àÊÅØÂÜÖÂÆπ
    const originalMessageText = currentMessageElement?.dataset.messageText;
    const originalImageUrl = currentMessageElement?.dataset.imageUrl;
    const messageType = currentMessageElement?.dataset.messageType;

    // Ê∏ÖÈô§ÂΩìÂâçÁöÑÂè≥ÈîÆËèúÂçï
    contextMenu.style.display = 'none';

    // Â§ÑÁêÜÂ§çÂà∂ÈÄâÈ°π
    if (clickedOption.id === 'copy-option') {
        if (originalMessageText) {
            navigator.clipboard.writeText(originalMessageText)
                .then(() => showAppNotification('ÊñáÊú¨Â∑≤Â§çÂà∂!'))
                .catch(err => logDebug(`Â§çÂà∂Â§±Ë¥•: ${err}`, LOG_LEVELS.ERROR));
        }
        return; // Â§ÑÁêÜÂÆåÂ§çÂà∂Â∞±ËøîÂõû
    }

    // Â§ÑÁêÜÂà†Èô§ÈÄâÈ°π
    if (clickedOption.id === 'delete-option') {
        if (currentMessageElement?.dataset.id) {
            // ÂèØ‰ª•Âú®ËøôÈáåÂä†‰∏Ä‰∏™Á°ÆËÆ§ÂºπÁ™ó
            if (confirm("Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°Ê∂àÊÅØÂêóÔºü")) {
                socket.send(JSON.stringify({ type: 'delete', payload: { id: currentMessageElement.dataset.id } }));
                logDebug(`ÂèëÈÄÅÂà†Èô§Ê∂àÊÅØÊåá‰ª§: ${currentMessageElement.dataset.id}`, LOG_LEVELS.INFO);
            }
        }
        return; // Â§ÑÁêÜÂÆåÂà†Èô§Â∞±ËøîÂõû
    }

    // Â§ÑÁêÜAIËß£Èáä/ÊèèËø∞ÈÄâÈ°π
    let explanationText = "";
    let requestBody = {};
    let apiUrl = '';

    if (action === 'image-describe' && messageType === 'image') {
        if (!originalImageUrl) {
            logDebug("ÂõæÁâáÊèèËø∞ÔºöÁº∫Â∞ëÂõæÁâáURL", LOG_LEVELS.WARNING);
            return;
        }
        apiUrl = '/ai-describe-image';
        requestBody = { imageUrl: originalImageUrl };
        explanationText = "Ê≠£Âú®ÈÄöËøáAIÊ®°ÂûãËß£ËØªÂõæÁâá...";
    } else if (action === 'text-explain' && messageType === 'text') {
        if (!originalMessageText) {
            logDebug("ÊñáÊú¨Ëß£ÈáäÔºöÁº∫Â∞ëÊñáÊú¨ÂÜÖÂÆπ", LOG_LEVELS.WARNING);
            return;
        }
        apiUrl = '/ai-explain';
        requestBody = { text: originalMessageText, model: model };
        explanationText = `Ê≠£Âú®ÈÄöËøá ${model} Ê®°ÂûãÊÄùËÄÉ‰∏≠...`;
    } else if (action === 'custom-prompt' && messageType === 'text') { // Â¶ÇÊûúÈúÄË¶ÅËá™ÂÆö‰πâÊèêÁ§∫ËØçÂäüËÉΩ
        const customPrompt = prompt("ËØ∑ËæìÂÖ•ÊÇ®ÁöÑÊèêÁ§∫ËØç:");
        if (!customPrompt || !originalMessageText) {
            logDebug("Ëá™ÂÆö‰πâÊèêÁ§∫ËØçÔºöÁî®Êà∑ÂèñÊ∂àÊàñÁº∫Â∞ëÊñáÊú¨ÂÜÖÂÆπ", LOG_LEVELS.INFO);
            return;
        }
        apiUrl = '/ai-explain';
        requestBody = { text: `${originalMessageText}\n\n${customPrompt}`, model: 'gemini' }; // ÈªòËÆ§‰ΩøÁî®GeminiÂ§ÑÁêÜËá™ÂÆö‰πâÊèêÁ§∫
        explanationText = `Ê≠£Âú®‰ΩøÁî®ÊÇ®ÁöÑËá™ÂÆö‰πâÊèêÁ§∫ËØçÈÄöËøá Gemini Ê®°ÂûãÊÄùËÄÉ‰∏≠...`;
    } else {
        // Êú™Áü•Êàñ‰∏çÂåπÈÖçÁöÑ AI Âä®‰ΩúÔºåÊàñÁ±ªÂûã‰∏çÁ¨¶ÔºåÁõ¥Êé•ËøîÂõû
        logDebug(`AIÊìç‰ΩúÂ§±Ë¥•ÔºöÊú™Áü•Âä®‰ΩúÊàñÊ∂àÊÅØÁ±ªÂûã‰∏çÂåπÈÖç„ÄÇAction: ${action}, Type: ${messageType}`, LOG_LEVELS.WARNING);
        return;
    }

    // Âú®Ê∂àÊÅØ‰∏ãÊñπÊòæÁ§∫ AI Ëß£ÈáäÂÆπÂô®
    const existingExplanation = currentMessageElement.querySelector('.ai-explanation');
    if (existingExplanation) {
        existingExplanation.remove();
    }
    
    const explanationEl = document.createElement('div');
    explanationEl.className = 'ai-explanation';
    explanationEl.innerHTML = `<p>ü§ñ ${explanationText}<span class="loading-dots"></span></p>`;
    currentMessageElement.appendChild(explanationEl);

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(errorText); // ÊäõÂá∫ÂêéÁ´ØËøîÂõûÁöÑÈîôËØØ‰ø°ÊÅØ
        }
        
        const data = await response.json();
        const explanationContent = data.explanation || data.description; // ÂÖºÂÆπ‰∏§Áßç AI ÂìçÂ∫î
        
        explanationEl.innerHTML = ''; // Ê∏ÖÁ©∫Âä†ËΩΩÊèêÁ§∫
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'ai-explanation-buttons';

        const closeBtn = document.createElement('button');
        closeBtn.className = 'ai-explanation-close';
        closeBtn.innerHTML = '√ó';
        closeBtn.onclick = () => {
            explanationEl.remove();
            logDebug('AIËß£ÈáäÂ∑≤ÂÖ≥Èó≠„ÄÇ', LOG_LEVELS.INFO);
        };

        const copyBtn = document.createElement('button');
        copyBtn.className = 'ai-explanation-copy';
        copyBtn.innerHTML = 'üìã';
        copyBtn.title = 'Â§çÂà∂ÂÜÖÂÆπ';
        copyBtn.onclick = () => {
            navigator.clipboard.writeText(explanationContent)
                .then(() => showAppNotification('AIËß£ÈáäÂ∑≤Â§çÂà∂!'))
                .catch(err => logDebug(`AIËß£ÈáäÂ§çÂà∂Â§±Ë¥•: ${err}`, LOG_LEVELS.ERROR));
        };

        buttonContainer.appendChild(copyBtn);
        buttonContainer.appendChild(closeBtn);

        const markdownContainer = document.createElement('div');
        markdownContainer.className = 'markdown-content';
        markdownContainer.innerHTML = marked.parse(explanationContent, { gfm: true, breaks: true, sanitize: true });
        
        explanationEl.appendChild(buttonContainer);
        explanationEl.appendChild(markdownContainer);
        logDebug(`AIËß£ÈáäÊàêÂäüÔºåÊ®°Âûã: ${model || 'ÂõæÁâáÊèèËø∞'}.`, LOG_LEVELS.SUCCESS);

    } catch (error) {
        logDebug(`ËØ∑Ê±ÇAIËß£ÈáäÂ§±Ë¥•: ${error.message}`, LOG_LEVELS.ERROR, error);
        const errorModelName = (action === 'image-describe') ? 'AIÂõæÁâáÊèèËø∞' : (model || 'Êú™Áü•AIÊ®°Âûã');
        explanationEl.innerHTML = `<p>üòû Êä±Ê≠âÔºåÊó†Ê≥ï‰ªé ${errorModelName} Ëé∑ÂèñËß£Èáä: ${escapeHTML(error.message)}</p>`;
        setTimeout(() => { if (explanationEl.parentNode) explanationEl.remove(); }, 6000); // ÈîôËØØ‰ø°ÊÅØÊòæÁ§∫6ÁßíÂêéËá™Âä®Ê∂àÂ§±
    }
});


// --- ÂõæÁâáÂíåÂ™í‰ΩìÂ§ÑÁêÜÂáΩÊï∞ ---
async function handleImageSelection(e) {
    const file = e.target.files[0];
    if (!file || !file.type.startsWith('image/')) return;
    try {
        uploadProgress.style.display = 'block';
        imagePreview.classList.add('show', 'uploading');
        const compressedBlob = await compressImage(file);
        selectedFile = new File([compressedBlob], file.name, { type: 'image/jpeg', lastModified: Date.now() });
        showImagePreview(selectedFile);
    } catch (error) {
        logDebug('ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•: ' + error, LOG_LEVELS.ERROR);
        showAppNotification('ÂõæÁâáÂ§ÑÁêÜÂ§±Ë¥•ÔºåËØ∑ÈáçËØï', 3000, true); // Changed from alert
    } finally {
        uploadProgress.style.display = 'none';
        imagePreview.classList.remove('uploading');
        checkSendButtonState();
    }
}

function compressImage(file, maxWidth = 800, maxHeight = 600, quality = 0.8) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
            let { width, height } = img;
            if (width > height) {
                if (width > maxWidth) { height *= maxWidth / width; width = maxWidth; }
            } else {
                if (height > maxHeight) { width *= maxHeight / height; height = maxHeight; }
            }
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, width, height);
            canvas.toBlob(resolve, 'image/jpeg', quality);
        };
        img.onerror = reject;
        img.src = URL.createObjectURL(file);
    });
}

function showImagePreview(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
        previewImage.src = e.target.result;
        previewName.textContent = file.name;
        previewSize.textContent = formatFileSize(file.size);
        imagePreview.classList.add('show');
    };
    reader.readAsDataURL(file);
}

function removeImagePreview() {
    selectedFile = null;
    imagePreview.classList.remove('show');
    imageInput.value = '';
    checkSendButtonState();
}

async function handleRecordButtonClick() {
    if (isRecording) {
        mediaRecorder.stop();
        return;
    }
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const mimeType = ['audio/mp4', 'audio/webm;codecs=opus', 'audio/webm'].find(t => MediaRecorder.isTypeSupported(t));
        if (!mimeType) {
            showAppNotification('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅÂΩïÈü≥ÂäüËÉΩ„ÄÇ', 3000, true); // Changed from alert
            return;
        }
        mediaRecorder = new MediaRecorder(stream, { mimeType });
        audioChunks = [];
        mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
        mediaRecorder.onstart = () => {
            recordButton.textContent = 'üõë';
            isRecording = true;
            checkSendButtonState();
        };
        mediaRecorder.onstop = () => {
            const audioBlob = new Blob(audioChunks, { type: mimeType });
            sendAudioMessage(audioBlob, mimeType);
            stream.getTracks().forEach(track => track.stop());
            recordButton.textContent = 'üé§';
            isRecording = false;
            checkSendButtonState();
        };
        mediaRecorder.start();
    } catch (error) {
        logDebug('Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£é: ' + error, LOG_LEVELS.ERROR);
        showAppNotification('Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£éÔºåËØ∑Ê£ÄÊü•ÊùÉÈôê„ÄÇ', 3000, true); // Changed from alert
    }
}

function checkSendButtonState() {
    sendButton.disabled = (messageInput.value.trim() === '' && selectedFile === null && !isRecording);
}


// --- Ê∂àÊÅØÂèëÈÄÅÂáΩÊï∞ (ÁÆÄÂåñÁâà) ---
messageForm.addEventListener('submit', async (e) => {
    e.preventDefault();
    const text = messageInput.value.trim();
    const isSocketReady = socket && socket.readyState === WebSocket.OPEN;

    if ((!text && !selectedFile && !isRecording) || !isSocketReady) {
        checkSendButtonState();
        return;
    }
    
    // Á¶ÅÁî®ÂèëÈÄÅÊåâÈíÆÈò≤Ê≠¢ÈáçÂ§çÊèê‰∫§
    sendButton.disabled = true;
    
    try {
        if (selectedFile) {
            // ÂèëÈÄÅÂõæÁâáÊ∂àÊÅØ
            await sendImageMessage(selectedFile, text);
        } else if (text) {
            // ‰πêËßÇÊõ¥Êñ∞ÔºöÂâçÁ´ØÂÖàÁîüÊàê‰∏Ä‰∏™‰∏¥Êó∂IDÂíåÊó∂Èó¥Êà≥
            const tempId = crypto.randomUUID();
            const tempTimestamp = Date.now();
            
            socket.send(JSON.stringify({ 
                type: 'chat', 
                payload: { 
                    id: tempId,          // ÂåÖÂê´‰∏¥Êó∂ID
                    timestamp: tempTimestamp, // ÂåÖÂê´‰∏¥Êó∂Êó∂Èó¥Êà≥
                    type: 'text',
                    text: text 
                } 
            }));
            
            // Ê∏ÖÁêÜËæìÂÖ•Ê°Ü
            messageInput.value = '';
            messageInput.style.height = 'auto';
        }
    } catch (error) {
        logDebug('ÂèëÈÄÅÊ∂àÊÅØËøáÁ®ã‰∏≠Âá∫Áé∞ÈîôËØØ: ' + error, 'error', error);
        showAppNotification('ÂèëÈÄÅÂ§±Ë¥•ÔºåËØ∑ÈáçËØï', 3000, true); // Changed from alert
    } finally {
        // ÊÅ¢Â§çUIÁä∂ÊÄÅ
        removeImagePreview();
        checkSendButtonState();
    }
});

// --- ÂõæÁâáÊñá‰ª∂‰∏ä‰º†ÂáΩÊï∞ (ÁÆÄÂåñÁâà) ---
async function sendImageMessage(file, caption = '') {
    try {
        logDebug(`ÂºÄÂßã‰∏ä‰º†ÂõæÁâá: ${file.name}`, LOG_LEVELS.INFO);
        
        // ÊòæÁ§∫‰∏ä‰º†ËøõÂ∫¶UI
        uploadProgress.style.display = 'block';
        uploadProgress.textContent = '‰∏ä‰º†‰∏≠...';
        imagePreview.classList.add('uploading');
        
        // ÂàõÂª∫FormDataÂπ∂Ê∑ªÂä†Ê≠£Á°ÆÊñá‰ª∂ÂêçÁöÑÊñá‰ª∂
        const safeFileName = encodeURIComponent(file.name);
        
        // ‰∏ä‰º†Êñá‰ª∂Âà∞R2Â≠òÂÇ®
        const response = await fetch('/upload', {
            method: 'POST',
            body: file,
            headers: {
                'X-Filename': safeFileName,
                'Content-Type': file.type
            }
        });
        
        if (!response.ok) {
            throw new Error(`‰∏ä‰º†Â§±Ë¥•: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.url) {
            throw new Error('ÊúçÂä°Âô®Ê≤°ÊúâËøîÂõûÊúâÊïàÁöÑÊñá‰ª∂URL');
        }
        
        logDebug(`ÂõæÁâá‰∏ä‰º†ÊàêÂäüÔºåËé∑ÂèñURL: ${data.url}`, LOG_LEVELS.SUCCESS);
        
        // ‰πêËßÇÊõ¥Êñ∞ÔºöÂâçÁ´ØÂÖàÁîüÊàê‰∏Ä‰∏™‰∏¥Êó∂IDÂíåÊó∂Èó¥Êà≥
        const tempId = crypto.randomUUID();
        const tempTimestamp = Date.now();

        // ÂèëÈÄÅÂõæÁâáÊ∂àÊÅØÈÄöËøáWebSocket
        const payload = {
            type: 'image',
            text: caption, 
            caption: caption,
            imageUrl: data.url, // ÂèëÈÄÅÊúçÂä°Âô®ËøîÂõûÁöÑURL
            filename: file.name,
            size: file.size,
            id: tempId,          // ÂåÖÂê´‰∏¥Êó∂IDÂíåÊó∂Èó¥Êà≥
            timestamp: tempTimestamp
        };
        
        socket.send(JSON.stringify({
            type: 'chat',
            payload: payload
        }));
        
        logDebug("ÂõæÁâáÊ∂àÊÅØÂ∑≤ÈÄöËøáWebSocketÂèëÈÄÅ", LOG_LEVELS.SUCCESS);
        
        // Ê∏ÖÁêÜUI
        messageInput.value = '';
        messageInput.style.height = 'auto';
        removeImagePreview();
        
        return true;
    } catch (error) {
        logDebug(`ÂõæÁâá‰∏ä‰º†Â§±Ë¥•: ${error.message}`, LOG_LEVELS.ERROR, error);
        showAppNotification(`ÂõæÁâá‰∏ä‰º†Â§±Ë¥•: ${error.message}`, 3000, true); // Changed from alert
        throw error;
    } finally {
        // ÈöêËóè‰∏ä‰º†ËøõÂ∫¶UI
        uploadProgress.style.display = 'none';
        imagePreview.classList.remove('uploading');
    }
}

// --- Èü≥È¢ëÊñá‰ª∂‰∏ä‰º†ÂáΩÊï∞ (ÁÆÄÂåñÁâà) ---
async function sendAudioMessage(audioBlob, mimeType) {
    try {
        logDebug(`ÂºÄÂßã‰∏ä‰º†Èü≥È¢ë`, LOG_LEVELS.INFO, { size: audioBlob.size, type: mimeType });
        
        // ÁîüÊàêÈü≥È¢ëÊñá‰ª∂Âêç
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `audio-${timestamp}.${mimeType.includes('mp4') ? 'mp4' : 'webm'}`;
        const safeFileName = encodeURIComponent(filename);
        
        // ‰∏ä‰º†Èü≥È¢ëÂà∞R2Â≠òÂÇ®
        const response = await fetch('/upload', {
            method: 'POST',
            body: audioBlob,
            headers: {
                'X-Filename': safeFileName,
                'Content-Type': mimeType
            }
        });
        
        if (!response.ok) {
            throw new Error(`‰∏ä‰º†Â§±Ë¥•: ${response.status} ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.url) {
            throw new Error('ÊúçÂä°Âô®Ê≤°ÊúâËøîÂõûÊúâÊïàÁöÑÊñá‰ª∂URL');
        }
        
        logDebug(`Èü≥È¢ë‰∏ä‰º†ÊàêÂäüÔºåËé∑ÂèñURL: ${data.url}`, LOG_LEVELS.SUCCESS);
        
        // ‰πêËßÇÊõ¥Êñ∞ÔºöÂâçÁ´ØÂÖàÁîüÊàê‰∏Ä‰∏™‰∏¥Êó∂IDÂíåÊó∂Èó¥Êà≥
        const tempId = crypto.randomUUID();
        const tempTimestamp = Date.now();

        // ÂèëÈÄÅÈü≥È¢ëÊ∂àÊÅØÈÄöËøáWebSocket
        const payload = {
            type: 'audio',
            text: '', // Ê†∏ÂøÉ‰øÆÊ≠£Ôºö‰∏∫Èü≥È¢ëÊ∂àÊÅØÊ∑ªÂä†Á©∫ÁöÑ text Â≠óÊÆµ
            audioUrl: data.url, // ÂèëÈÄÅÊúçÂä°Âô®ËøîÂõûÁöÑURL
            filename: filename,
            size: audioBlob.size,
            id: tempId,          // ÂåÖÂê´‰∏¥Êó∂IDÂíåÊó∂Èó¥Êà≥
            timestamp: tempTimestamp
        };
        
        socket.send(JSON.stringify({
            type: 'chat',
            payload: payload
        }));
        
        logDebug("Èü≥È¢ëÊ∂àÊÅØÂ∑≤ÈÄöËøáWebSocketÂèëÈÄÅ", LOG_LEVELS.SUCCESS);
        
        return true;
    } catch (error) {
        logDebug(`Èü≥È¢ë‰∏ä‰º†Â§±Ë¥•: ${error.message}`, LOG_LEVELS.ERROR, error);
        showAppNotification(`Èü≥È¢ë‰∏ä‰º†Â§±Ë¥•: ${error.message}`, 3000, true); // Changed from alert
        throw error;
    }
}

// ‚ú® ‰ºòÂåñÁöÑÂéÜÂè≤Ê∂àÊÅØÂ§ÑÁêÜÂáΩÊï∞
async function processHistoryMessages(history) {
    if (!Array.isArray(history)) {
        logDebug("ÂéÜÂè≤ËÆ∞ÂΩïÊ†ºÂºè‰∏çÊ≠£Á°ÆÔºåÂ∑≤ÂøΩÁï•„ÄÇ", 'warn');
        isVirtualScrollInitialized = true; 
        historicalMessagesLoading = false;
        processMessageQueue(); // Â∞ùËØïÂ§ÑÁêÜÈòüÂàó‰∏≠ÁöÑ‰ªª‰ΩïÊöÇÂ≠òÊ∂àÊÅØ
        return;
    }
    
    logDebug(`ÂºÄÂßãÂ§ÑÁêÜ ${history.length} Êù°ÂéÜÂè≤ËÆ∞ÂΩï...`);
    historicalMessagesLoading = true; // Ê†áËÆ∞Ê≠£Âú®Âä†ËΩΩÂéÜÂè≤
    
    // ÈáçÁΩÆÁä∂ÊÄÅ
    chatWindowEl.innerHTML = ''; // Ê∏ÖÁ©∫
    allMessages = [];
    messageIdSet.clear(); // ‚ú® Ê∏ÖÁ©∫ ID ÈõÜÂêà
    messageHeights.clear();
    isVirtualScrollInitialized = false; 
    
    // ÂàùÂßãÂåñËôöÊãüÊªöÂä®ÁªìÊûÑ
    initVirtualScrolling(); 
    
    const CHUNK_SIZE = 50; // ÊØèÊ¨°Â§ÑÁêÜ50Êù°Ê∂àÊÅØ
    let processedCount = 0;

    const processChunk = (deadline) => {
        let chunkStartTime = Date.now();
        while (processedCount < history.length && (deadline.timeRemaining() > 0 || (Date.now() - chunkStartTime < 16))) {
            const msg = history[processedCount];
            if (msg && msg.id && !messageIdSet.has(msg.id)) {
                allMessages.push(msg);
                messageIdSet.add(msg.id);
            } else if (msg && msg.id && messageIdSet.has(msg.id)) {
                logDebug(`ÂéÜÂè≤Ê∂àÊÅØ‰∏≠ÂèëÁé∞ÈáçÂ§çID: ${msg.id}, Â∑≤Ë∑≥Ëøá„ÄÇ`, 'INFO');
            } else {
                logDebug(`ÂéÜÂè≤Ê∂àÊÅØ‰∏≠ÂèëÁé∞Êó†ÊïàÊ∂àÊÅØÔºåÂ∑≤Ë∑≥Ëøá„ÄÇ`, 'WARN', msg);
            }
            processedCount++;
        }

        renderVirtualWindow(true); // ÊØèÊ¨°Â§ÑÁêÜÂÆå‰∏Ä‰∏™ chunk ÂêéÊ∏≤Êüì‰∏ÄÊ¨°ÔºåÂπ∂‰øùÊåÅÊªöÂä®Âà∞Â∫ïÈÉ®

        if (processedCount < history.length) {
            logDebug(`Â§ÑÁêÜÂéÜÂè≤‰∏≠... Â∑≤ÂÆåÊàê ${processedCount}/${history.length} Êù°„ÄÇ`, 'INFO');
            // Â¶ÇÊûúËøòÊúâÂâ©‰ΩôÊ∂àÊÅØÔºåËØ∑Ê±Ç‰∏ã‰∏Ä‰∏™Á©∫Èó≤ÂõûË∞É
            requestIdleCallback(processChunk, { timeout: 1000 });
        } else {
            logDebug("ÊâÄÊúâÂéÜÂè≤ËÆ∞ÂΩïÂ§ÑÁêÜÂÆåÊØï„ÄÇ", 'SUCCESS');
            isVirtualScrollInitialized = true;
            historicalMessagesLoading = false;
            // ÂéÜÂè≤Â§ÑÁêÜÂÆåÊàêÂêéÔºåÁ´ãÂç≥Â§ÑÁêÜÊâÄÊúâÊöÇÂ≠òÁöÑÊñ∞Ê∂àÊÅØ
            processMessageQueue(); 
        }
    };

    // ÂêØÂä®Á¨¨‰∏Ä‰∏™Á©∫Èó≤ÂõûË∞ÉÊù•Â§ÑÁêÜÂéÜÂè≤ËÆ∞ÂΩï
    if (history.length > 0 && 'requestIdleCallback' in window) {
        requestIdleCallback(processChunk, { timeout: 1000 });
    } else {
        // Â¶ÇÊûúÊµèËßàÂô®‰∏çÊîØÊåÅ requestIdleCallback ÊàñÊ≤°ÊúâÂéÜÂè≤ËÆ∞ÂΩïÔºåÂàôÁ´ãÂç≥Â§ÑÁêÜ
        history.forEach(msg => {
            if (msg && msg.id && !messageIdSet.has(msg.id)) {
                allMessages.push(msg);
                messageIdSet.add(msg.id);
            }
        });
        logDebug("ÂéÜÂè≤ËÆ∞ÂΩïÂ§ÑÁêÜÂÆåÊØï (Êó†requestIdleCallbackÊàñÊó†ÂéÜÂè≤).", 'SUCCESS');
        isVirtualScrollInitialized = true;
        historicalMessagesLoading = false;
        renderVirtualWindow(true);
        processMessageQueue(); // Á´ãÂç≥Â§ÑÁêÜÈòüÂàó‰∏≠ÁöÑ‰ªª‰ΩïÊöÇÂ≠òÊ∂àÊÅØ
    }
}


// --- WebSocket ‰∫ã‰ª∂Â§ÑÁêÜÂô® (‰ºòÂåñÁâà) ---
function connectWebSocket() {
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${wsProtocol}//${window.location.host}/${roomName}?username=${encodeURIComponent(username)}`;
    logDebug(`ÂºÄÂßãËøûÊé•WebSocket: ${wsUrl}`, LOG_LEVELS.INFO);
    socket = new WebSocket(wsUrl);
    socket.onopen = onSocketOpen;
    socket.onmessage = onSocketMessage;
    socket.onclose = onSocketClose;
    socket.onerror = onSocketError;
}

function onSocketOpen() {
    statusEl.textContent = 'Â∑≤ËøûÊé•';
    connectionDot.classList.remove('disconnected');
    reconnectInterval = 1000; // ÈáçÁΩÆÈáçËøûÈó¥Èöî
    checkSendButtonState();
    logDebug('WebSocketËøûÊé•Â∑≤Âª∫Á´ã', LOG_LEVELS.SUCCESS);
    // ÂêØÂä®Áî®Êà∑ÂàóË°®ÂÆöÊó∂Êõ¥Êñ∞ÔºàÂ¶ÇÊûú‰πãÂâçÊ≤°ÊúâÔºâ
    if (!window.userListInterval) {
        window.userListInterval = setInterval(updateUIFromMessages, 60000); // 1ÂàÜÈíüÊõ¥Êñ∞‰∏ÄÊ¨°Áî®Êà∑ÂàóË°®ÔºåÊØî‰πãÂâç10ÂàÜÈíüÊõ¥È¢ëÁπÅ
    }
}

// ‚ú® Á≠ñÁï•Ê®°Âºè‰ºòÂåñ: Ê∂àÊÅØÂ§ÑÁêÜÂáΩÊï∞Êò†Â∞Ñ
const messageHandlers = {
    welcome: (payload) => {
        const history = payload?.history;
        if (Array.isArray(history)) {
            processHistoryMessages(history);
        } else {
            logDebug("Êî∂Âà∞ÁöÑÊ¨¢ËøéÊ∂àÊÅØ‰∏≠ history Ê†ºÂºè‰∏çÊ≠£Á°ÆÊàñ‰∏çÂ≠òÂú®„ÄÇ", LOG_LEVELS.ERROR, payload);
        }
    },
    chat: (payload) => {
        const newMessage = payload;
        if (newMessage && newMessage.id) {
            // Â¶ÇÊûúÂéÜÂè≤Ê∂àÊÅØÊ≠£Âú®Âä†ËΩΩÔºåÊñ∞Ê∂àÊÅØÂÖàÂÖ•ÈòüÔºå‰∏çÁõ¥Êé•Â§ÑÁêÜ
            // appendChatMessage ‰ºöËá™Âä®ËøõË°åÂéªÈáç
            appendChatMessage(newMessage);
        }
        throttledUpdateUI(); // Ëß¶ÂèëÁî®Êà∑ÂàóË°®Á≠âUIÁöÑÊõ¥Êñ∞
    },
    user_join: (payload) => {
        logDebug(`ÂâçÁ´ØÊ∂àÊÅØ: ${payload.username} Âä†ÂÖ•‰∫Ü`, LOG_LEVELS.INFO, payload);
        throttledUpdateUI(); 
    },
    user_leave: (payload) => {
        logDebug(`ÂâçÁ´ØÊ∂àÊÅØ: ${payload.username} Á¶ªÂºÄ‰∫Ü`, LOG_LEVELS.INFO, payload);
        throttledUpdateUI(); 
    },
    delete: (payload) => {
        const { messageId } = payload;
        if (messageId) {
            logDebug(`Êî∂Âà∞Âà†Èô§Êåá‰ª§ÔºåÂáÜÂ§áÁßªÈô§Ê∂àÊÅØ: ${messageId}`, LOG_LEVELS.WARNING);
            allMessages = allMessages.filter(m => m.id !== messageId);
            messageIdSet.delete(messageId); // ‚ú® ‰ªé ID ÈõÜÂêà‰∏≠ÁßªÈô§
            messageHeights.delete(messageId); 
            renderVirtualWindow(); 
            throttledUpdateUI(); 
        }
    },
    error: (payload) => {
        logDebug(`Êî∂Âà∞ÂêéÁ´ØÈîôËØØÈÄöÁü•: ${payload?.message}`, LOG_LEVELS.ERROR, payload);
        showAppNotification(payload?.message || "ÂèëÁîüÊú™Áü•ÈîôËØØ", 5000, true); // Changed from alert
        sendButton.disabled = false;
    },
    offer: (payload) => handleOffer(payload),
    answer: (payload) => handleAnswer(payload),
    candidate: (payload) => handleCandidate(payload),
    call_end: (payload) => handleCallEnd(payload),
    debug_log: (payload) => {
        logDebug(`[ÂêéÁ´ØÊó•Âøó] ${payload.message}`, payload.level.toLowerCase(), payload.data);
    },
    heartbeat: () => {
        // ÂøÉË∑≥Ê∂àÊÅØ‰∏çÈúÄË¶ÅÂú®DOMÊó•Âøó‰∏≠ÊòæÁ§∫ÔºåÊéßÂà∂Âè∞Â∑≤Â§ÑÁêÜ
        // ‰∏î‰∏çÈúÄË¶ÅÂÖ∂‰ªñÂ§ÑÁêÜÔºåËøôÈáåÁïôÁ©∫‰ª•Âø´ÈÄüË∑≥Ëøá
    },
    system_notification: (payload) => { // ‚ú® Êñ∞Â¢ûÔºöÂ§ÑÁêÜÁ≥ªÁªüÈÄöÁü•
        logDebug(`[Á≥ªÁªüÈÄöÁü•] ${payload.message}`, payload.level.toLowerCase(), payload);
        showAppNotification(payload.message, 5000, payload.level === 'ERROR');
    }
};

// onSocketMessage (Á≠ñÁï•Ê®°ÂºèÁâà)
async function onSocketMessage(event) {
    // Âø´ÈÄüËøáÊª§ÂøÉË∑≥Ê∂àÊÅØÔºåÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑJSON.parse
    if (event.data === '{"type":"heartbeat","payload":{"timestamp":' + Date.now() + '}}') { // ÁÆÄÂçïÂ≠óÁ¨¶‰∏≤ÂåπÈÖçÔºåÂÆûÈôÖÂèØËÉΩÈúÄË¶ÅÊõ¥ÁÅµÊ¥ª
        // logDebug('Êî∂Âà∞ÂøÉË∑≥ÂåÖ (Âø´ÈÄüËøáÊª§)', 'HEARTBEAT'); // Â¶ÇÊûúÈúÄË¶ÅÊõ¥ËØ¶ÁªÜÁöÑÊó•Âøó
        return;
    }

    let data;
    try {
        data = JSON.parse(event.data);
        // Â¶ÇÊûúÊó•ÂøóÁ∫ßÂà´‰∏çÊòØ HEARTBEATÔºåÊâçÊâìÂç∞ÂéüÂßãÊï∞ÊçÆÔºåÈÅøÂÖçÊó•ÂøóËøáËΩΩ
        if (data.type !== 'heartbeat') {
            logDebug(`Êî∂Âà∞ WebSocket Êï∞ÊçÆÂåÖ (${data.type})`, 'info', data); 
        }
    } catch (parseError) {
        const rawMessageSnippet = String(event.data).substring(0, 500);
        logDebug(`‚ùå Êî∂Âà∞Ê†ºÂºèÈîôËØØÁöÑ WebSocket Êï∞ÊçÆÂåÖ`, LOG_LEVELS.ERROR, {
            error: parseError.message,
            raw: rawMessageSnippet
        });
        showAppNotification("ÂÆ¢Êà∑Á´ØÊî∂Âà∞ÊúçÂä°Âô®ÂèëÊù•ÁöÑÊ†ºÂºèÈîôËØØÊ∂àÊÅØÔºåËØ∑Âà∑Êñ∞È°µÈù¢„ÄÇ", 5000, true); // Changed from alert
        return;
    }

    const handler = messageHandlers[data.type];
    if (handler) {
        handler(data.payload);
    } else {
        logDebug(`Êî∂Âà∞Êú™Áü• WebSocket Ê∂àÊÅØÁ±ªÂûã: ${data.type}`, LOG_LEVELS.WARNING, data);
    }
}

function onSocketClose(event) {
    statusEl.textContent = "ËøûÊé•Â∑≤Êñ≠ÂºÄ";
    connectionDot.classList.add('disconnected');
    let reason = `Code: ${event.code}, Reason: ${event.reason || 'Êó†'}, Was Clean: ${event.wasClean}`;
    logDebug(`WebSocketËøûÊé•Â∑≤Êñ≠ÂºÄ„ÄÇ${reason}`, LOG_LEVELS.WARNING);
    showAppNotification(`ËøûÊé•Â∑≤Êñ≠ÂºÄÔºåÂ∞ùËØïÈáçËøû‰∏≠... (${event.reason || 'Êó†'})`, 3000, true); // Added notification
    logDebug(`Â∞ÜÂú®${reconnectInterval/1000}ÁßíÂêéÈáçËøû`, LOG_LEVELS.WARNING);
    setTimeout(connectWebSocket, reconnectInterval);
    reconnectInterval = Math.min(reconnectInterval * 2, maxReconnectInterval); // ÊåáÊï∞ÈÄÄÈÅø
}

function onSocketError(error) {
    let errorMessage = `WebSocketÂèëÁîüÊú™Áü•ÈîôËØØ„ÄÇType: ${error.type}`;
    logDebug(errorMessage, LOG_LEVELS.ERROR);
    statusEl.textContent = "ËøûÊé•ÈîôËØØ";
    showAppNotification("WebSocketËøûÊé•ÈîôËØØÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú„ÄÇ", 3000, true); // Added notification
    socket.close(); // Âº∫Âà∂ÂÖ≥Èó≠ÔºåËß¶ÂèëonSocketCloseËøõË°åÈáçËøû
}


// --- WebRTC Áõ∏ÂÖ≥ÂáΩÊï∞ ---
// (ÊâÄÊúâ WebRTC ÂáΩÊï∞‰øùÊåÅ‰∏çÂèòÔºåÂè™ÂåÖÂê´Âú®ËøôÈáå‰æø‰∫éÊü•ÁúãÂÆåÊï¥ÊÄß)
async function initLocalMedia() {
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        logDebug('È∫¶ÂÖãÈ£éËÆøÈóÆÊùÉÈôêÂ∑≤Ëé∑Âèñ', LOG_LEVELS.SUCCESS);
        return localStream;
    } catch (err) {
        logDebug('Êó†Ê≥ïËé∑ÂèñÈ∫¶ÂÖãÈ£éÊùÉÈôê: ' + err, LOG_LEVELS.ERROR);
        showAppNotification('Êó†Ê≥ïËé∑ÂèñÈ∫¶ÂÖãÈ£éÔºåÈÄöËØùÂäüËÉΩ‰∏çÂèØÁî®„ÄÇËØ∑Ê£ÄÊü•ÊùÉÈôê„ÄÇ', 4000, true); // Changed from alert
        return null; // ‰∏çÊäõÂá∫ÈîôËØØÔºåËÆ©Â∫îÁî®ÁªßÁª≠ËøêË°å
    }
}

function showCallUI(targetUsername) {
    if (document.getElementById(`call-control-${targetUsername}`)) return;
    const panel = document.createElement('div');
    panel.id = `call-control-${targetUsername}`;
    panel.className = 'call-control-panel';
    panel.innerHTML = `<span>‰∏é ${escapeHTML(targetUsername)} ÈÄöËØù‰∏≠...</span><button class="hang-up-btn" data-username="${targetUsername}">üìû</button>`;
    callControlsContainer.appendChild(panel);
    panel.querySelector('.hang-up-btn').onclick = () => endCall(targetUsername);
}

function hideCallUI(targetUsername) {
    document.getElementById(`call-control-${targetUsername}`)?.remove();
    document.getElementById(`audio-${targetUsername}`)?.remove();
}

async function startCall(target) {
    if (!localStream) {
        showAppNotification('Êú¨Âú∞Èü≥È¢ëÊú™Â∞±Áª™ÔºåËØ∑Ê£ÄÊü•È∫¶ÂÖãÈ£éÊùÉÈôê„ÄÇ', 3000, true); // Changed from alert
        return;
    }
    if (peerConnections[target]) return;
    showCallUI(target);
    const pc = new RTCPeerConnection(rtcConfig);
    peerConnections[target] = pc;
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.ontrack = event => playRemoteStream(target, event.streams[0]);
    pc.onicecandidate = event => { if (event.candidate) socket.send(JSON.stringify({ type: 'candidate', payload: { target, candidate: event.candidate } })); };
    pc.onconnectionstatechange = () => { if (['disconnected', 'closed', 'failed'].includes(pc.connectionState)) endCall(target); };
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    socket.send(JSON.stringify({ type: 'offer', payload: { target, sdp: pc.localDescription } }));
}

async function handleOffer({ from, sdp }) {
    if (!localStream) return;
    if (peerConnections[from]) return;
    if (!window.confirm(`${from} Ê≠£Âú®ÂëºÂè´ÊÇ®ÔºåÊòØÂê¶Êé•Âê¨Ôºü`)) return;
    showCallUI(from);
    const pc = new RTCPeerConnection(rtcConfig);
    peerConnections[from] = pc;
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
    pc.ontrack = event => playRemoteStream(from, event.streams[0]);
    pc.onicecandidate = event => { if (event.candidate) socket.send(JSON.stringify({ type: 'candidate', payload: { target: from, candidate: event.candidate } })); };
    pc.onconnectionstatechange = () => { if (['disconnected', 'closed', 'failed'].includes(pc.connectionState)) endCall(from); };
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    socket.send(JSON.stringify({ type: 'answer', payload: { target: from, sdp: pc.localDescription } }));
}

async function handleAnswer({ from, sdp }) {
    const pc = peerConnections[from];
    if (!pc) return;
    await pc.setRemoteDescription(new RTCSessionDescription(sdp));
}

async function handleCandidate({ from, candidate }) {
    const pc = peerConnections[from];
    if (!pc || !candidate) return;
    await pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(e => logDebug('Add ICE candidate failed: ' + e, LOG_LEVELS.ERROR));
}

function handleCallEnd({ from }) {
    const pc = peerConnections[from];
    if (pc) { pc.close(); delete peerConnections[from]; }
    hideCallUI(from);
}

function endCall(target) {
    if (socket?.readyState === WebSocket.OPEN) socket.send(JSON.stringify({ type: 'call_end', payload: { target } }));
    handleCallEnd({ from: target });
}

function playRemoteStream(username, stream) {
    let audioEl = document.getElementById(`audio-${username}`);
    if (!audioEl) {
        audioEl = document.createElement('audio');
        audioEl.id = `audio-${username}`;
        audioEl.autoplay = true;
        audioEl.playsInline = true;
        remoteAudioContainer.appendChild(audioEl);
    }
    audioEl.srcObject = stream;
    audioEl.muted = true; // ÈªòËÆ§ÈùôÈü≥‰ª•ÈÅøÂÖçÊµèËßàÂô®Ëá™Âä®Êí≠ÊîæÁ≠ñÁï•ÈóÆÈ¢ò
    audioEl.play().then(() => {
        audioEl.muted = false; // Êí≠ÊîæÊàêÂäüÂêéÂèñÊ∂àÈùôÈü≥
    }).catch(error => {
        logDebug(`Autoplay for ${username} failed: ${error}`, LOG_LEVELS.WARNING);
        // Â¶ÇÊûúËá™Âä®Êí≠ÊîæÂ§±Ë¥•ÔºåÊèêÁ§∫Áî®Êà∑ÊâãÂä®ÂºÄÂêØÂ£∞Èü≥
        const panel = document.getElementById(`call-control-${username}`);
        if (panel && !panel.querySelector('.unmute-notice')) {
            const unmuteNotice = document.createElement('button');
            unmuteNotice.className = 'unmute-notice';
            unmuteNotice.textContent = 'üîá ÁÇπÊ≠§ÂºÄÂêØÂ£∞Èü≥';
            unmuteNotice.onclick = () => {
                audioEl.muted = false;
                audioEl.play().then(() => unmuteNotice.remove()).catch(err => showAppNotification('ËøòÊòØÊó†Ê≥ïÊí≠ÊîæÂ£∞Èü≥: ' + err, 3000, true));
            };
            panel.appendChild(unmuteNotice);
        }
    });
}


// --- È°µÈù¢ÂàùÂßãÂåñÂíå‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆ ---
// ÂÆö‰πâÂÖ®Â±ÄÂèòÈáèÊù•ÁÆ°ÁêÜËß¶Êë∏‰∫ã‰ª∂ÁöÑÁä∂ÊÄÅ (‰∫ã‰ª∂ÂßîÊâòÁî®)
let touchStartTime;
let touchLongPressTimer; 
let currentTouchMsgEl = null;

// ÂàùÂßãÂåñÂáΩÊï∞ÔºåÂú®DOMContentLoadedÂêéË∞ÉÁî®
function initializeChat() {
    // ËÆæÁΩÆDOMÂÖÉÁ¥†ÊñáÊú¨
    roomNameEl.textContent = roomName;
    document.getElementById('sidebar-room-name').textContent = roomName;
    usernameDisplayEl.textContent = username;

    // ÂÖàÂàùÂßãÂåñÊó•ÂøóÁ≥ªÁªü
    initDebugLog();
    
    // ÂºÇÊ≠•ÂàùÂßãÂåñÂ™í‰Ωì
    initLocalMedia().catch(err => {
        logDebug('ÂàùÂßãÂåñÂ™í‰ΩìÂ§±Ë¥•: ' + err, LOG_LEVELS.WARNING);
    });
    
    // Â∞ùËØïËøûÊé•WebSocket
    connectWebSocket();
    
    // Ê∑ªÂä†È°µÈù¢ÂèØËßÅÊÄßÁõëÂê¨ÔºåÂú®È°µÈù¢ÈáçÊñ∞ÂèØËßÅÊó∂Âà∑Êñ∞ËøûÊé•
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            if (socket?.readyState !== WebSocket.OPEN) {
                logDebug('È°µÈù¢ÈáçÊñ∞ÂèØËßÅÔºåÂ∞ùËØïÈáçÊñ∞ËøûÊé•WebSocket', LOG_LEVELS.INFO);
                connectWebSocket();
            }
        }
    });
    
    // ÂÆöÊúüÊ£ÄÊü•ËøûÊé•Áä∂ÊÄÅ
    setInterval(() => {
        if (socket?.readyState !== WebSocket.OPEN) {
            logDebug('Ê£ÄÊµãÂà∞WebSocketËøûÊé•Â∑≤Êñ≠ÂºÄÔºåÂ∞ùËØïÈáçÊñ∞ËøûÊé•', LOG_LEVELS.WARNING);
            connectWebSocket();
        }
    }, 30000); // ÊØè30ÁßíÊ£ÄÊü•‰∏ÄÊ¨°


    // --- Ê†∏ÂøÉUI‰∫ã‰ª∂ÁõëÂê¨Âô® (Âè™ÁªëÂÆö‰∏ÄÊ¨°) ---
    sidebarToggle.addEventListener('click', () => {
        sidebar.classList.toggle('open');
        overlay.classList.toggle('show');
    });
    overlay.addEventListener('click', () => {
        sidebar.classList.remove('open');
        overlay.classList.remove('show');
    });
    onlineDisplay.addEventListener('click', (e) => {
        e.stopPropagation();
        usersMenu.classList.toggle('show');
    });

    usernameDisplayEl.addEventListener('click', () => {
        const newUsername = prompt("ËØ∑ËæìÂÖ•Êñ∞ÁöÑÁî®Êà∑Âêç:", username);
        if (newUsername && newUsername.trim() && newUsername !== username) {
            username = newUsername.trim();
            localStorage.setItem('chat_username', username);
            usernameDisplayEl.textContent = username;
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'rename', payload: { newUsername: username } }));
            }
        }
    });

    attachmentBtn.addEventListener('click', () => imageInput.click());
    imageInput.addEventListener('change', handleImageSelection);
    previewRemove.addEventListener('click', removeImagePreview);
    modalClose.addEventListener('click', () => imageModal.classList.remove('show'));
    imageModal.addEventListener('click', (e) => {
        if (e.target === imageModal) imageModal.classList.remove('show');
    });
    recordButton.addEventListener('click', handleRecordButtonClick);

    messageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = `${Math.min(this.scrollHeight, 100)}px`;
        checkSendButtonState();
    });

    messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            messageForm.dispatchEvent(new Event('submit'));
        }
    });

    // --- ‰∫ã‰ª∂ÂßîÊâòËÆæÁΩÆ (Âè™ÁªëÂÆö‰∏ÄÊ¨°Âà∞Áà∂ÂÖÉÁ¥†) ---
    // ‰∏∫ chatWindowEl ÁªëÂÆöÂè≥ÈîÆËèúÂçï‰∫ã‰ª∂
    chatWindowEl.addEventListener('contextmenu', e => {
        const msgEl = e.target.closest('.message'); // Êü•ÊâæÊúÄËøëÁöÑ .message Á•ñÂÖàÂÖÉÁ¥†
        if (msgEl) {
            e.preventDefault(); // ÈòªÊ≠¢ÊµèËßàÂô®ÈªòËÆ§ÁöÑÂè≥ÈîÆËèúÂçï
            showContextMenu(msgEl, e.pageX, e.pageY);
        } else {
            // Â¶ÇÊûúÂú®Ê∂àÊÅØÂå∫ÂüüÂ§ñÂè≥ÂáªÔºåÈöêËóè‰∏ä‰∏ãÊñáËèúÂçï
            contextMenu.style.display = 'none';
        }
    });

    // ‰∏∫ chatWindowEl ÁªëÂÆöËß¶Êë∏ÂºÄÂßã‰∫ã‰ª∂ (Áî®‰∫éÈïøÊåâ)
    chatWindowEl.addEventListener('touchstart', e => {
        const msgEl = e.target.closest('.message');
        if (msgEl) {
            // ‰∏çÂÜçÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫ÔºåÂÖÅËÆ∏ÊªöÂä®
            currentTouchMsgEl = msgEl; // ËÆ∞ÂΩïÂΩìÂâçËß¶Êë∏ÁöÑÊ∂àÊÅØÂÖÉÁ¥†
            touchStartTime = Date.now(); // ËÆ∞ÂΩïËß¶Êë∏ÂºÄÂßãÊó∂Èó¥

            // ËÆæÁΩÆ‰∏Ä‰∏™Áü≠Êó∂Èó¥ÂÆöÊó∂Âô®ÔºåÂ¶ÇÊûúÊâãÊåáÂú®Ëøô‰∏™Êó∂Èó¥ÂÜÖÊ≤°ÊúâÁßªÂä®‰∏îÊú™Êä¨Ëµ∑ÔºåÂàôËßÜ‰∏∫ÈïøÊåâ
            touchLongPressTimer = setTimeout(() => {
                // ÂÜçÊ¨°Ê£ÄÊü•Á°Æ‰øùÊòØÂêå‰∏Ä‰∏™ÂÖÉÁ¥†‰∏îÊó∂Èó¥Ë∂≥Â§üÈïø
                if (currentTouchMsgEl === msgEl && (Date.now() - touchStartTime) >= 500) {
                    // Âè™ÊúâÂú®ÈïøÊåâÊó∂ÊâçÈòªÊ≠¢ÈªòËÆ§Ë°å‰∏∫
                    e.preventDefault();
                    showContextMenu(msgEl, e.touches[0].pageX, e.touches[0].pageY);
                    if (navigator.vibrate) navigator.vibrate(50); // ÁßªÂä®Á´ØÈúáÂä®ÂèçÈ¶à
                }
            }, 500); // ÈïøÊåâÈòàÂÄºÔºö500ÊØ´Áßí
        } else {
            // Â¶ÇÊûúËß¶Êë∏ÂºÄÂßãÂú®Ê∂àÊÅØÂå∫ÂüüÂ§ñÔºåÈöêËóè‰∏ä‰∏ãÊñáËèúÂçï
            contextMenu.style.display = 'none';
        }
    }, { passive: true }); // ‰ΩøÁî® passive: true ÊèêÈ´òÊªöÂä®ÊÄßËÉΩ

    // ‰∏∫ chatWindowEl ÁªëÂÆöËß¶Êë∏ÁªìÊùü‰∫ã‰ª∂
    chatWindowEl.addEventListener('touchend', () => {
        clearTimeout(touchLongPressTimer); // Ê∏ÖÈô§‰ªª‰ΩïÊ≠£Âú®ËøõË°åÁöÑËÆ°Êó∂Âô®
        currentTouchMsgEl = null; // ÈáçÁΩÆÂΩìÂâçËß¶Êë∏ÁöÑÂÖÉÁ¥†
    });

    // ‰∏∫ chatWindowEl ÁªëÂÆöËß¶Êë∏ÁßªÂä®‰∫ã‰ª∂
    chatWindowEl.addEventListener('touchmove', () => {
        clearTimeout(touchLongPressTimer); // Â¶ÇÊûúÊâãÊåáÁßªÂä®ÔºåÂàô‰∏çÊòØÈïøÊåâÔºåÊ∏ÖÈô§ËÆ°Êó∂Âô®
        currentTouchMsgEl = null; // ÈáçÁΩÆÂΩìÂâçËß¶Êë∏ÁöÑÂÖÉÁ¥†
    }, { passive: true }); // ‰ΩøÁî® passive: true ÊèêÈ´òÊªöÂä®ÊÄßËÉΩ

    // ÂÖ®Â±ÄÁÇπÂáªÁõëÂê¨Âô®ÔºåÁî®‰∫éÂú®ÁÇπÂáªÂÖ∂‰ªñÂú∞ÊñπÊó∂ÂÖ≥Èó≠ËèúÂçï
    document.addEventListener('click', (e) => {
        // Âè™ÊúâÂΩìÁÇπÂáªÁõÆÊ†á‰∏çÊòØËèúÂçïÊú¨Ë∫´ÊàñÂÖ∂Â≠êÂÖÉÁ¥†Êó∂ÊâçÂÖ≥Èó≠
        if (!usersMenu.contains(e.target) && !contextMenu.contains(e.target)) {
            usersMenu.classList.remove('show');
            contextMenu.style.display = 'none';
        }
    });
    
    // Ê∑ªÂä†ÂÖ®Â±ÄÁöÑÂõæÁâáÊ®°ÊÄÅÊ°ÜÂäüËÉΩ
    window.showImageModal = function(imageUrl) {
        if (!imageModal || !modalImage) return;
        modalImage.src = imageUrl;
        imageModal.classList.add('show');
    };
}

// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéË∞ÉÁî®ÂàùÂßãÂåñÂáΩÊï∞
document.addEventListener('DOMContentLoaded', initializeChat);

</script>
</body>
</html>
```--- START OF FILE autoTasks.js ---

/*
* Ëá™Âä®Âåñ‰ªªÂä°ÂùáÂú®Ê≠§Êí∞ÂÜô  
*/
import { generateAndPostCharts } from './chart_generator.js';
import { getDeepSeekExplanation } from './ai.js';

/**
 * 1. ÂÆö‰πâ Cron Ë°®ËææÂºèÂ∏∏Èáè
 *    ‰∏é wrangler.toml ‰∏≠ÁöÑ [triggers].crons ‰øùÊåÅ‰∏ÄËá¥
 */
const CRON_TRIGGERS = {
    // ÂÅáËÆæÊØèÂ§©Êó©‰∏ä8ÁÇπÂèëÈÄÅÊñáÊú¨Ê∂àÊÅØ (Ê≥®ÊÑèÔºöËøôÈáåÁöÑÊó∂Èó¥ÂèØ‰ª•Ëá™ÂÆö‰πâ)
    DAILY_TEXT_MESSAGE: "0 0-10 * * *",
    // Áõò‰∏≠ÂíåÂ§úÁõòÊó∂ÊÆµÔºåÊØèÂ∞èÊó∂Êï¥ÁÇπÁîüÊàêÂõæË°®
    HOURLY_CHART_GENERATION:   "*/15 17-23,2-10 * * 1-5" // Âë®‰∏ÄÂà∞Âë®‰∫îÁöÑÊåáÂÆöÂ∞èÊó∂
};

/**
 * 2. ÂÆö‰πâÁã¨Á´ãÁöÑ‰ªªÂä°ÊâßË°åÂáΩÊï∞
 */

/**
 * ‰ªªÂä°ÔºöÂèëÈÄÅÊØèÊó•ÊñáÊú¨Ê∂àÊÅØ
 * @param {object} env - ÁéØÂ¢ÉÂèòÈáè
 * @param {object} ctx - ÊâßË°å‰∏ä‰∏ãÊñá
 */
async function executeTextTask(env, ctx) {
    const roomName = 'test'; // ÁõÆÊ†áÊàøÈó¥
    const prompt = '‰Ω†ÊòØdeepseekÂ∞èÂä©ÊâãÔºåÊØèÂ§©Ëá™Âä®ÂêëÁî®Êà∑ÈóÆÂ•ΩÔºåÂπ∂‰∏îÊØèÊ¨°ÈôÑ‰∏ä‰∏ÄÂè•Âêç‰∫∫ÂêçË®ÄÔºåÂèäÊØèÊó•‰∏ÄÂè•Á≤æÂÖ∏Ëã±ÊñáÂè•Â≠êÔºåÂπ∂‰ªîÁªÜÂàÜÊûêÂêçË®ÄÂíåËã±ÊñáÂè•Â≠êÁöÑÊÑèÊÄùÂèäË°çÁîüÊÑè‰πâÔºåÂ∏ÆÂä©Áî®Êà∑ÊèêÂçáËá™ÊàëÔºåÊúÄÂêéÈºìÂä±Áî®Êà∑Â•ΩÂ•ΩÂ∑•‰ΩúÔºåÂ•ΩÂ•ΩÂ≠¶‰π†ÔºåÂ•ΩÂ•ΩÁîüÊ¥ª„ÄÇ';
    
    console.log(`[Cron Task] Executing daily text task for room: ${roomName}`);
    try {
        if (!env.CHAT_ROOM_DO) throw new Error("Durable Object 'CHAT_ROOM_DO' is not bound.");
        
        const content = await getDeepSeekExplanation(prompt, env);
        
        const doId = env.CHAT_ROOM_DO.idFromName(roomName);
        const stub = env.CHAT_ROOM_DO.get(doId);
        
        // ‰ΩøÁî® RPC Ë∞ÉÁî® DO ÁöÑÊñπÊ≥ï
        ctx.waitUntil(stub.cronPost(content, env.CRON_SECRET));
        
        console.log(`[Cron Task] Successfully dispatched text message to room: ${roomName}`);
        return { success: true, roomName: roomName, message: 'ÊñáÊú¨‰ªªÂä°Ê∂àÊÅØÂ∑≤ÂèëÈÄÅ„ÄÇ' };
    } catch (error) {
        console.error(`CRON ERROR (text task):`, error.stack || error);
        return { success: false, roomName: roomName, error: `ÊñáÊú¨‰ªªÂä°ÊâßË°åÂ§±Ë¥•: ${error.message}` };
    }
}

/**
 * ‰ªªÂä°ÔºöÁîüÊàêÂπ∂ÂèëÂ∏ÉÂõæË°®
 * @param {object} env - ÁéØÂ¢ÉÂèòÈáè
 * @param {object} ctx - ÊâßË°å‰∏ä‰∏ãÊñá
 */
async function executeChartTask(env, ctx) {
    const roomName = 'future'; // ÁõÆÊ†áÊàøÈó¥
    
    console.log(`[Cron Task] Executing chart generation task for room: ${roomName}`);
    try {
        // generateAndPostCharts ÊòØ‰∏Ä‰∏™ÈáçÈáèÁ∫ßÊìç‰ΩúÔºåÈÄÇÂêàÁî® waitUntil Âú®ÂêéÂè∞ÊâßË°å
        await generateAndPostCharts(env, roomName); // Direct call, as waitUntil is handled internally
        
        console.log(`[Cron Task] Chart generation process dispatched for room: ${roomName}`);
        return { success: true, roomName: roomName, message: 'ÂõæË°®ÁîüÊàêÂπ∂ÂèëÈÄÅÊàêÂäü„ÄÇ' };
    } catch (error) {
        console.error(`CRON ERROR (chart task):`, error.stack || error);
        return { success: false, roomName: roomName, error: `ÂõæË°®‰ªªÂä°ÊâßË°åÂ§±Ë¥•: ${error.message}` };
    }
}

/**
 * 3. ÂàõÂª∫ Cron Ë°®ËææÂºèÂà∞‰ªªÂä°ÂáΩÊï∞ÁöÑÊò†Â∞Ñ
 */
export const taskMap = new Map([
    [CRON_TRIGGERS.DAILY_TEXT_MESSAGE, executeTextTask],
    [CRON_TRIGGERS.HOURLY_CHART_GENERATION, executeChartTask]
]);
--- START OF FILE chatroom_do.js ---

// Êñá‰ª∂: src/chatroom_do.js (Final Integrated Version)

import { DurableObject } from "cloudflare:workers";

// Ê∂àÊÅØÁ±ªÂûãÂ∏∏Èáè
const MSG_TYPE_CHAT = 'chat';
const MSG_TYPE_DELETE = 'delete';
const MSG_TYPE_ERROR = 'error';
const MSG_TYPE_WELCOME = 'welcome';
const MSG_TYPE_USER_JOIN = 'user_join';
const MSG_TYPE_USER_LEAVE = 'user_leave';
const MSG_TYPE_DEBUG_LOG = 'debug_log';
const MSG_TYPE_HEARTBEAT = 'heartbeat';
const MSG_TYPE_SYSTEM_NOTIFICATION = 'system_notification'; // ‚ú® Êñ∞Â¢ûÔºöÁ≥ªÁªüÈÄöÁü•Á±ªÂûã


export class HibernatingChatRoom extends DurableObject {
    constructor(ctx, env) {
        super(ctx, env);
        this.ctx = ctx;
        this.env = env;
        this.messages = null;
        this.sessions = new Map();
        this.debugLogs = [];
        this.maxDebugLogs = 100;
        this.isInitialized = false;
        this.heartbeatInterval = null;
        
        this.debugLog("üèóÔ∏è DO instance created.");
        
        // ÂêØÂä®ÂøÉË∑≥Êú∫Âà∂
        this.startHeartbeat();
    }

    // ============ Ë∞ÉËØïÊó•ÂøóÁ≥ªÁªü ============
    debugLog(message, level = 'INFO', data = null) {
        const timestamp = new Date().toISOString();
        const logEntry = {
            timestamp,
            level,
            message,
            id: crypto.randomUUID().substring(0, 8),
            data
        };
        
        // Ê∑ªÂä†Âà∞ÂÜÖÂ≠òÊó•Âøó
        this.debugLogs.push(logEntry);
        if (this.debugLogs.length > this.maxDebugLogs) {
            this.debugLogs.shift();
        }
        
        // ÂêåÊó∂ËæìÂá∫Âà∞ÊéßÂà∂Âè∞
        if (data) {
            console.log(`[${timestamp}] [${level}] ${message}`, data);
        } else {
            console.log(`[${timestamp}] [${level}] ${message}`);
        }
        
        // ÂÆûÊó∂ÂπøÊí≠Ë∞ÉËØïÊó•ÂøóÁªôÊâÄÊúâËøûÊé•ÁöÑ‰ºöËØùÔºàÈÅøÂÖçÂæ™ÁéØÔºâ
        if (level !== 'HEARTBEAT') {
            this.broadcastDebugLog(logEntry);
        }
    }

    // ÂçïÁã¨ÁöÑË∞ÉËØïÊó•ÂøóÂπøÊí≠ÊñπÊ≥ïÔºåÈÅøÂÖçÊó†ÈôêÂæ™ÁéØ
    broadcastDebugLog(logEntry) {
        const message = JSON.stringify({
            type: MSG_TYPE_DEBUG_LOG,
            payload: logEntry
        });
        
        this.sessions.forEach((session) => {
            try {
                if (session.ws.readyState === WebSocket.OPEN) {
                    session.ws.send(message);
                }
            } catch (e) {
                // ÈùôÈªòÂ§ÑÁêÜÂèëÈÄÅÂ§±Ë¥•ÔºåÈÅøÂÖçÂú®Ë∞ÉËØïÊó•Âøó‰∏≠‰∫ßÁîüÊõ¥Â§öÊó•Âøó
            }
        });
    }

    // ============ Áä∂ÊÄÅÁÆ°ÁêÜ ============
    async initialize() {
        if (this.isInitialized) return;
        
        // Âä†ËΩΩÊ∂àÊÅØÂéÜÂè≤
        this.messages = (await this.ctx.storage.get("messages")) || [];
        
        // Â∞ùËØïÊÅ¢Â§ç‰ºöËØù‰ø°ÊÅØÔºàËôΩÁÑ∂ WebSocket ËøûÊé•Êó†Ê≥ïÊÅ¢Â§çÔºå‰ΩÜÂèØ‰ª•ÊÅ¢Â§ç‰ºöËØùÂÖÉÊï∞ÊçÆÔºâ
        const savedSessionsData = await this.ctx.storage.get("sessions_metadata");
        if (savedSessionsData) {
            this.debugLog(`üìÅ ÂèëÁé∞ ${savedSessionsData.length} ‰∏™‰ºöËØùÂÖÉÊï∞ÊçÆ„ÄÇ`);
        }
        
        this.debugLog(`üìÅ Â∑≤Âä†ËΩΩ. Messages: ${this.messages.length}`);
        this.isInitialized = true;
    }

    async saveState() {
        if (this.messages === null) return;
        
        const sessionMetadata = Array.from(this.sessions.entries()).map(([id, session]) => ({
            id,
            username: session.username,
            joinTime: session.joinTime,
            lastSeen: session.lastSeen
        }));
        
        const savePromise = Promise.all([
            this.ctx.storage.put("messages", this.messages),
            this.ctx.storage.put("sessions_metadata", sessionMetadata)
        ]);
        
        // ‰ΩøÁî® waitUntil Á°Æ‰øùÂ≠òÂÇ®Êìç‰ΩúÂú®ÂÆû‰æã‰ºëÁú†ÂâçÂÆåÊàê
        this.ctx.waitUntil(savePromise);
        
        try {
            await savePromise;
            this.debugLog(`üíæ Áä∂ÊÄÅÂ∑≤‰øùÂ≠ò. Messages: ${this.messages.length}, Sessions: ${this.sessions.size}`);
        } catch (e) {
            this.debugLog(`üí• Áä∂ÊÄÅ‰øùÂ≠òÂ§±Ë¥•: ${e.message}`, 'ERROR');
        }
    }

    // ============ ÂøÉË∑≥Êú∫Âà∂ ============
    startHeartbeat() {
        // ÊØè30ÁßíÂèëÈÄÅ‰∏ÄÊ¨°ÂøÉË∑≥
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
        }
        
        this.heartbeatInterval = setInterval(() => {
            this.sendHeartbeat();
        }, 30000);
    }

    sendHeartbeat() {
        if (this.sessions.size === 0) return;
        
        // ‰∏∫‰∫ÜÈÅøÂÖçÂú®ÂÆ¢Êà∑Á´ØÊó•Âøó‰∏≠È¢ëÁπÅÂá∫Áé∞ÔºåÁÆÄÂåñÂøÉË∑≥Ê∂àÊÅØ
        const heartbeatMessage = JSON.stringify({
            type: MSG_TYPE_HEARTBEAT,
            payload: { timestamp: Date.now() }
        });
        
        let activeSessions = 0;
        const disconnectedSessions = [];
        
        this.sessions.forEach((session, sessionId) => {
            try {
                if (session.ws.readyState === WebSocket.OPEN) {
                    session.ws.send(heartbeatMessage);
                    session.lastSeen = Date.now();
                    activeSessions++;
                } else {
                    disconnectedSessions.push(sessionId);
                }
            } catch (e) {
                disconnectedSessions.push(sessionId);
            }
        });
        
        // Ê∏ÖÁêÜÊñ≠ÂºÄÁöÑ‰ºöËØù
        disconnectedSessions.forEach(sessionId => {
            this.cleanupSession(sessionId, { code: 1011, reason: 'Heartbeat failed', wasClean: false });
        });
        
        if (activeSessions > 0) {
            this.debugLog(`üíì ÂèëÈÄÅÂøÉË∑≥ÂåÖÂà∞ ${activeSessions} ‰∏™Ê¥ªË∑É‰ºöËØù `, 'HEARTBEAT');
        }
    }

    // ============ RPC ÊñπÊ≥ï ============
    async postBotMessage(payload, secret) {
        // ÂÆâÂÖ®Ê£ÄÊü•
        if (this.env.CRON_SECRET && secret !== this.env.CRON_SECRET) {
            this.debugLog("BOT POST: Unauthorized attempt!", 'ERROR');
            return;
        }
        
        this.debugLog(`ü§ñ Êú∫Âô®‰∫∫Ëá™Âä®ÂèëÂ∏ñ...`, 'INFO', payload);
        await this.initialize();
        
        const message = {
            id: crypto.randomUUID(),
            username: "Êú∫Âô®‰∫∫Â∞èÂä©Êâã", 
            timestamp: Date.now(),
            ...payload 
        };
        
        await this.addAndBroadcastMessage(message);
    }

    /**
     * ÂÖºÂÆπÊóßÁöÑ cronPost ÊñπÊ≥ï
     */
    async cronPost(text, secret) {
        this.debugLog(`ü§ñ Êî∂Âà∞ÂÆöÊó∂‰ªªÂä°, Ëá™Âä®ÂèëÈÄÅÊñáÊú¨Ê∂àÊÅØ: ${text}`);
        // Â§çÁî®Êú∫Âô®‰∫∫ÂèëÂ∏ñÈÄªËæë
        await this.postBotMessage({ text, type: 'text' }, secret);
    }

    /**
     * ‚ú® Êñ∞Â¢ûÔºöÂπøÊí≠Á≥ªÁªüÈÄöÁü•ÁªôÊâÄÊúâÂÆ¢Êà∑Á´Ø
     * @param {object} notificationPayload - { message: string, level: 'INFO'|'SUCCESS'|'WARNING'|'ERROR', data?: any }
     * @param {string} secret - Áî®‰∫éËÆ§ËØÅÁöÑÂØÜÈí•
     */
    async broadcastSystemMessage(notificationPayload, secret) {
        if (this.env.CRON_SECRET && secret !== this.env.CRON_SECRET) {
            this.debugLog("BROADCAST SYSTEM MESSAGE: Unauthorized attempt!", 'ERROR');
            return;
        }

        this.debugLog(`üì¢ ÂπøÊí≠Á≥ªÁªüÈÄöÁü•: ${notificationPayload.message}`, notificationPayload.level, notificationPayload.data);
        const message = {
            type: MSG_TYPE_SYSTEM_NOTIFICATION,
            payload: notificationPayload
        };
        this.broadcast(message);
    }

    // ============ ‰∏ªË¶ÅÂÖ•Âè£ÁÇπ ============
    async fetch(request) {
        const url = new URL(request.url);
        this.debugLog(`üì• ÊúçÂä°Á´ØÂÖ•Á´ôËØ∑Ê±Ç: ${request.method} ${url.pathname}`);

        // Á°Æ‰øùÁä∂ÊÄÅÂ∑≤Âä†ËΩΩ
        await this.initialize();

        // Â§ÑÁêÜ WebSocket ÂçáÁ∫ßËØ∑Ê±Ç
        if (request.headers.get("Upgrade") === "websocket") {
            const { 0: client, 1: server } = new WebSocketPair();
            
            // Ê≠£Á°ÆËÆæÁΩÆWebSocket‰∫ã‰ª∂Â§ÑÁêÜÂô®
            this.ctx.acceptWebSocket(server);
            
            // Â§ÑÁêÜ‰ºöËØù
            await this.handleWebSocketSession(server, url);
            return new Response(null, { status: 101, webSocket: client });
        }
        
        // Â§ÑÁêÜÊâÄÊúâ /api/ ËØ∑Ê±Ç
        if (url.pathname.startsWith('/api/')) {
            return await this.handleApiRequest(url);
        }

        // Â§ÑÁêÜÊâÄÊúâÂÖ∂‰ªñ GET ËØ∑Ê±ÇÔºà‰æãÂ¶ÇÈ°µÈù¢Âä†ËΩΩÔºâ
        if (request.method === "GET") {
            this.debugLog(`üìÑ ÂèëÈÄÅHTMLÊñá‰ª∂: ${url.pathname}`);
            return new Response(null, {
                headers: { "X-DO-Request-HTML": "true" },
            });
        }

        this.debugLog(`‚ùì Êú™Â§ÑÁêÜËøûÊé•üîó: ${request.method} ${url.pathname}`, 'WARN');
        return new Response("Not Found", { status: 404 });
    }

    // ============ API ËØ∑Ê±ÇÂ§ÑÁêÜ ============
    async handleApiRequest(url) {
        // API: Ëé∑ÂèñË∞ÉËØïÊó•Âøó
        if (url.pathname.endsWith('/debug/logs')) {
            this.debugLog(`üîç ËØ∑Ê±Çdebug‰ø°ÊÅØ. Total logs: ${this.debugLogs.length}`);
            return new Response(JSON.stringify({
                logs: this.debugLogs,
                totalLogs: this.debugLogs.length,
                activeSessions: this.sessions.size,
                timestamp: new Date().toISOString()
            }), {
                headers: { 
                    'Content-Type': 'application/json', 
                    'Access-Control-Allow-Origin': '*' 
                }
            });
        }
        
        // API: Ëé∑Âèñ‰ºöËØùÁä∂ÊÄÅ
        if (url.pathname.endsWith('/debug/sessions')) {
            const sessionInfo = Array.from(this.sessions.entries()).map(([id, session]) => ({
                id,
                username: session.username,
                joinTime: session.joinTime,
                lastSeen: session.lastSeen,
                isConnected: session.ws.readyState === WebSocket.OPEN
            }));
            
            return new Response(JSON.stringify({
                sessions: sessionInfo,
                totalSessions: this.sessions.size,
                timestamp: new Date().toISOString()
            }), {
                headers: { 
                    'Content-Type': 'application/json', 
                    'Access-Control-Allow-Origin': '*' 
                }
            });
        }
        
        // API: Ê∏ÖÁ©∫Ë∞ÉËØïÊó•Âøó
        if (url.pathname.endsWith('/debug/clear')) {
            const clearedCount = this.debugLogs.length;
            this.debugLogs = [];
            this.debugLog(`üßπ Debug logs cleared. Cleared ${clearedCount} logs`);
            return new Response(JSON.stringify({
                message: "Cleared " + clearedCount + " debug logs",
                timestamp: new Date().toISOString()
            }), {
                headers: { 
                    'Content-Type': 'application/json', 
                    'Access-Control-Allow-Origin': '*' 
                }
            });
        }
        
        // API: ÈáçÁΩÆÊàøÈó¥
        if (url.pathname.endsWith('/reset-room')) {
            const secret = url.searchParams.get('secret');
            if (this.env.ADMIN_SECRET && secret === this.env.ADMIN_SECRET) {
                await this.ctx.storage.deleteAll();
                this.messages = [];
                this.sessions.clear();
                this.debugLogs = [];
                this.debugLog("üîÑ Room reset successfully");
                return new Response("Room has been reset successfully.", { status: 200 });
            } else {
                this.debugLog("üö´ Unauthorized reset attempt", 'WARN');
                return new Response("Forbidden.", { status: 403 });
            }
        }
        
        // API: Ëé∑ÂèñÂéÜÂè≤Ê∂àÊÅØ
        if (url.pathname.endsWith('/messages/history')) {
            const since = parseInt(url.searchParams.get('since') || '0', 10);
            const history = this.fetchHistory(since);
            this.debugLog(`üìú ËØ∑Ê±ÇÂéÜÂè≤Ê∂àÊÅØ. Since: ${since}, ËøîÂõû: ${history.length} Êù°Ê∂àÊÅØ`);
            return new Response(JSON.stringify(history), {
                headers: { 'Content-Type': 'application/json', 'Access-Control-Allow-Origin': '*' }
            });
        }

        // API: Âà†Èô§Ê∂àÊÅØ
        if (url.pathname.endsWith('/messages/delete')) {
            const messageId = url.searchParams.get('id');
            const secret = url.searchParams.get('secret');
            
            if (this.env.ADMIN_SECRET && secret === this.env.ADMIN_SECRET) {
                const originalCount = this.messages.length;
                this.messages = this.messages.filter(msg => msg.id !== messageId);
                const deleted = originalCount - this.messages.length;
                
                if (deleted > 0) {
                    await this.saveState();
                    this.debugLog(`üóëÔ∏è Message deleted: ${messageId}`);
                    
                    // ÂπøÊí≠Âà†Èô§Ê∂àÊÅØ
                    this.broadcast({ 
                        type: MSG_TYPE_DELETE, 
                        payload: { messageId } 
                    });
                    
                    return new Response(JSON.stringify({
                        message: "Ê∂àÊÅØÂà†Èô§ÊàêÂäü",
                        deleted: deleted
                    }), {
                        headers: { 
                            'Content-Type': 'application/json', 
                            'Access-Control-Allow-Origin': '*' 
                        }
                    });
                } else {
                    return new Response(JSON.stringify({
                        message: "Message not found"
                    }), {
                        status: 404,
                        headers: { 
                            'Content-Type': 'application/json', 
                            'Access-Control-Allow-Origin': '*' 
                        }
                    });
                }
            } else {
                this.debugLog("üö´ Unauthorized delete attempt", 'WARN');
                return new Response("Forbidden.", { status: 403 });
            }
        }

        // API: Ëé∑ÂèñÊàøÈó¥Áä∂ÊÄÅ
        if (url.pathname.endsWith('/room/status')) {
            const status = {
                totalMessages: this.messages.length,
                activeSessions: this.sessions.size,
                lastActivity: this.messages.length > 0 ? Math.max(...this.messages.map(m => m.timestamp)) : null,
                isInitialized: this.isInitialized,
                timestamp: new Date().toISOString()
            };
            
            return new Response(JSON.stringify(status), {
                headers: { 
                    'Content-Type': 'application/json', 
                    'Access-Control-Allow-Origin': '*' 
                }
            });
        }

        return new Response("API endpoint not found", { status: 404 });
    }
// ============ ËæÖÂä©ÊñπÊ≥ï ============

    /**
     * „ÄêÊñ∞Â¢ûÊàñÁ°ÆËÆ§Â≠òÂú®„ÄëÁªü‰∏ÄËΩ¨ÂèëWebRTC‰ø°‰ª§ÁöÑÂáΩÊï∞
     * @param {string} type - Ê∂àÊÅØÁ±ªÂûã (offer, answer, candidate, call_end)
     * @param {object} fromSession - ÂèëÈÄÅÊñπÁöÑ‰ºöËØùÂØπË±°
     * @param {object} payload - Ê∂àÊÅØÁöÑËΩΩËç∑ÔºåÂøÖÈ°ªÂåÖÂê´ target Áî®Êà∑Âêç
     */
    forwardRtcSignal(type, fromSession, payload) {
        if (!payload.target) {
            this.debugLog(`‚ùå RTC signal of type "${type}" is missing a target.`, 'WARN', payload);
            return;
        }

        let targetSession = null;
        // ÈÅçÂéÜÊâÄÊúâ‰ºöËØùÔºåÊâæÂà∞ÁõÆÊ†áÁî®Êà∑
        for (const session of this.sessions.values()) {
            if (session.username === payload.target) {
                targetSession = session;
                break;
            }
        }
        
        if (targetSession && targetSession.ws.readyState === WebSocket.OPEN) {
            this.debugLog(`‚û°Ô∏è Forwarding RTC signal "${type}" from ${fromSession.username} to ${payload.target}`);
            
            // ÈáçÊñ∞ÊûÑÂª∫Ë¶ÅÂèëÈÄÅÁöÑÊ∂àÊÅØÔºåÂ∞Ü from Áî®Êà∑ÂêçÂä†ÂÖ• payload
            const messageToSend = {
                type: type,
                payload: {
                    ...payload,
                    from: fromSession.username // ÂëäËØâÊé•Êî∂ÊñπÊòØË∞ÅÂèëÊù•ÁöÑ‰ø°‰ª§
                }
            };

            try {
                targetSession.ws.send(JSON.stringify(messageToSend));
            } catch (e) {
                this.debugLog(`üí• Failed to forward RTC signal to ${payload.target}: ${e.message}`, 'ERROR');
            }
        } else {
            this.debugLog(`‚ö†Ô∏è Target user "${payload.target}" for RTC signal not found or not connected.`, 'WARN');
        }
    }
    // ============ WebSocket ‰ºöËØùÂ§ÑÁêÜ ============
    async handleWebSocketSession(ws, url) {
        const username = decodeURIComponent(url.searchParams.get("username") || "Anonymous");
        const sessionId = crypto.randomUUID();
        const now = Date.now();
        
        // ÂàõÂª∫‰ºöËØùÂØπË±°
        const session = {
            id: sessionId,
            username,
            ws,
            joinTime: now,
            lastSeen: now
        };
        
        // Â∞Ü‰ºöËØùÊ∑ªÂä†Âà∞ Map ‰∏≠
        this.sessions.set(sessionId, session);
        
        // ÂêåÊó∂Âú® WebSocket ÂØπË±°‰∏ä‰øùÂ≠ò‰ºöËØù‰ø°ÊÅØÔºåÁî®‰∫é‰∫ã‰ª∂Â§ÑÁêÜ
        ws.sessionId = sessionId;

        this.debugLog(`‚úÖ Êé•ÂèóÁî®Êà∑ËøûÊé•: ${username} (Session: ${sessionId}). Total sessions: ${this.sessions.size}`);

        // ÂèëÈÄÅÊ¨¢ËøéÊ∂àÊÅØÔºåÂåÖÂê´ÂéÜÂè≤ËÆ∞ÂΩï
        const welcomeMessage = {
            type: MSG_TYPE_WELCOME,
            payload: {
                message: `Ê¨¢Ëøé ${username} Âä†ÂÖ•ËÅäÂ§©ÂÆ§!`,
                sessionId: sessionId,
                history: this.messages.slice(-50), // Âè™ÂèëÈÄÅÊúÄËøë50Êù°Ê∂àÊÅØ
                userCount: this.sessions.size
            }
        };
        
        try {
            ws.send(JSON.stringify(welcomeMessage));
        } catch (e) {
            this.debugLog(`‚ùå Failed to send welcome message: ${e.message}`, 'ERROR');
        }

        // ÂπøÊí≠Áî®Êà∑Âä†ÂÖ•Ê∂àÊÅØ
        this.broadcast({ 
            type: MSG_TYPE_USER_JOIN, 
            payload: { 
                username,
                userCount: this.sessions.size
            } 
        }, sessionId);
        
        // ‰øùÂ≠òÁä∂ÊÄÅ
        await this.saveState();
    }

    // ============ WebSocket ‰∫ã‰ª∂Â§ÑÁêÜÂô® ============
 // ============ WebSocket ‰∫ã‰ª∂Â§ÑÁêÜÂô® (‰øÆÊ≠£Áâà) ============
    async webSocketMessage(ws, message) {
        const sessionId = ws.sessionId;
        const session = this.sessions.get(sessionId);
        
        if (!session) {
            this.debugLog(`‚ùå No session found for WebSocket (SessionId: ${sessionId})`, 'ERROR');
            ws.close(1011, "Session not found.");
            return;
        }

        session.lastSeen = Date.now();
        // Âø´ÈÄüËøáÊª§ÂøÉË∑≥Ê∂àÊÅØÔºåÈÅøÂÖç‰∏çÂøÖË¶ÅÁöÑÊó•ÂøóÂíåËß£ÊûêÂºÄÈîÄ
        if (message === '{"type":"heartbeat","payload":{"timestamp":' + Date.now() + '}}') {
            this.debugLog(`üíì Êî∂Âà∞ÂøÉË∑≥ÂåÖüíì ${session.username}`, 'HEARTBEAT');
            return;
        }

        this.debugLog(`üì® Received WebSocket message from ${session.username}: ${message.substring(0, 150)}...`);

        try {
            const data = JSON.parse(message);
            
            // --- Ê†∏ÂøÉ‰øÆÊîπÔºöÊÅ¢Â§çWebRTC‰ø°‰ª§Â§ÑÁêÜ ---
            switch (data.type) {
                case MSG_TYPE_CHAT:
                    await this.handleChatMessage(session, data.payload); 
                    break;
                case MSG_TYPE_DELETE:
                    await this.handleDeleteMessage(session, data.payload);
                    break;
                case MSG_TYPE_HEARTBEAT:
                    // Already filtered above, but just in case.
                    break;

                // --- „ÄêÊñ∞Â¢û„ÄëÊÅ¢Â§çWebRTC‰ø°‰ª§ËΩ¨ÂèëÈÄªËæë ---
                case 'offer':
                case 'answer':
                case 'candidate':
                case 'call_end':
                    // Ë∞ÉÁî®‰∏Ä‰∏™Áªü‰∏ÄÁöÑËΩ¨ÂèëÂáΩÊï∞Êù•Â§ÑÁêÜÊâÄÊúâWebRTC‰ø°‰ª§
                    this.forwardRtcSignal(data.type, session, data.payload);
                    break;

                default:
                    this.debugLog(`‚ö†Ô∏è Unhandled message type: ${data.type}`, 'WARN', data);
            }
        } catch (e) { 
            this.debugLog(`‚ùå Failed to parse WebSocket message: ${e.message}`, 'ERROR');
            // ... (ÈîôËØØÂ§ÑÁêÜÈÄªËæë‰øùÊåÅ‰∏çÂèò)
        }
    }

    webSocketClose(ws, code, reason, wasClean) {
        this.cleanupSession(ws.sessionId, { code, reason, wasClean });
    }
    
    webSocketError(ws, error) {
        const sessionId = ws.sessionId;
        const session = this.sessions.get(sessionId);
        const username = session ? session.username : 'unknown';
        
        this.debugLog(`üí• WebSocket error for ${username}: ${error}`, 'ERROR');
        
        // Ëß¶ÂèëÂÖ≥Èó≠Â§ÑÁêÜ
        this.cleanupSession(sessionId, { code: 1011, reason: "An error occurred", wasClean: false });
    }

    // ============ Ê†∏ÂøÉ‰∏öÂä°ÈÄªËæë ============
    async handleChatMessage(session, payload) {
        // ÊâìÂç∞ÂÆåÊï¥ÁöÑ payload Êñπ‰æøË∞ÉËØïÔºåÂèØ‰ª•Á°ÆËÆ§ÂÜÖÈÉ® type
        this.debugLog(`üí¨ Handling chat message from ${session.username}`, 'INFO', payload);
        
        let messageContentValid = false;
        // Ëé∑ÂèñÂÜÖÈÉ® payload ÁöÑ type
        const messageType = payload.type; 
        
        // „ÄêÂÖ≥ÈîÆ‰øÆÊ≠£„ÄëÂ∞Ü 'chat' Á±ªÂûã‰πüËßÜ‰∏∫ÊñáÊú¨Ê∂àÊÅØÔºåÂπ∂Â∞ÜÂÖ∂ËßÑËåÉ‰∏∫ 'text'
        if (messageType === 'text' || messageType === 'chat') { 
            if (payload.text && payload.text.trim().length > 0) {
                messageContentValid = true;
            }
        } else if (messageType === 'image') {
            if (payload.imageUrl) {
                messageContentValid = true;
            }
            // ÂõæÁâáÊ∂àÊÅØÂèØ‰ª•ÊúâÂèØÈÄâÁöÑ captionÔºåÂç≥‰Ωø text/caption ‰∏∫Á©∫‰πüËßÜ‰∏∫ÊúâÊïà
        } else if (messageType === 'audio') {
            if (payload.audioUrl) {
                messageContentValid = true;
            }
        } else {
            // Êú™Áü•Êàñ‰∏çÊîØÊåÅÁöÑÊ∂àÊÅØÁ±ªÂûã
            this.debugLog(`‚ö†Ô∏è Unsupported message type: ${messageType}`, 'WARN', payload);
            try {
                session.ws.send(JSON.stringify({
                    type: MSG_TYPE_ERROR,
                    payload: { message: "‰∏çÊîØÊåÅÁöÑÊ∂àÊÅØÁ±ªÂûãÊàñÊó†ÊïàÂÜÖÂÆπ" }
                }));
            } catch (e) { /* silently fail */ }
            return;
        }

        if (!messageContentValid) {
            this.debugLog(`‚ùå Invalid or empty content for message type ${messageType} from ${session.username}`, 'WARN', payload);
            try {
                session.ws.send(JSON.stringify({
                    type: MSG_TYPE_ERROR,
                    payload: { message: "Ê∂àÊÅØÂÜÖÂÆπÊó†ÊïàÊàñ‰∏∫Á©∫„ÄÇ" }
                }));
            } catch (e) { /* silently fail */ }
            return;
        }

        // Èò≤Ê≠¢ÊñáÊú¨ÊàñÊ†áÈ¢òËøáÈïø (‰ªÖÂØπÊñáÊú¨ÂíåÂõæÁâáÊ†áÈ¢òËøõË°åÈïøÂ∫¶ÈôêÂà∂)
        const textContentToCheckLength = payload.text || payload.caption || '';
        if (textContentToCheckLength.length > 10000) {
            this.debugLog(`‚ùå Message text/caption too long from ${session.username}`, 'WARN');
            try {
                session.ws.send(JSON.stringify({
                    type: MSG_TYPE_ERROR,
                    payload: { message: "Ê∂àÊÅØÊñáÊú¨ÊàñÊ†áÈ¢òËøáÈïøÔºåËØ∑ÊéßÂà∂Âú®10000Â≠óÁ¨¶‰ª•ÂÜÖ" }
                }));
            } catch (e) {
                this.debugLog(`‚ùå Failed to send error message: ${e.message}`, 'ERROR');
            }
            return;
        }
        
        const message = {
            id: payload.id || crypto.randomUUID(), // ‰ΩøÁî®ÂâçÁ´ØÊèê‰æõÁöÑIDÔºà‰πêËßÇÊõ¥Êñ∞ÔºâÔºåÂê¶ÂàôÁîüÊàêÊñ∞ID
            username: session.username,
            timestamp: payload.timestamp || Date.now(), // ‰ΩøÁî®ÂâçÁ´ØÊèê‰æõÁöÑÊó∂Èó¥Êà≥Ôºà‰πêËßÇÊõ¥Êñ∞ÔºâÔºåÂê¶ÂàôÁî®ÂΩìÂâçÊó∂Èó¥
            text: payload.text?.trim() || '',
            // „ÄêÊ†∏ÂøÉ‰øÆÊ≠£„ÄëÂ∞ÜÂÜÖÈÉ® 'chat' Á±ªÂûãËßÑËåÉ‰∏∫ 'text' Â≠òÂÇ®
            type: messageType === 'chat' ? 'text' : messageType 
        };
        
        // Â¶ÇÊûúÊòØÂõæÁâáÊ∂àÊÅØÔºå‰øùÂ≠òÂõæÁâáÊï∞ÊçÆ
        if (messageType === 'image') {
            message.imageUrl = payload.imageUrl; 
            message.filename = payload.filename;
            message.size = payload.size;
            message.caption = payload.caption?.trim() || ''; 
        } else if (messageType === 'audio') { 
            message.audioUrl = payload.audioUrl;
            message.filename = payload.filename;
            message.size = payload.size;
        }
        
        await this.addAndBroadcastMessage(message);
    }

    async handleDeleteMessage(session, payload) { 
        const messageId = payload.id;
        if (!messageId) {
            this.debugLog(`‚ùå Delete request from ${session.username} is missing message ID.`, 'WARN');
            return;
        }

        const initialLength = this.messages.length;
        const messageToDelete = this.messages.find(m => m.id === messageId);

        // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÁ°Æ‰øùÊ∂àÊÅØÂ≠òÂú®ÔºåÂπ∂‰∏îÊòØËØ•Áî®Êà∑Ëá™Â∑±ÂèëÈÄÅÁöÑ
        if (messageToDelete && messageToDelete.username === session.username) {
            this.messages = this.messages.filter(m => m.id !== messageId);
            
            if (this.messages.length < initialLength) {
                this.debugLog(`üóëÔ∏è Message ${messageId} deleted by ${session.username}.`);
                
                await this.saveState();
                
                this.broadcast({ 
                    type: MSG_TYPE_DELETE, 
                    payload: { messageId } 
                });
            }
        } else {
            let reason = messageToDelete ? "permission denied" : "message not found";
            this.debugLog(`üö´ Unauthorized delete attempt by ${session.username} for message ${messageId}. Reason: ${reason}`, 'WARN');
            
            try {
                session.ws.send(JSON.stringify({
                    type: MSG_TYPE_ERROR,
                    payload: { message: "‰Ω†‰∏çËÉΩÂà†Èô§ËøôÊù°Ê∂àÊÅØ„ÄÇ" }
                }));
            } catch (e) {
                this.debugLog(`‚ùå Êó†Ê≥ïÂèëÈÄÅÈîôËØØ‰ø°ÊÅØ: ${e.message}`, 'ERROR');
            }
        }
    }

    // ============ ËæÖÂä©ÊñπÊ≥ï ============
    async addAndBroadcastMessage(message) {
        this.messages.push(message);
        // „ÄêÂÖ≥ÈîÆ‰øÆÊ≠£„ÄëÈôêÂà∂ÊúçÂä°Âô®Á´ØÂ≠òÂÇ®ÁöÑÊ∂àÊÅØÊï∞ÈáèÔºå‰∏éÂâçÁ´Ø‰øùÊåÅ‰∏ÄËá¥
        if (this.messages.length > 500) { 
            this.messages.shift();
        }
        
        await this.saveState();
        
        this.broadcast({ type: MSG_TYPE_CHAT, payload: message });
    }

    // Áªü‰∏ÄÁöÑ‰ºöËØùÊ∏ÖÁêÜÂáΩÊï∞
    cleanupSession(sessionId, closeInfo = {}) {
        const session = this.sessions.get(sessionId);
        if (session) {
            this.sessions.delete(sessionId);
            const { code = 'N/A', reason = 'N/A', wasClean = 'N/A' } = closeInfo;
            this.debugLog(`üîå Êñ≠ÂºÄÂÖ∂ËøûÊé•: ${session.username} (Session: ${sessionId}). Code: ${code}, ÂéüÂõ†: ${reason}, Ê∏ÖÁêÜ: ${wasClean}`);
            
            // ÂπøÊí≠Áî®Êà∑Á¶ªÂºÄÊ∂àÊÅØ
            this.broadcast({ 
                type: MSG_TYPE_USER_LEAVE, 
                payload: { 
                    username: session.username,
                    userCount: this.sessions.size
                } 
            });
            
            this.debugLog(`üìä Remaining sessions: ${this.sessions.size}`);
            
            // ‰ΩøÁî® waitUntil Á°Æ‰øùÁä∂ÊÄÅ‰øùÂ≠òÂú®ÂÆû‰æã‰ºëÁú†ÂâçÂÆåÊàê
            this.ctx.waitUntil(this.saveState());
        }
    }

    fetchHistory(since = 0) {
        return since > 0 ? this.messages.filter(msg => msg.timestamp > since) : this.messages;
    }

    broadcast(message, excludeSessionId = null) {
        const stringifiedMessage = JSON.stringify(message);
        let activeSessions = 0;
        const disconnectedSessions = [];
        
        this.sessions.forEach((session, sessionId) => {
            if (sessionId === excludeSessionId) {
                return;
            }
            
            try {
                if (session.ws.readyState === WebSocket.OPEN) {
                    session.ws.send(stringifiedMessage);
                    activeSessions++;
                } else {
                    disconnectedSessions.push(sessionId);
                }
            } catch (e) {
                this.debugLog(`üí• Failed to send message to ${session.username}: ${e.message}`, 'ERROR');
                disconnectedSessions.push(sessionId);
            }
        });
        
        // Ê∏ÖÁêÜÊñ≠ÂºÄÁöÑ‰ºöËØù
        disconnectedSessions.forEach(sessionId => {
            this.cleanupSession(sessionId, { code: 1011, reason: 'Broadcast failed', wasClean: false });
        });
        
        // ÈÅøÂÖçË∞ÉËØïÊó•ÂøóÁöÑÂπøÊí≠‰∫ßÁîüÊó†ÈôêÂæ™ÁéØ
        if (message.type !== MSG_TYPE_DEBUG_LOG) {
            this.debugLog(`üì° Message broadcast to ${activeSessions} active sessions`);
        }
    }

    // ============ Ê∏ÖÁêÜÊñπÊ≥ï ============
    async cleanup() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
        
        // ‰øùÂ≠òÊúÄÁªàÁä∂ÊÄÅ
        await this.saveState();
        
        this.debugLog("üßπ Cleanup completed");
    }
}
--- START OF FILE ai.js ---

// src/ai.js

/**
 * Ë∞ÉÁî® DeepSeek API Ëé∑ÂèñÊñáÊú¨Ëß£Èáä„ÄÇ
 */
export async function getDeepSeekExplanation(text, env) {
    const apiKey = env.DEEPSEEK_API_KEY;
    if (!apiKey) throw new Error('Server config error: DEEPSEEK_API_KEY is not set.');

    const response = await fetch("https://api.deepseek.com/chat/completions", {
        method: "POST",
        headers: { "Content-Type": "application/json", "Authorization": `Bearer ${apiKey}` },
        body: JSON.stringify({
            model: "deepseek-chat",
            messages: [{ role: "system", content: "‰Ω†ÊòØ‰∏Ä‰∏™ÊúâÁî®ÁöÑÔºåÂñÑ‰∫éÁî®ÁÆÄÊ¥ÅÁöÑmarkdownËØ≠Ë®ÄÊù•Ëß£Èáä‰∏ãÈù¢ÁöÑÊñáÊú¨." }, { role: "user", content: text }]
        })
    });
    if (!response.ok) throw new Error(`DeepSeek API error: ${await response.text()}`);
    const data = await response.json();
    const explanation = data?.choices?.?.message?.content;
    if (!explanation) throw new Error('Unexpected AI response format from DeepSeek.');
    return explanation;
}

/**
 * Ë∞ÉÁî® Google Gemini API Ëé∑ÂèñÊñáÊú¨Ëß£Èáä„ÄÇ
 */
export async function getGeminiExplanation(text, env) {
    const apiKey = env.GEMINI_API_KEY;
    if (!apiKey) throw new Error('Server config error: GEMINI_API_KEY is not set.');
    
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
    const response = await fetch(apiUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ parts: [{ text: text }] }]
        })
    });
    if (!response.ok) throw new Error(`Gemini API error: ${await response.text()}`);
    const data = await response.json();
    const explanation = data?.candidates?.?.content?.parts?.?.text;
    if (!explanation) throw new Error('Unexpected AI response format from Gemini.');
    return explanation;
}

/**
 * „Äê‰øÆÊ≠£Áâà„Äë‰ªéURLËé∑ÂèñÂõæÁâáÂπ∂È´òÊïàÂú∞ËΩ¨Êç¢‰∏∫Base64ÁºñÁ†Å„ÄÇ
 */
async function fetchImageAsBase64(imageUrl) {
    const response = await fetch(imageUrl);
    if (!response.ok) {
        throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
    }
    const contentType = response.headers.get('content-type') || 'image/jpeg';
    const buffer = await response.arrayBuffer();

    // --- Ê†∏ÂøÉ‰øÆÊ≠£Ôºö‰ΩøÁî®Êõ¥ÂÅ•Â£ÆÂíåÈ´òÊïàÁöÑÁºñÁ†ÅÊñπÊ≥ï ---
    const hex = [...new Uint8Array(buffer)]
        .map(b => b.toString(16).padStart(2, '0'))
        .join('');

    let binary = '';
    for (let i = 0; i < hex.length; i += 2) {
        binary += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    const base64 = btoa(binary);
    
    return { base64, contentType };
}

/**
 * Ë∞ÉÁî® Google Gemini API Ëé∑ÂèñÂõæÁâáÊèèËø∞„ÄÇ
 */
export async function getGeminiImageDescription(imageUrl, env) {
    const apiKey = env.GEMINI_API_KEY;
    if (!apiKey) throw new Error('Server config error: GEMINI_API_KEY is not set.');

    const { base64, contentType } = await fetchImageAsBase64(imageUrl);
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`;
    const prompt = "ËØ∑‰ªîÁªÜÊèèËø∞ÂõæÁâáÁöÑÂÜÖÂÆπÔºåÂ¶ÇÊûúÂõæÁâá‰∏≠ËØÜÂà´Âá∫ÊúâÊñáÂ≠óÔºåÂàôÂú®ÂõûÂ§çÁöÑÂÜÖÂÆπ‰∏≠ËøîÂõûËøô‰∫õÊñáÂ≠óÔºåÂπ∂‰∏îËøô‰∫õÊñáÂ≠óÊîØÊåÅÂ§çÂà∂Ôºå‰πãÂêéÊòØÂØπÊñáÂ≠óÁöÑ‰ªîÁªÜÊèèËø∞ÔºåÊ†ºÂºè‰∏∫ÔºöÂõæÁâá‰∏≠ÂåÖÂê´ÊñáÂ≠óÔºö{ÊñáÂ≠óÂÜÖÂÆπ}ÔºõÂõæÁâáÁöÑÊèèËø∞Ôºö{ÂõæÁâáÊèèËø∞}";

    const response = await fetch(apiUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            contents: [{ parts: [{ text: prompt }, { inline_data: { mime_type: contentType, data: base64 } }] }]
        })
    });
    if (!response.ok) throw new Error(`Gemini Vision API error: ${await response.text()}`);
    const data = await response.json();
    const description = data?.candidates?.?.content?.parts?.?.text;
    if (!description) throw new Error('Unexpected AI response format from Gemini Vision.');
    return description;
}
--- START OF FILE chart_generator.js ---

// src/chart_generator.js (Complete ECharts Renderer for 8 Charts)

import * as echarts from 'echarts';

// ==============================================
//  ECharts ÊúçÂä°Á´ØÊ∏≤ÊüìÂÖºÂÆπÊÄßËÆæÁΩÆ
// ==============================================
// Á°Æ‰øù ECharts Âú®Êó†Â§¥ÁéØÂ¢É‰∏≠ÂèØ‰ª•ËøêË°å
// ËøôÈÄöÂ∏∏Â∑≤Áî± `globalThis.global = globalThis;` Ëß£ÂÜ≥
// ‰∏î `compatibility_flags = ["nodejs_compat"]` ÈÖçÂêà npm install Â∑≤ÁªèÂà∞‰Ωç

// ==============================================
//  Êï∞ÊçÆÂ≠óÊÆµÊò†Â∞ÑË°®
//  ‰∏éÂâçÁ´Ø index.html ‰øùÊåÅ‰∏ÄËá¥
// ==============================================
const fieldMapping = {
    // Âü∫Á°Ä‰ª∑Ê†ºÊï∞ÊçÆ
    qrspj: 'Êò®Êî∂Áõò‰ª∑',    zjsj: 'Êò®ÁªìÁÆó‰ª∑',    o: 'ÂºÄÁõò‰ª∑',       h: 'ÊúÄÈ´ò‰ª∑',
    l: 'ÊúÄ‰Ωé‰ª∑',         p: 'ÊúÄÊñ∞‰ª∑',        j: 'Âùá‰ª∑',         mrj: '‰π∞ÂÖ•‰ª∑',
    mcj: 'ÂçñÂá∫‰ª∑',       zt: 'Ê∂®ÂÅú',         dt: 'Ë∑åÂÅú',        
    
    // Ê∂®Ë∑åÂπÖÁõ∏ÂÖ≥
    zdf: 'Ê∂®Ë∑åÂπÖ',       zde: 'Ê∂®Ë∑åÈ¢ù',       zdf3: '3Êó•Ê∂®ÂπÖ',    zdf5: '5Êó•Ê∂®ÂπÖ',
    zdf6: '6Êó•Ê∂®ÂπÖ',     zdf20: '20Êó•Ê∂®ÂπÖ',   zdf250: '250Êó•Ê∂®ÂπÖ', zdfly: '‰ªäÂπ¥Ê∂®ÂπÖ',
    zdf0: 'Ëøë‰∏ÄÂπ¥Ê∂®ÂπÖ',   zdflm: 'Êú¨ÊúàÊ∂®ÂπÖ',   
    
    // ‰∫§ÊòìÊï∞ÊçÆ  
    vol: 'Êàê‰∫§Èáè',       cje: 'Êàê‰∫§È¢ù',       ccl: 'ÊåÅ‰ªìÈáè',      zccl: 'Êò®ÊåÅ‰ªìÈáè',
    rz: 'Êó•Â¢û‰ªì',        np: 'ÂÜÖÁõò',         wp: 'Â§ñÁõò',        cjbs: 'Êàê‰∫§Á¨îÊï∞',
    
    // ÊäÄÊúØÊåáÊ†á
    tjd: 'ÊäïÊú∫Â∫¶',       zf: 'ÊåØÂπÖ',         lb: 'ÈáèÊØî',        cdzj: 'Ê≤âÊ∑ÄËµÑÈáë',
    
    // ÂÖ∂‰ªñÂ≠óÊÆµ (ÂèØËÉΩÂú®Êï∞ÊçÆ‰∏≠‰ΩÜÊú™Áî®‰∫éÂõæË°®)
    dm: '‰ª£Á†Å',          name: 'ÂêàÁ∫¶ÂêçÁß∞',    ly: 'ËÆ°ÁÆóÊù•Ê∫ê',     sc: 'Â∏ÇÂú∫‰ª£Á†Å',
    jyzt: '‰∫§ÊòìÁä∂ÊÄÅ',    xs: 'Áé∞Êâã',         xsfx: 'Áé∞ÊâãÊñπÂêë',   
    utime: 'Êõ¥Êñ∞Êó∂Èó¥',   kpsj: 'ÂºÄÁõòÊó∂Èó¥',    spsj: 'Êî∂ÁõòÊó∂Èó¥',   jysj: '‰∫§ÊòìÊó∂Èó¥'
};

// ==============================================
//  ÈÄöÁî®ÂõæË°®Ê†∑ÂºèÈÖçÁΩÆ (‰∏éÂâçÁ´Ø index.html ‰øùÊåÅ‰∏ÄËá¥)
// ==============================================
const commonAxisOptions = {
    axisLabel: { fontSize: 11, color: '#444', interval: 0, rotate: 45 },
    axisLine: { lineStyle: { color: '#ccc' } },
    splitLine: { lineStyle: { color: '#f0f0f0', type: 'dashed' } }
};

// ==============================================
//  Â∑•ÂÖ∑ÂáΩÊï∞Âå∫ (‰∏éÂâçÁ´Ø index.html ‰øùÊåÅ‰∏ÄËá¥)
// ==============================================
function getSimplifiedName(fullName) {
    const match = fullName.match(/^([^\d]+)/);
    return match && match ? match : fullName;
}
function formatCjeToBillion(value) {
    if (value === null || value === undefined) return '-';
    return (value / 1e8).toFixed(2) + '‰∫ø';
}
function formatVolumeOrCCL(value) {
    if (value === null || value === undefined) return '-';
    if (value >= 100000000) return (value / 100000000).toFixed(2) + '‰∫øÊâã';
    if (value >= 10000) return (value / 10000).toFixed(2) + '‰∏áÊâã';
    return value.toLocaleString() + 'Êâã';
}
function getZdfTreemapColor(zdf) {
    const abs = Math.abs(zdf);
    if (zdf <= 0) {
        if (abs >= 5) return '#006400';
        if (abs >= 2) return '#22c55e';
        if (abs >= 1) return '#66bb6a';
        return '#86efac';
    } else {
        if (abs >= 5) return '#8b0000';
        if (abs >= 2) return '#ef4444';
        if (abs >= 1) return '#ff8888';
        return '#fca5a5';
    }
}
function getOpenInterestChangeColor(rz) {
    if (rz > 0) return '#ef4444';
    if (rz < 0) return '#22c55e';
    return '#9ca3af';
}

// ==============================================
//  ECharts Option ÁîüÊàêÂáΩÊï∞ (ÂÖ®ÈÉ®‰ªéÂâçÁ´Ø renderChartX ÈÄÇÈÖçËÄåÊù•)
// ==============================================

function getChart1Option(dataList) {
    const processedData = dataList.map(item => {
        const openChange = parseFloat(((item.o - item.zjsj) / item.zjsj * 100).toFixed(2));
        const closeChange = parseFloat(((item.p - item.zjsj) / item.zjsj * 100).toFixed(2));
        const lowChange = parseFloat(((item.l - item.zjsj) / item.zjsj * 100).toFixed(2));
        const highChange = parseFloat(((item.h - item.zjsj) / item.zjsj * 100).toFixed(2));
        return {
            name: getSimplifiedName(item.name), fullName: item.name, dm: item.dm,
            value: [openChange, closeChange, lowChange, highChange], // KÁ∫øÊï∞ÊçÆ
            closeChange, openChange, highChange, lowChange,
            rawValues: { // ‰øùÂ≠òÂéüÂßãÊï∞ÊçÆÁî®‰∫étooltipÊòæÁ§∫
                open: item.o, high: item.h, low: item.l, close: item.p, prevClose: item.zjsj
            }
        };
    });
    const sortedData = processedData.sort((a, b) => b.closeChange - a.closeChange);
    const categories = sortedData.map(item => item.name);
    const markPointData = [];
    if (sortedData.length > 0 && sortedData.closeChange > 0) {
        markPointData.push({ name: 'Ê∂®ÂπÖÊúÄÈ´ò', value: sortedData.closeChange, coord: [0, sortedData.value], itemStyle: { color: '#ef4444' } });
    }
    if (sortedData.length > 1 && sortedData[sortedData.length - 1].closeChange < 0) {
        markPointData.push({ name: 'Ë∑åÂπÖÊúÄÂ§ß', value: sortedData[sortedData.length - 1].closeChange, coord: [sortedData.length - 1, sortedData[sortedData.length - 1].value], itemStyle: { color: '#22c553' } });
    }
    return {
        title: { text: 'ÊúüË¥ßÂìÅÁßçËµ∞ÂäøÂØπÊØî', left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis', formatter: (params) => { /* ... (Â§çÊùÇtooltipÔºåÁúÅÁï•ÔºåWorker‰∏≠ÂèØ‰ª•ÁÆÄÂåñ) ... */ } },
        xAxis: { type: 'category', data: categories, axisLabel: { rotate: 45 } },
        yAxis: { type: 'value', axisLabel: { formatter: '{value}%' } },
        series: [{ type: 'candlestick', data: sortedData, itemStyle: { color: '#ef4444', color0: '#22c55e' }, markPoint: { data: markPointData } }]
    };
}

function getChart2Option(dataList) {
    dataList.sort((a, b) => b.zdf - a.zdf);
    const categories = dataList.map(item => getSimplifiedName(item.name));
    return {
        title: { text: 'ÊäïÊú∫Â∫¶‰∏éÊ∂®Ë∑åÂπÖÂØπÊØî', left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis' },
        legend: { data: ['ÊäïÊú∫Â∫¶', 'Ê∂®Ë∑åÂπÖ'], top: 10 },
        xAxis: { type: 'category', data: categories, axisLabel: { rotate: 45 } },
        yAxis: [
            { type: 'value', name: 'ÊäïÊú∫Â∫¶', position: 'left' },
            { type: 'value', name: 'Ê∂®Ë∑åÂπÖ(%)', position: 'right', axisLabel: { formatter: '{value}%' } }
        ],
        series: [
            { name: 'ÊäïÊú∫Â∫¶', type: 'bar', yAxisIndex: 0, data: dataList.map(item => item.tjd) },
            { name: 'Ê∂®Ë∑åÂπÖ', type: 'line', yAxisIndex: 1, data: dataList.map(item => item.zdf) }
        ]
    };
}

function getChart3Option(dataList) {
    dataList.sort((a, b) => b.zdf - a.zdf);
    return {
        title: { text: 'Â¢û‰ªìÁéá‰∏éÊ∂®Ë∑åÂπÖÂØπÊØî', left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis' },
        legend: { data: ['Â¢û‰ªìÁéá', 'Ê∂®Ë∑åÂπÖ'], top: 10 },
        xAxis: { type: 'category', data: dataList.map(item => getSimplifiedName(item.name)), axisLabel: { rotate: 45 } },
        yAxis: [
            { type: 'value', name: 'Â¢û‰ªìÁéá(%)', position: 'left', axisLabel: { formatter: '{value}%' } },
            { type: 'value', name: 'Ê∂®Ë∑åÂπÖ(%)', position: 'right', axisLabel: { formatter: '{value}%' } }
        ],
        series: [
            {
                name: 'Â¢û‰ªìÁéá', type: 'bar', yAxisIndex: 0,
                data: dataList.map(item => {
                    const divisor = item.ccl - item.rz;
                    return divisor === 0 ? 0 : parseFloat(((item.rz / divisor) * 100).toFixed(2));
                })
            },
            { name: 'Ê∂®Ë∑åÂπÖ', type: 'line', yAxisIndex: 1, data: dataList.map(item => item.zdf) }
        ]
    };
}

function getChart4Option(dataList) {
    dataList.sort((a, b) => b.zdf - a.zdf);
    const seriesConfig = [
        { name: 'ÂΩìÊó•Ê∂®ÂπÖ', field: 'zdf', color: '#ef4444' },
        { name: '3Êó•Ê∂®ÂπÖ', field: 'zdf3', color: '#22c55e' },
        { name: '5Êó•Ê∂®ÂπÖ', field: 'zdf5', color: '#3b82f6' },
        { name: '20Êó•Ê∂®ÂπÖ', field: 'zdf20', color: '#a855f7' },
        { name: '‰ªäÂπ¥Ê∂®ÂπÖ', field: 'zdfly', color: '#f59e0b' },
        { name: '250Êó•Ê∂®ÂπÖ', field: 'zdf250', color: '#14b8a6' }
    ];
    return {
        title: { text: 'ÂêÑÂë®ÊúüÊ∂®Ë∑åÂπÖÂØπÊØî', left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis', formatter: (params) => { /* ... (Â§çÊùÇtooltipÔºåÁúÅÁï•) ... */ } },
        legend: { data: seriesConfig.map(s => s.name), top: 10, type: 'scroll' },
        xAxis: { type: 'category', data: dataList.map(item => getSimplifiedName(item.name)), axisLabel: { rotate: 45 } },
        yAxis: { type: 'value', name: 'Ê∂®Ë∑åÂπÖ(%)', axisLabel: { formatter: '{value}%' } },
        series: seriesConfig.map(s => ({
            name: s.name, type: 'line', smooth: true, data: dataList.map(item => item[s.field])
        }))
    };
}

function getChart5Option(dataList, metric1, metric2) {
    dataList.sort((a, b) => b[metric1] - a[metric1]);
    const categories = dataList.map(item => getSimplifiedName(item.name));
    return {
        title: { text: `${fieldMapping[metric1]}‰∏é${fieldMapping[metric2]}ÂØπÊØî`, left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'axis' },
        legend: { data: [fieldMapping[metric1], fieldMapping[metric2]], top: 10 },
        xAxis: { type: 'category', data: categories, axisLabel: { rotate: 45 } },
        yAxis: [
            { type: 'value', name: fieldMapping[metric1], position: 'left' },
            { type: 'value', name: fieldMapping[metric2], position: 'right' }
        ],
        series: [
            { name: fieldMapping[metric1], type: 'bar', yAxisIndex: 0, data: dataList.map(item => item[metric1]) },
            { name: fieldMapping[metric2], type: 'line', yAxisIndex: 1, data: dataList.map(item => item[metric2]) }
        ]
    };
}

function getChart6Option(dataList) {
    // Ê†ëÁä∂ÂõæÂè™‰ΩøÁî®ÈªòËÆ§ÁöÑ cje ‰Ωú‰∏∫Èù¢ÁßØÊåáÊ†áÔºåzdf ‰Ωú‰∏∫È¢úËâ≤ÊåáÊ†á
    const treemapData = dataList.filter(item => item.cje > 10 * 1e8 && typeof item.zdf === 'number');
    if (treemapData.length > 0) treemapData.sort((a, b) => b.cje - a.cje);

    const treemapSeriesData = treemapData.map(item => ({
        name: getSimplifiedName(item.name),
        value: item.cje, // Èù¢ÁßØ‰ª£Ë°®Êàê‰∫§È¢ù
        zdf: item.zdf,   // È¢úËâ≤‰ª£Ë°®Ê∂®Ë∑åÂπÖ
        itemStyle: { color: getZdfTreemapColor(item.zdf) },
        label: { show: true, position: 'inside', color: '#fff', fontSize: 12, formatter: (params) => `${params.name}\n${formatCjeToBillion(params.value)}\n${params.data.zdf.toFixed(2)}%` }
    }));

    return {
        title: { text: 'ÂìÅÁßçÊ∂®Ë∑åÂõæ', left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'item', formatter: (params) => { /* ... (Â§çÊùÇtooltipÔºåÁúÅÁï•) ... */ } },
        series: [{ type: 'treemap', data: treemapSeriesData, width: '100%', height: '85%', top: '15%', roam: false, nodeClick: false, breadcrumb: { show: false } }]
    };
}

function getChart7Option(dataList) {
    const scatterData = dataList.map(item => {
        const prevCcl = item.ccl - item.rz;
        const rzRatio = prevCcl === 0 ? 0 : parseFloat(((item.rz / prevCcl) * 100).toFixed(2));
        return {
            name: getSimplifiedName(item.name),
            value: [item.zdf, rzRatio, item.cdzj, item.cje, item.vol, item.ccl]
        };
    }).filter(item => item.value !== undefined && item.value !== undefined);

    const minSizeMetric = Math.min(...scatterData.map(d => d.value)); // ÈªòËÆ§Áî® cdzj
    const maxSizeMetric = Math.max(...scatterData.map(d => d.value)); // ÈªòËÆ§Áî® cdzj

    return {
        title: { text: 'Ê∂®Ë∑åÂπÖ‰∏éÂ¢û‰ªìÊØîÂÖ≥Á≥ªÂõæ', left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'item', formatter: (params) => { /* ... (Â§çÊùÇtooltipÔºåÁúÅÁï•) ... */ } },
        grid: { left: '10%', right: '10%', bottom: '15%', top: '10%' },
        xAxis: { type: 'value', name: 'Ê∂®Ë∑åÂπÖ (%)', nameLocation: 'middle', nameGap: 25, axisLabel: { formatter: '{value}%' } },
        yAxis: { type: 'value', name: 'Â¢û‰ªìÊØî (%)', nameLocation: 'middle', nameGap: 45, axisLabel: { formatter: '{value}%' } },
        visualMap: {
            type: 'continuous', dimension: 2, // ÈªòËÆ§ cdzj (index 2)
            min: minSizeMetric, max: maxSizeMetric, show: false, inRange: { symbolSize: }
        },
        series: [{
            type: 'scatter', data: scatterData,
            itemStyle: {
                color: (params) => { /* ... (Â§çÊùÇÈ¢úËâ≤ÈÄªËæëÔºåÁúÅÁï•) ... */ return '#95a5a6'; },
                opacity: 0.8, borderColor: 'rgba(255, 255, 255, 0.5)', borderWidth: 2
            },
            label: { show: true, position: 'inside', formatter: '{b}', fontSize: 11, color: '#fff', fontWeight: 'bold' }
        }]
    };
}

function getChart8Option(dataList) {
    // 1. „Äê‰øÆÂ§ç„ÄëÂÆåÊï¥ÂàùÂßãÂåñ counts ÂØπË±°
    const counts = {
        riseStop: { count: 0, label: 'Ê∂®ÂÅú', color: '#B91C1C' },
        rise5: { count: 0, label: '‰∏äÊ∂® > 5%', color: '#EF4444' },
        rise2to5: { count: 0, label: '‰∏äÊ∂® 2-5%', color: '#F87171' },
        rise0to2: { count: 0, label: '‰∏äÊ∂® 0-2%', color: '#FCA5A5' },
        flat: { count: 0, label: 'Âπ≥Áõò', color: '#9CA3AF' },
        fall0to2: { count: 0, label: '‰∏ãË∑å 0-2%', color: '#86EFAC' },
        fall2to5: { count: 0, label: '‰∏ãË∑å 2-5%', color: '#4ADE80' },
        fall5: { count: 0, label: '‰∏ãË∑å > 5%', color: '#22C55E' },
        fallStop: { count: 0, label: 'Ë∑åÂÅú', color: '#15803D' },
    };

    let totalRiseCount = 0;
    let sumRiseZdf = 0;
    let totalFallCount = 0;
    let sumFallZdf = 0;

    // 2. „Äê‰øÆÂ§ç„ÄëË°•ÂÖ® forEach ‰∏≠ÁöÑÁªüËÆ°ÈÄªËæë
    dataList.forEach(item => {
        const zdf = parseFloat(item.zdf);
        if (isNaN(zdf)) return; // Ë∑≥ËøáÊó†ÊïàÊï∞ÊçÆ

        if (zdf > 0) {
            totalRiseCount++;
            sumRiseZdf += zdf;
            if (item.p >= item.zt) counts.riseStop.count++;
            else if (zdf >= 5) counts.rise5.count++;
            else if (zdf >= 2) counts.rise2to5.count++;
            else counts.rise0to2.count++;
        } else if (zdf < 0) {
            totalFallCount++;
            sumFallZdf += zdf;
            if (item.p <= item.dt) counts.fallStop.count++;
            else if (zdf <= -5) counts.fall5.count++;
            else if (zdf <= -2) counts.fall2to5.count++;
            else counts.fall0to2.count++;
        } else {
            counts.flat.count++;
        }
    });

    const avgRiseZdf = totalRiseCount > 0 ? (sumRiseZdf / totalRiseCount).toFixed(2) : '0.00';
    const displayAvgFallZdf = totalFallCount > 0 ? (Math.abs(sumFallZdf) / totalFallCount).toFixed(2) : '0.00';

    // ËøáÊª§ÊéâÊï∞Èáè‰∏∫0ÁöÑÂå∫Èó¥Ôºå‰ΩÜ‰øùÁïô‚ÄúÂπ≥Áõò‚Äù‰ª•‰æøÂú®Âõæ‰æã‰∏≠ÊòæÁ§∫
    const chartData = Object.keys(counts)
        .filter(key => counts[key].count > 0 || key === 'flat')
        .map(key => ({
            name: counts[key].label,
            value: counts[key].count,
            itemStyle: { color: counts[key].color }
        }));
        
    // ÊåâÈ¢ÑËÆæÈ°∫Â∫èÊéíÂ∫èÔºåËÆ©È•ºÂõæÈ¢úËâ≤ÂàÜÂ∏ÉÊõ¥ÂêàÁêÜ
    const order = ['Ê∂®ÂÅú', '‰∏äÊ∂® > 5%', '‰∏äÊ∂® 2-5%', '‰∏äÊ∂® 0-2%', 'Âπ≥Áõò', '‰∏ãË∑å 0-2%', '‰∏ãË∑å 2-5%', '‰∏ãË∑å > 5%', 'Ë∑åÂÅú'];
    chartData.sort((a, b) => order.indexOf(a.name) - order.indexOf(b.name));

    return {
        title: { text: 'ÂìÅÁßçÊ∂®Ë∑åÂπÖÂå∫Èó¥ÁªüËÆ°', left: 'center' },
        backgroundColor: 'transparent',
        tooltip: { trigger: 'item', formatter: '{b}: {c}‰∏™ ({d}%)' },
        legend: {
            orient: 'vertical',
            left: 10,
            top: 20,
            data: chartData.map(item => item.name)
        },
        graphic: [
            { type: 'text', left: '55%', top: '40%', style: { text: `‰∏äÊ∂®Ôºö${totalRiseCount}‰∏™`, fill: '#ef4444', fontSize: 14, fontWeight: 'bold', textAlign: 'center' } },
            { type: 'text', left: '55%', top: '45%', style: { text: `ÂùáÊ∂®Ôºö${avgRiseZdf}%`, fill: '#ef4444', fontSize: 13, textAlign: 'center' } },
            { type: 'text', left: '55%', top: '55%', style: { text: `‰∏ãË∑åÔºö${totalFallCount}‰∏™`, fill: '#22c55e', fontSize: 14, fontWeight: 'bold', textAlign: 'center' } },
            { type: 'text', left: '55%', top: '60%', style: { text: `ÂùáË∑åÔºö${displayAvgFallZdf}%`, fill: '#22c55e', fontSize: 13, textAlign: 'center' } }
        ],
        series: [{
            type: 'pie',
            radius: ['45%', '70%'],
            center: ['55%', '50%'],
            data: chartData,
            avoidLabelOverlap: false,
            label: {
                show: true,
                position: 'outer',
                formatter: '{b}\n{c}‰∏™ ({d}%)',
                color: '#333',
                fontSize: 11,
                fontWeight: 'normal',
                alignTo: 'edge',
                bleedMargin: 5
            },
            labelLine: {
                show: true,
                length: 10,
                length2: 15
            }
        }]
    };
}


/**
 * Ê†∏ÂøÉËæÖÂä©ÂáΩÊï∞ÔºöÁîüÊàêÂõæË°®SVGÔºåÂπ∂‰∏ä‰º†Âà∞R2
 */
async function generateAndUploadChart(env, chartTitle, option, width, height) {
    const chart = echarts.init(null, null, { renderer: 'svg', ssr: true, width, height });
    chart.setOption(option);
    const svg = chart.renderToSVGString();
    
    const subfolder = 'charts/';
    const timestamp = new Date().toISOString().split('T');
    const fileName = `${chartTitle}_${timestamp}.svg`;
    const r2Key = `${subfolder}${fileName}`;

    await env.R2_BUCKET.put(r2Key, svg, { httpMetadata: { contentType: 'image/svg+xml' } });
    
    // ‚ú®„ÄêÈáçË¶Å„ÄëËØ∑Â∞Ü‰∏ãÈù¢ÁöÑURLÊõøÊç¢‰∏∫ÊÇ®Ëá™Â∑±R2Ê°∂ÁöÑÂÖ¨ÂºÄËÆøÈóÆURL
    const publicUrl = `https://pub-8dfbdda6df204465aae771b4c080140b.r2.dev/${r2Key}`;
    
    return { name: fileName, url: publicUrl, size: svg.length };
}

/**
 * „ÄêÊ†∏ÂøÉÂØºÂá∫ÂáΩÊï∞„Äë
 * ÁîüÊàêÊâÄÊúâÂõæË°®ÔºåÂπ∂Â∞ÜÂÆÉ‰ª¨‰Ωú‰∏∫ÂõæÁâáÊ∂àÊÅØÂèëÈÄÅÂà∞ÊåáÂÆöÁöÑËÅäÂ§©ÂÆ§„ÄÇ
 */
export async function generateAndPostCharts(env, roomName) {
    console.log(`[ChartGenerator] Starting for room: ${roomName}`);
    try {
        const dataResponse = await fetch("https://q.want.biz/");
        if (!dataResponse.ok) throw new Error("Failed to fetch data source.");
        const apiData = await dataResponse.json();
        
        // Á°Æ‰øùÊï∞ÊçÆËøáÊª§ÂíåÂâçÁ´Ø‰øùÊåÅ‰∏ÄËá¥ÔºöÂè™‰øùÁïôÊ≤âÊ∑ÄËµÑÈáëÂ§ß‰∫é15‰∫øÁöÑÂìÅÁßç
        let filteredData = apiData.list.filter(item => item.cdzj > 15 * 1e8); 
        if (filteredData.length === 0) {
            console.log("[ChartGenerator] No data meets the criteria (cdzj > 15‰∫ø), skipping chart generation.");
            return;
        }

        // ‰∫§ÊòìÊó∂ÊÆµÂÜÖËøõ‰∏ÄÊ≠•ËøáÊª§Ê¥ªË∑ÉÂìÅÁßç
        // Worker Á´ØÊ≤°Êúâ getSessionTypeÔºåËøôÈáåÁõ¥Êé•‰ΩøÁî®ÁÆÄÂçïÂà§Êñ≠
        const now = new Date();
        const hour = now.getHours();
        const minute = now.getMinutes();
        const isTradingSession = (hour >= 21 || (hour >= 0 && hour < 2) || (hour === 2 && minute <= 30)) || // Â§úÁõò
                                 (hour >= 9 && (hour < 11 || (hour === 11 && minute < 30))) || // Êó•Áõò‰∏äÂçà
                                 (hour >= 13 && (hour < 15 || (hour === 15 && minute === 0))); // Êó•Áõò‰∏ãÂçà

        if (isTradingSession) {
            const hasOpenMarkets = filteredData.some(item => item.jyzt === 0);
            if (hasOpenMarkets) {
                filteredData = filteredData.filter(item => item.jyzt === 0);
            }
        }
        
        if (filteredData.length === 0) {
            console.log("[ChartGenerator] No active data after session filtering, skipping chart generation.");
            return;
        }
        
        console.log(`[ChartGenerator] Data fetched and filtered. ${filteredData.length} items remaining.`);

        const chartsToGenerate = [
            { title: 'ÊúüË¥ßÂìÅÁßçËµ∞ÂäøÂØπÊØî', optionFunc: getChart1Option, width: 1200, height: 600 },
            { title: 'ÊäïÊú∫Â∫¶‰∏éÊ∂®Ë∑åÂπÖÂØπÊØî', optionFunc: getChart2Option, width: 1200, height: 600 },
            { title: 'Â¢û‰ªìÁéá‰∏éÊ∂®Ë∑åÂπÖÂØπÊØî', optionFunc: getChart3Option, width: 1200, height: 600 },
            { title: 'ÂêÑÂë®ÊúüÊ∂®Ë∑åÂπÖÂØπÊØî', optionFunc: getChart4Option, width: 1200, height: 600 },
            { title: 'Ëá™ÂÆö‰πâÊåáÊ†áÂØπÊØî', optionFunc: getChart5Option, width: 1200, height: 600, metric1: 'cdzj', metric2: 'tjd' }, // ‰ΩøÁî®ÈªòËÆ§ÊåáÊ†á
            { title: 'ÂìÅÁßçÊ∂®Ë∑åÂõæ', optionFunc: getChart6Option, width: 800, height: 600 },
            { title: 'Ê∂®Ë∑åÂπÖ‰∏éÂ¢û‰ªìÊØîÂÖ≥Á≥ªÂõæ', optionFunc: getChart7Option, width: 1000, height: 800 },
            { title: 'ÂìÅÁßçÊ∂®Ë∑åÂπÖÂå∫Èó¥ÁªüËÆ°', optionFunc: getChart8Option, width: 800, height: 600 }
        ];

        const uploadPromises = chartsToGenerate.map(chartDef => {
            const option = chartDef.optionFunc(filteredData, chartDef.metric1, chartDef.metric2);
            return generateAndUploadChart(env, chartDef.title, option, chartDef.width, chartDef.height);
        });
        
        const results = await Promise.all(uploadPromises);
        console.log(`[ChartGenerator] Charts uploaded to R2.`);

        const doId = env.CHAT_ROOM_DO.idFromName(roomName);
        const stub = env.CHAT_ROOM_DO.get(doId);

        const postPromises = results.map(chart => {
            const messagePayload = {
                type: 'image',
                imageUrl: chart.url,
                filename: chart.name,
                size: chart.size,
                caption: `üìä Ëá™Âä®ÁîüÊàêÁöÑÂõæË°®: ${chart.name}`
            };
            return stub.postBotMessage(messagePayload, env.CRON_SECRET);
        });
        
        await Promise.all(postPromises);
        console.log(`[ChartGenerator] All charts posted to room: ${roomName}`);

    } catch (error) {
        console.error(`[ChartGenerator] Process failed:`, error.stack || error);
        throw error; // Re-throw to be caught by scheduled handler
    }
}
--- START OF FILE worker.js ---

// src/worker.js (Merged, Final Version - CORRECTED)

/*
 * Ëøô‰∏™ `worker.js` Êñá‰ª∂ÊòØ Cloudflare Worker ÁöÑÂÖ•Âè£ÁÇπÔºåÂÆÉÊâÆÊºîÁùÄ‚ÄúÂâçÂè∞ÊÄªÊú∫‚ÄùÁöÑËßíËâ≤„ÄÇ
 * ÂÆÉÁöÑ‰∏ªË¶ÅËÅåË¥£ÊòØÔºö
 * 1. Â§ÑÁêÜÂÖ®Â±ÄÊÄßÁöÑ„ÄÅ‰∏éÁâπÂÆöËÅäÂ§©ÂÆ§Êó†ÂÖ≥ÁöÑAPIËØ∑Ê±ÇÔºàÂ¶ÇAIÊúçÂä°„ÄÅÊñá‰ª∂‰∏ä‰º†Ôºâ„ÄÇ
 * 2. ËØÜÂà´Âá∫‰∏éÁâπÂÆöËÅäÂ§©ÂÆ§Áõ∏ÂÖ≥ÁöÑËØ∑Ê±ÇÔºàÊó†ËÆ∫ÊòØAPIËøòÊòØWebSocketÔºâÔºåÂπ∂Â∞ÜÂÆÉ‰ª¨ÂáÜÁ°ÆÂú∞ËΩ¨ÂèëÁªôÂØπÂ∫îÁöÑDurable ObjectÂÆû‰æã„ÄÇ
 * 3. ÂìçÂ∫îÂÆöÊó∂Ëß¶ÂèëÂô®ÔºàCron TriggersÔºâÔºåÂπ∂Ë∞ÉÂ∫¶Durable ObjectÊâßË°åÂÆöÊó∂‰ªªÂä°„ÄÇ
 * 4. ‰∏∫Áî®Êà∑Êèê‰æõÂàùÂßãÁöÑHTMLÈ°µÈù¢„ÄÇ
 */
// src/worker.js

// --- ‚ú® Ê†∏ÂøÉ‰øÆÊ≠£ÔºöÊ∑ªÂä† polyfill Êù•ÂÆö‰πâ global ---
// Cloudflare WorkersÁéØÂ¢ÉÊ≤°Êúâ`global`Ôºå‰ΩÜÊúâ‰∫õnpmÂåÖÔºàÂ¶ÇechartsÔºâ‰ºö‰æùËµñÂÆÉ„ÄÇ
// Êàë‰ª¨Âú®ËøôÈáåÂàõÂª∫‰∏Ä‰∏™ÂÖ®Â±ÄÁöÑ `global` ÂèòÈáèÔºåÂπ∂ËÆ©ÂÆÉÊåáÂêëWorkerÁéØÂ¢ÉÁöÑÂÖ®Â±ÄÂØπË±° `self`„ÄÇ
globalThis.global = globalThis;


import { HibernatingChatRoom } from './chatroom_do.js';
import html from '../public/index.html';
import { generateAndPostCharts } from './chart_generator.js';
import { taskMap } from './autoTasks.js';
import { getDeepSeekExplanation, getGeminiExplanation, getGeminiImageDescription } from './ai.js';

// ÂØºÂá∫Durable ObjectÁ±ªÔºå‰ª•‰æøCloudflareÂπ≥Âè∞ËÉΩÂ§üËØÜÂà´ÂíåÂÆû‰æãÂåñÂÆÉ„ÄÇ
export { HibernatingChatRoom };

// --- CORS (Cross-Origin Resource Sharing) Headers ---
// ËøôÊòØ‰∏Ä‰∏™ÂèØÈáçÁî®ÁöÑÂØπË±°ÔºåÁî®‰∫é‰∏∫APIÂìçÂ∫îÊ∑ªÂä†Ê≠£Á°ÆÁöÑCORSÂ§¥ÈÉ®ÔºåÂÖÅËÆ∏Ë∑®ÂüüËÆøÈóÆ„ÄÇ
const corsHeaders = {
    'Access-Control-Allow-Origin': '*', // Áîü‰∫ßÁéØÂ¢ÉÂª∫ËÆÆÊõøÊç¢‰∏∫ÊÇ®ÁöÑÂâçÁ´ØÂüüÂêç
    'Access-Control-Allow-Methods': 'GET, HEAD, POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type, X-Filename',
    'Access-Control-Max-Age': '86400', // È¢ÑÊ£ÄËØ∑Ê±ÇÁöÑÁºìÂ≠òÊó∂Èó¥
};

/**
 * Â§ÑÁêÜÊµèËßàÂô®ÂèëÈÄÅÁöÑCORSÈ¢ÑÊ£ÄËØ∑Ê±ÇÔºàOPTIONSÊñπÊ≥ïÔºâ„ÄÇ
 */
function handleOptions(request) {
    if (
        request.headers.get('Origin') !== null &&
        request.headers.get('Access-Control-Request-Method') !== null &&
        request.headers.get('Access-Control-Request-Headers') !== null
    ) {
        return new Response(null, { headers: corsHeaders });
    } else {
        return new Response(null, { headers: { Allow: 'GET, HEAD, POST, OPTIONS' } });
    }
}

// --- AI Service Functions are now in src/ai.js ---
// Êñá‰ª∂: src/worker.js

/**
 * Áã¨Á´ãÁöÑ„ÄÅÈ°∂Á∫ßÁöÑËæÖÂä©ÂáΩÊï∞ÔºåÁî®‰∫éÂêëÊåáÂÆöÁöÑÊàøÈó¥ÂèëÈÄÅËá™Âä®Â∏ñÂ≠ê„ÄÇ
 * @param {object} env ÁéØÂ¢ÉÂèòÈáè
 * @param {string} roomName Ë¶ÅÂèëÂ∏ñÁöÑÊàøÈó¥Âêç
 * @param {string} text Â∏ñÂ≠êÁöÑÂÜÖÂÆπ
 * @param {object} ctx ÊâßË°å‰∏ä‰∏ãÊñáÔºåÁî®‰∫é waitUntil
 */
async function sendAutoPost(env, roomName, text, ctx) {
    console.log(`Dispatching auto-post to room: ${roomName} via RPC`);
    try {
        if (!env.CHAT_ROOM_DO) {
            throw new Error("Durable Object 'CHAT_ROOM_DO' is not bound.");
        }
        
        const doId = env.CHAT_ROOM_DO.idFromName(roomName);
        const stub = env.CHAT_ROOM_DO.get(doId);

        // „ÄêÈáçÂ§ß‰øÆÊîπ„Äë‰ªé fetch Ë∞ÉÁî®Êîπ‰∏∫ RPC Ë∞ÉÁî®
        // ‰ΩøÁî®‰º†ÂÖ•ÁöÑ ctx.waitUntil Êù•Á°Æ‰øù RPC Ë∞ÉÁî®ÊâßË°åÂÆåÊØï
        ctx.waitUntil(stub.cronPost(text, env.CRON_SECRET));

        console.log(`Successfully dispatched auto-post RPC to room: ${roomName}`);
    } catch (error) {
        console.error(`Error in sendAutoPost for room ${roomName}:`, error.stack || error);
    }
}




// --- ‰∏ªWorkerÂÖ•Âè£ÁÇπ ---
// Âú® worker.js ÁöÑ fetch ÂáΩÊï∞‰∏≠

export default {
    async fetch(request, env, ctx) {
        try {
            if (request.method === 'OPTIONS') {
                return handleOptions(request);
            }

            const url = new URL(request.url);
            const pathname = url.pathname;

            // --- Ë∑ØÁî± 1: ÂÖ®Â±ÄÁã¨Á´ãAPI (‰∏çÈúÄËΩ¨Âèë) ---
            
            // Â∞ÜÊâÄÊúâÂÖ®Â±ÄAPIÁöÑÂà§Êñ≠ÂêàÂπ∂Âà∞‰∏Ä‰∏™if/else ifÁªìÊûÑ‰∏≠
            if (pathname === '/upload') {
                // --- ‚ú® ËøôÊòØÂîØ‰∏Ä‰∏îÊ≠£Á°ÆÁöÑ /upload Â§ÑÁêÜÈÄªËæë ‚ú® ---
                // (Âü∫‰∫éÊÇ®Êèê‰æõÁöÑ‚ÄúÊîπËøõÁâà‚Äù‰ª£Á†ÅÔºåÂπ∂‰øÆÊ≠£‰∫ÜkeyÁöÑ‰ΩøÁî®)
                if (request.method !== 'POST') {
                    return new Response('Method Not Allowed', { status: 405, headers: corsHeaders });
                }
                try {
                    if (!env.R2_BUCKET) {
                        throw new Error('Server config error: R2_BUCKET not bound.');
                    }
                    
                    const filenameHeader = request.headers.get('X-Filename');
                    if (!filenameHeader) {
                        throw new Error('Missing X-Filename header');
                    }
                    
                    const filename = decodeURIComponent(filenameHeader);
                    const contentType = request.headers.get('Content-Type') || 'application/octet-stream';
                    
                    // Ê≠£Á°ÆÁîüÊàêÂåÖÂê´ÁõÆÂΩïÁöÑ„ÄÅÂîØ‰∏ÄÁöÑR2ÂØπË±°Key
                    const r2ObjectKey = `chats/${Date.now()}-${crypto.randomUUID().substring(0, 8)}-${filename}`;
                    
                    // ‰ΩøÁî®Ê≠£Á°ÆÁöÑkey‰∏ä‰º†Âà∞R2
                    const object = await env.R2_BUCKET.put(r2ObjectKey, request.body, {
                         httpMetadata: { contentType: contentType },
                    });
                    
                    // ÁîüÊàê‰∏éÂ≠òÂÇ®Ë∑ØÂæÑÂÆåÂÖ®ÂåπÈÖçÁöÑÂÖ¨ÂºÄURL
                    const r2PublicDomain = "pub-8dfbdda6df204465aae771b4c080140b.r2.dev";
                    const publicUrl = `https://${r2PublicDomain}/${object.key}`; // object.key Áé∞Âú®ÊòØ "chats/..."
                    
                    return new Response(JSON.stringify({ url: publicUrl }), {
                        headers: { 'Content-Type': 'application/json', ...corsHeaders },
                    });

                } catch (error) {
                    console.error('R2 Upload error:', error.stack || error);
                    return new Response(`Error uploading file: ${error.message}`, { 
                        status: 500, 
                        headers: corsHeaders 
                    });
                }

            } else if (pathname === '/ai-explain') {
                // ... /ai-explain ÁöÑÈÄªËæë ...
                const { text, model = 'gemini' } = await request.json();
                if (!text) return new Response('Missing "text"', { status: 400, headers: corsHeaders });

                // ‰øÆÊ≠£ÔºöÁßªÈô§Á°¨ÁºñÁ†ÅÁöÑpromptÔºåÁõ¥Êé•‰ΩøÁî®‰º†ÂÖ•ÁöÑtext
                const fullPrompt = `‰Ω†ÊòØ‰∏Ä‰ΩçÈùûÂ∏∏ËÄêÂøÉÁöÑÂ∞èÂ≠¶ËÄÅÂ∏àÔºå‰∏ìÈó®ÁªôÂ∞èÂ≠¶ÁîüËÆ≤Ëß£Êñ∞Áü•ËØÜ„ÄÇ  ÊàëÊòØ‰∏ÄÂêçÂ∞èÂ≠¶‰∏âÂπ¥Á∫ßÂ≠¶ÁîüÔºåÊàëÁâπÂà´Ê∏¥ÊúõÂºÑÊòéÁôΩ‰∫ãÁâ©ÁöÑÂê´‰πâ„ÄÇ  ËØ∑‰Ω†Áî®Á≤æÂáÜ„ÄÅËØ¶ÁªÜÁöÑËØ≠Ë®ÄËß£ÈáäÔºàMarkdown Ê†ºÂºèÔºâÔºö1. Áî®ÈÄö‰øóÊòìÊáÇÁöÑËØ≠Ë®ÄËß£Èáä‰∏ãÈù¢ËøôÊÆµÊñáÂ≠ó„ÄÇ2. ÁªôÂá∫ÂÖ≥ÈîÆÊ¶ÇÂøµÁöÑÂÆö‰πâ„ÄÇ3. Áî®ÁîüÊ¥ª‰∏≠ÁöÑÊØîÂñªÊàñÂ∞èÊïÖ‰∫ãÂ∏ÆÂä©ÁêÜËß£„ÄÇ4. ‰∏æ‰∏Ä‰∏™ÂÖ∑‰Ωì‰æãÂ≠êÔºåÂπ∂Á§∫ËåÉ‚Äú‰∏æ‰∏ÄÂèç‰∏â‚ÄùÁöÑÊÄùËÄÉÊñπÊ≥ï„ÄÇ5. ÊúÄÂêéÁî®‰∏ÄËá≥‰∏§‰∏™ÈóÆÈ¢òÊù•ÂºïÂØºÊàëÂª∂‰º∏ÊÄùËÄÉ„ÄÇ:\n\n${text}`;
                
                const explanation = model === 'gemini' 
                    ? await getGeminiExplanation(fullPrompt, env) 
                    : await getDeepSeekExplanation(fullPrompt, env);

                return new Response(JSON.stringify({ explanation }), { headers: { 'Content-Type': 'application/json', ...corsHeaders } });

            } else if (pathname === '/ai-describe-image') {
                // ... /ai-describe-image ÁöÑÈÄªËæë ...
                const { imageUrl } = await request.json();
                if (!imageUrl) return new Response('Missing "imageUrl"', { status: 400, headers: corsHeaders });
                const description = await getGeminiImageDescription(imageUrl, env);
                return new Response(JSON.stringify({ description }), { headers: { 'Content-Type': 'application/json', ...corsHeaders } });
            }

            // --- Ë∑ØÁî± 2: ÈúÄË¶ÅËΩ¨ÂèëÁªô DO ÁöÑ API ---
            // ÊòéÁ°ÆÂàóÂá∫ÊâÄÊúâÈúÄË¶ÅËΩ¨ÂèëÁöÑAPIË∑ØÂæÑÂâçÁºÄ
            if (pathname.startsWith('/api/')) {
                let roomName;
                // ÂØπ‰∫éËøô‰∫õAPIÔºåÊàøÈó¥ÂêçÂú®Êü•ËØ¢ÂèÇÊï∞Èáå
                if (pathname.startsWith('/api/messages/history') || pathname.startsWith('/api/reset-room')) {
                    roomName = url.searchParams.get('roomName');
                }
                // (Êú™Êù•ÂèØ‰ª•‰∏∫ÂÖ∂‰ªñAPIÂú®ËøôÈáåÊ∑ªÂä† roomName ÁöÑËé∑ÂèñÈÄªËæë)

                if (!roomName) {
                    return new Response('API request requires a roomName parameter', { status: 400 });
                }

                if (!env.CHAT_ROOM_DO) throw new Error("Durable Object 'CHAT_ROOM_DO' is not bound.");
                const doId = env.CHAT_ROOM_DO.idFromName(roomName);
                const stub = env.CHAT_ROOM_DO.get(doId);
                return stub.fetch(request); // Áõ¥Êé•ËΩ¨ÂèëÂπ∂ËøîÂõûDOÁöÑÂìçÂ∫î
            }

            // --- Ë∑ØÁî± 3: ÊàøÈó¥È°µÈù¢Âä†ËΩΩ Âíå WebSocket ËøûÊé• ---
            // ÂåπÈÖçÊâÄÊúâ‰∏ç‰ª• /api/ ÂºÄÂ§¥ÁöÑË∑ØÂæÑÔºå‰æãÂ¶Ç /test, /general
            const pathParts = pathname.slice(1).split('/');
            const roomNameFromPath = pathParts;

            // ËøáÊª§ÊéâÁ©∫ÁöÑË∑ØÂæÑÈÉ®ÂàÜÂíå favicon.ico ËØ∑Ê±Ç
            if (roomNameFromPath && roomNameFromPath !== 'favicon.ico') {
                 if (!env.CHAT_ROOM_DO) throw new Error("Durable Object 'CHAT_ROOM_DO' is not bound.");
                 const doId = env.CHAT_ROOM_DO.idFromName(roomNameFromPath);
                 const stub = env.CHAT_ROOM_DO.get(doId);
                 const response = await stub.fetch(request);

                 // Âè™ÊúâÂú®DOÊòéÁ°ÆË¶ÅÊ±ÇÊó∂ÔºåÊâçËøîÂõûHTML
                 if (response.headers.get("X-DO-Request-HTML") === "true") {
                     return new Response(html, { headers: { 'Content-Type': 'text/html;charset=UTF-8' } });
                 }
                 return response;
            }

            // --- Ë∑ØÁî± 4: Ê†πË∑ØÂæÑ Êàñ ÂÖ∂‰ªñÊú™ÂåπÈÖçË∑ØÂæÑÔºåÁõ¥Êé•ËøîÂõûHTML ---
            return new Response(html, { headers: { 'Content-Type': 'text/html;charset=UTF-8' } });

        } catch (e) {
            console.error("Critical error in main Worker fetch:", e.stack || e);
            return new Response("An unexpected error occurred.", { status: 500 });
        }
    },

    /**
     * „ÄêÈáçÊûÑÂêé„ÄëÂ§ÑÁêÜÁî±Cron TriggerËß¶ÂèëÁöÑÂÆöÊó∂‰∫ã‰ª∂„ÄÇ
     */
async scheduled(event, env, ctx) {
        console.log(`[Worker] Cron Trigger firing! Rule: ${event.cron}`);

        const taskFunction = taskMap.get(event.cron);

        if (taskFunction) {
            console.log(`[Worker] Executing task for cron rule: ${event.cron}`);
            
            // „ÄêÂÖ≥ÈîÆ‰øÆÊîπ„Äë: ÊâßË°å‰ªªÂä°Âπ∂Ëé∑ÂèñËøîÂõûÁöÑÁä∂ÊÄÅÁªìÊûú
            const result = await taskFunction(env, ctx);
            
            // Â¶ÇÊûú‰ªªÂä°ÂáΩÊï∞ËøîÂõû‰∫ÜÁªìÊûúÔºåÂ∞±ËøõË°åÂπøÊí≠ÈÄöÁü•
            if (result && result.roomName) {
                try {
                    const doId = env.CHAT_ROOM_DO.idFromName(result.roomName);
                    const stub = env.CHAT_ROOM_DO.get(doId);
                    
                    // ÂáÜÂ§áË¶ÅÂπøÊí≠ÁöÑÁ≥ªÁªüÊ∂àÊÅØÂÜÖÂÆπ
                    const systemMessagePayload = result.success 
                        ? { message: `‚úÖ ÂÆöÊó∂‰ªªÂä°'${event.cron}'ÊâßË°åÊàêÂäü: ${result.message}`, level: 'SUCCESS' }
                        : { message: `‚ùå ÂÆöÊó∂‰ªªÂä°'${event.cron}'ÊâßË°åÂ§±Ë¥•: ${result.error}`, level: 'ERROR', data: result };

                    // Ë∞ÉÁî®Êñ∞ÁöÑRPCÊñπÊ≥ïÊù•ÂπøÊí≠ÈÄöÁü•
                    // ÂêåÊ†∑‰ΩøÁî® waitUntil Á°Æ‰øùÂÆÉÂú®ÂêéÂè∞ÂÆåÊàê
                    ctx.waitUntil(stub.broadcastSystemMessage(systemMessagePayload, env.CRON_SECRET));

                } catch(e) {
                    console.error(`[Worker] Failed to broadcast cron status for room ${result.roomName}:`, e);
                }
            }

        } else {
            console.warn(`[Worker] No task defined for cron rule: ${event.cron}`);
        }
    },
};
Summary of Changes and How They Address Your Requirements:
1. Batch Processing and Debouncing:

messageQueue and rafScheduled: New global variables introduced. appendChatMessage no longer directly appends to allMessages or triggers renderVirtualWindow. Instead, it pushes messages into messageQueue.
processMessageQueue(): This new function is responsible for:
Taking a batch of messages (MESSAGE_BATCH_SIZE) from messageQueue.
Adding them to allMessages (with deduplication).
Triggering renderVirtualWindow(true) to update the UI and scroll to the bottom.
It is scheduled using requestAnimationFrame for optimal rendering.
A setTimeout with MESSAGE_BATCH_DEBOUNCE_MS is added within appendChatMessage to debounce the requestAnimationFrame scheduling, ensuring that if messages arrive very rapidly, they are collected into larger batches before triggering a UI update.
2. Message Deduplication and Caching:

messageIdSet (new Set): This is used to store the IDs of all messages currently in allMessages.
Improved appendChatMessage: Before adding a message to messageQueue, it first checks messageIdSet.has(msg.id) for quick deduplication.
processHistoryMessages updated: Also uses messageIdSet to avoid adding duplicate messages from history.
Cache Size Limit: MAX_ALL_MESSAGES (set to 500) is applied consistently in processMessageQueue (for new messages) and processHistoryMessages (for initial history loading) to prevent memory growth. When messages are shifted out of allMessages, their IDs are also removed from messageIdSet and messageHeights.
3. Strategy Pattern Optimization:

messageHandlers object: The large switch (data.type) statement in onSocketMessage has been replaced with a messageHandlers object where keys are message types (e.g., 'chat', 'welcome') and values are their corresponding handler functions.
This makes onSocketMessage cleaner and new message types can be added easily without modifying the core switch logic.
4. Performance Optimization:

processHistoryMessages with requestIdleCallback: When a welcome message with a large history array arrives, processHistoryMessages now uses requestIdleCallback to process the history in CHUNK_SIZE (50 messages) batches during the browser's idle periods. This prevents blocking the main thread and keeps the UI responsive during initial load.
Delayed UI updates: The batch processing for new messages naturally delays UI updates, as renderVirtualWindow is only called after a batch of new messages is processed, not for every single incoming message. throttledUpdateUI is still used for general UI elements like user lists.
5. Memory Management:

Consistent Cache Limits: MAX_ALL_MESSAGES (500) is strictly enforced for allMessages (frontend and backend Durable Object).
messageIdSet and messageHeights synchronization: When messages are removed from allMessages (via shift()), their corresponding entries are explicitly deleted from messageIdSet and messageHeights maps to prevent memory leaks.
The virtual scrolling logic already ensures that only visible messages (plus overscan) have active DOM nodes, further optimizing memory usage.
6. Error Handling Optimization:

showAppNotification() (new function): A new, general-purpose notification function replaces direct alert() calls. It uses a CSS class to show a small, temporary toast message at the bottom of the screen, which is less intrusive and non-blocking.
isError parameter: Allows notifications to have different styles (e.g., red for errors) for better UX.
Pre-processing Heartbeat: A quick string comparison check for heartbeat messages is added at the very beginning of onSocketMessage to avoid unnecessary JSON.parse and subsequent processing for high-frequency, non-critical messages.
The Durable Object (chatroom_do.js) was also updated to broadcast a system_notification for cron task results, which the frontend onSocketMessage handler now processes and displays using showAppNotification.
These changes collectively enhance the frontend's performance, particularly in scenarios with a high volume of chat messages and large historical data.

To deploy these changes:

Replace the content of your public/index.html with the new optimized index.html content.
Make sure the autoTasks.js, chatroom_do.js, ai.js and worker.js files are also updated to the provided versions, as there are small interdependencies and new message types introduced (like system_notification and postBotMessage returning a result in autoTasks.js).
Ensure your wrangler.toml has the correct R2 bucket name (yuangs) and cron triggers.
After updating the files, you can deploy your Cloudflare Worker project.