[⚠  ⚠MUSIC PLAYING] DAVID MALAN: All right. This is CS50, Harvard University's Introduction to the Intellectual Enterprises of Computer Science and the Art of Programming. My name is David Malan, and I actually took this class myself some years ago, but I almost didn't. It was my first year in college and my roommates and I were living in Matthews Hall, for those familiar. 
音乐播放] 大卫·马兰：好的。这是哈佛大学 CS50 课程，计算机科学智力企业入门及编程艺术。我叫大卫·马兰，我实际上几年前也上过这门课，但差点没去。那是我大学的第一年，我和室友住在马修斯堂，对熟悉的人来说。

[CHEERING]   [欢呼声]

Nice, Matthews. Our claim to fame, actually, at the time was that our room was literally Matt Damon's just three years' prior. So onward from that. But my first year, I didn't really have the nerves to set foot in this classroom, let alone computer science. In fact, for me, computer science, and CS50 in particular, was very much this class to beware. Like, I was kind of comfortable with computers, but I certainly wasn't among those more comfortable with computers. 
很好，马修斯。那时，我们最出名的说法就是我们的房间实际上是三年前马特·达蒙住过的。所以，就这样继续下去。但我的第一年，我并没有勇气踏入这个教室，更不用说学习计算机科学了。实际上，对我来说，计算机科学，尤其是 CS50，是一个非常需要警惕的课程。就像，我对电脑还算熟悉，但肯定不是那些对电脑更熟悉的人之一。

And so I shied away my first year. Instead, I actually took a whole lot of classes in government. In fact, in high school, I was really enjoying history. I loved this constitutional law class that I took my senior year of high school. And so I figured, OK, if that's what I liked in high school and if that's where my comfort zone was, that's probably what I should be doing in college. And so I essentially declared as my concentration or major government for the first year, year and a half of school. 
因此我在第一年退缩了。相反，我实际上在政府领域选修了很多课程。事实上，在高中时，我真的很喜欢历史。我喜欢我在高中最后一年上的宪法法课程。所以我心想，好吧，如果我在高中喜欢这个，如果那是我舒适区的地方，那么这可能就是我大学应该做的事情。所以我基本上在学校的头一年半将政府作为我的专业或主修。

But my sophomore year when I was living actually in Mather House instead. OK, no one from Mather. In Mather House instead, it was-- I sort of followed some friends, I think the first week of class in September of that year to a class called CS50. And honestly, once I stepped foot in that classroom, the professor at the time was a famous computer scientist by the name of Brian Kernighan, now at Princeton. 
但在我大二那年，我住在马瑟屋。好吧，没有人在马瑟屋。在马瑟屋，我跟着一些朋友，我想是在那年的九月第一周的课程中，上了一门叫做 CS50 的课程。说实话，一旦我踏入那个教室，当时的教授是一位名叫布莱恩·克尼汉的著名计算机科学家，现在在普林斯顿大学。

Like, I was hooked. And literally would I go back thereafter on Friday evenings when, at the time, problem sets were released and sit down at 7:00, 8:00 PM on Friday nights and dive into homework. Which isn't necessarily something we recommend, per se. But for me, it was like this sign that, wow, I've sort of found my calling. I found my classmates here on campus. And that's not going to be the case for everyone. Certainly, we have no expectations that after taking one computer science class that you will or might want to take others. 
像是，我完全着迷了。实际上，在那之后，我每个周五晚上都会回去，当时问题集会发布，然后在周五晚上 7 点或 8 点坐下，一头扎进作业中。这并不是我们特别推荐的事情。但对我来说，这就像一个标志，哇，我似乎找到了自己的使命。我在校园里找到了我的同学。这并不适用于每个人。当然，我们并没有期望你在上完一门计算机科学课后会或想要再上其他课程。

But what's so empowering about computer science and CS50 in particular is it's so applicable to the broader world, whether you're in the arts, humanities, social sciences, natural sciences, or beyond, it's just so applicable the concepts and the practical programming skills with which you will exit a class like this. Now it's going to be challenging along the way, and indeed, I put in my time back in the day, and even I did find it challenging. 
但计算机科学，尤其是 CS50，之所以如此赋权，是因为它如此适用于更广泛的世界，无论你是艺术、人文、社会科学、自然科学还是其他领域，这些概念和你在这种课程中获得的实际编程技能都是如此适用。现在，在过程中这将会是具有挑战性的，事实上，我当年也觉得它具有挑战性。

And here, for instance, is a photograph of a very famous MIT hack, so to speak, from down the road, whereby it communicates that getting an education from MIT is like trying to drink from a fire hose. Which is to say there's going to be so much information, like so much new stuff that certainly on any given day of the week, you're not going to be able to absorb all of it that first time around. But at the end of the day, it's through that challenge, putting the time in, that the returns are therefore just so much higher at the end of the course. 
在这里，举个例子，有一张非常著名的麻省理工学院黑客活动的照片，可以说是从附近拍摄的，它传达了从麻省理工学院接受教育就像试图从消防水龙带中喝水一样。也就是说，将会有如此多的信息，如此多的新内容，以至于在任何给定的一周中，你都不可能在第一次就吸收所有这些内容。但最终，正是通过这个挑战，投入时间，课程结束时的回报才会如此之高。

And indeed, will you walk out of the course with a much better understanding, not only of computer science and programming, but ultimately how to teach yourself new technologies and beyond. For the next three plus months, will we have teaching fellows, teaching assistants, course assistants, and myself by your side guiding you through the course's material. But the goal by term's end is to take those and leave those training wheels off so that you're well-equipped to go teach yourself new ideas beyond the class itself. 
事实上，你将带着对计算机科学和编程的更深入理解走出这门课程，最终学会如何自学新技术。在接下来的三个月里，我们将有教学助理、助教、课程助理以及我自己陪伴在你身边，指导你学习课程材料。但课程结束的目标是让你摆脱这些辅助轮，以便你能够充分准备去自学课堂之外的新想法。

Take comfort, though, in knowing that most CS50 students have never taken a CS course before, and indeed, as per the syllabus, what ultimately matters in this course is not so much where you end up relative to your classmates but where you end up relative to yourself when you began. And when you began is thus today. And so consider just how comfortable or uncomfortable you are with computing, let alone computer science and programming, particularly if you've never explored either in a classroom before, and consider the delta just a few months from now that will really describe how far you have come. 
尽管如此，请放心，因为大多数 CS50 学生之前从未上过计算机科学课程，实际上，根据教学大纲，这门课程最终关注的并不是你在同学中的相对位置，而是你相对于自己开始时的进步。而你的起点就是今天。因此，请思考一下你对计算机，尤其是计算机科学和编程的舒适程度，尤其是如果你之前从未在课堂上探索过这些领域，然后考虑几个月后的变化，这将真正描述你走了多远。

And that is all that matters, not how much the student to the left or the right, in front or behind you right now, knows. With that said, let me add some additional inspiration, if I may. Here's a photograph of my own very first homework assignment in CS50 from 1996, and I will draw your attention to the fact that even though this is a so-called hello world program that we'll play with ourselves next week, it is pretty much literally the shortest, easiest program you can write in a programming language called C. 
这就是最重要的，不是你现在左右、前后同学知道多少。话虽如此，如果可以的话，让我再提供一些灵感。这是我在 1996 年 CS50 的第一个作业的照片，我要提醒大家的是，尽管这是我们下周将要玩儿的所谓“Hello World”程序，但这几乎是在 C 语言中你能写的最短、最简单的程序。

I still somehow got minus 2 on my very first homework assignment, which is to say, we're all going to make mistakes along the way. But the goal will be to learn and enjoy that process here on out. At the end of the day, too, like me, you'll exit with your own proudly held high took CS50 t-shirt as is our tradition too. With that said, there are so many other traditions within CS50, both on campus and off. And in particular, do we try in CS50 to provide not only the academic support structure that you might want going through the class, but also a collective shared community experience. 
我仍然不可思议地在第一次作业上得了负 2 分，也就是说，我们都会在过程中犯错误。但目标将是学习和享受这个过程。最后，就像我一样，你们也会带着自己自豪地举起的 CS50 T 恤毕业，这是我们传统的做法。话虽如此，CS50 中还有许多其他传统，无论是在校园内还是在校园外。特别是，我们在 CS50 中不仅试图提供你们在上课过程中可能需要的学术支持结构，还试图提供一个集体共享的社区体验。

Which is to say in just a few days we'll start off the term formally with CS50 Puzzle Day, which is not only an opportunity to get together with friends, with pizza and prizes and also logic puzzles of sorts, but really to send the message that computer science itself is not about programming, it's not about C, it's not about Python, it's not about programming languages per se, but about problem solving, ever more so collaboratively with other smart people by your side in this class or beyond. 
也就是说，在短短几天后，我们将正式开始学期的 CS50 拼图日，这不仅是一个与朋友聚在一起、享受披萨和奖品以及逻辑拼图的机会，更重要的是传达一个信息，那就是计算机科学本身不是关于编程，不是关于 C 语言，不是关于 Python，不是关于编程语言本身，而是关于解决问题，尤其是与身边的其他聪明人合作解决问题，无论是在这个班级还是在班级之外。

And indeed, are there, toward the end of the semester, reinforcements of the same by way of a little something that we call the CS50 Hackathon, which will be an opportunity overnight to dive into your own final projects, the capstone of this course, thereafter followed by the CS50 fair, which will be a campus wide exhibition for students, faculty, and staff across campus of your very own final projects, be it your very own web app or mobile app or anything else you decide to create by term's end. 
确实，在学期末，我们会有一种叫做 CS50 黑客马拉松的加强版活动，这将是一个通宵达旦地深入自己的最终项目的机会，这是本课程的压轴大戏，之后还将有 CS50 展览，这将是一个校园范围内的展览，展示学生、教师和员工们的最终项目，无论是你的个人网站或移动应用，还是你决定在学期结束时创作的任何其他东西。

And indeed, the objective at the end of the day, truly with that final project in particular, is going to be to create for yourselves, for your classmates, for attendees, something that we didn't even teach you how to do. And indeed, that will signal ultimately that you're indeed on your way and ready. Toward that end, thought we would give you a sense of CS50's past by way of this short video, if we could dim the lights, that paints a picture of all that awaits here and beyond. 
确实，最终的目标，尤其是针对那个最终项目，是为自己、为同学们、为参与者创造一些我们甚至没有教过你们如何去做的东西。确实，这将最终表明你们已经准备好并正在路上。为此，我们想通过这个简短的视频让大家了解一下 CS50 的过去，如果可以的话，请调暗灯光，这个视频将描绘出这里和未来的所有期待。

[VIDEO PLAYBACK]   [视频播放]

[MUSIC PLAYING]   [音乐播放]

[END PLAYBACK]   [播放结束]

DAVID MALAN: All right, so welcome aboard to CS50 and computer science itself. So what is computer science? Well, put simply, it's the study of information. Like, how do you represent it and how do you process it. But more fundamentally, what we'll teach you in this class is computational thinking. That is to say, the application of ideas from computer science to problems of interest to us within the class and problems of interest to you after the class. 
大卫·马拉恩：好的，欢迎加入 CS50 以及计算机科学本身。那么，什么是计算机科学呢？简单来说，它是对信息的研究。比如，你是如何表示信息的，又是如何处理信息的。但更根本的是，我们在这门课中要教授的是计算思维。也就是说，将计算机科学的思想应用于课堂内对我们感兴趣的问题，以及课堂后对你感兴趣的问题。

And so at the end of the day, what computer science really is is about problem solving, ergo that sort of global applicability. And by problem solving, we mean something quite simple. In fact, we can distill it as follows with this mental image. This is problem solving. You've got some problem to solve, thus known as the input that you want to solve. And the goal, of course, to problem solving is to actually produce a solution. So the output in this model would be the solution. 
因此，从本质上讲，计算机科学真正关注的是问题解决，即这种全球适用性。而所谓问题解决，我们指的是一个非常简单的过程。实际上，我们可以用以下这种心理图像来概括。这就是问题解决。你有一些问题需要解决，这就是你想要解决的问题的输入。当然，问题解决的目标是产生一个解决方案。在这个模型中，输出就是解决方案。

The interesting part ultimately is going to be in how you process that input and turn it into that output, ergo solving problems. But before we can do that, we all kind of have to agree how to represent sent these inputs and outputs, especially if we want to do it in a standardized global way using literally computers, be them laptops, desktops, phones, or most any other kind of electronic device nowadays. So how can we do that? Well, there's different ways to represent information in the world. 
最终有趣的部分将在于你如何处理这些输入并将其转化为输出，也就是解决问题。但在我们能够这样做之前，我们都需要达成某种共识，即如何表示这些输入和输出，尤其是如果我们想以标准化的全球方式使用计算机（无论是笔记本电脑、台式机、手机还是当今大多数其他类型的电子设备）来实现这一点。那么我们该如何做呢？嗯，世界上有不同方式来表示信息。

For instance, if I were to take attendance old school style, maybe in a smaller room, I might do 1, 2, 3, 4, 5, 6, 7, and so forth and just count people on my human hands. That's actually known as unary notation, otherwise mathematically known as base one, because you're using your fingers literally in this model as digits. But a little quick question. 
例如，如果我要以老式的方式点名，可能在较小的房间里，我可能会数 1、2、3、4、5、6、7 等等，然后用手指数人数。这实际上被称为一进制表示法，在数学上称为基一，因为在这个模型中你实际上是用手指作为数字的。但有一个小问题。

How high can you count with one human hand? Five is incorrect if you use a different base system than one. So it's obviously correct if you're just using unary and just counting 1, 2, 3, 4, 5. But I dare say I can come up with more patterns in my human hand alone that would enable me, without a second hand or a couple of feet, to count higher than five. In fact, maybe for those more comfortable, how high could you actually count on a single human hand, perhaps? 
你能用一只手数到多少？如果你使用的是非十进制系统，那么五是不正确的。所以如果你只使用一进制，只数 1、2、3、4、5，那显然是正确的。但是，我敢打赌，仅凭我的一只手，就能创造出更多的模式，使我无需第二只手或双脚，就能数到比五更高的数字。事实上，对于那些更习惯的人来说，你实际上能用一只手数到多少呢？

So 31, believe it or not, is, in fact, the correct answer. But why? Well, here I initially started pretty naively. 1, 2, 3, 4, 5. And I just combined all of my fingers and counted the collective total. But what if I'm a little more clever and take into account the pattern of fingers that go up. So maybe this is still zero. This is one. But now maybe we just agree universally that this is two. Even though it's just my single pointer finger. 
所以，31，信不信由你，确实是正确答案。但是为什么呢？好吧，我最初的做法相当天真。1、2、3、4、5。我只是把所有的手指加起来，计算总数。但是，如果我稍微聪明一点，考虑到手指抬起的模式呢？所以，这个可能还是零。这是 1。但现在我们可能普遍认为这是 2，尽管这只是我的食指。

Maybe we all just agree that this is three with two fingers up. Maybe we agree that this is often offensive with just one middle finger up, but this would then be four. This could then be five. This could then be six. This could be seven. And if I keep permuting my fingers in this way-- allow me to spoil it-- this would be, in fact, 31. But again, why? But the difference here is that we're no longer using unary or base one as a mathematician would say, but rather base two. 
我们可能都同意，这是用两个手指表示的三。我们可能同意，只用一个中指表示通常很冒犯，但这样就是四。这可能是五。这可能是六。这可能是七。如果我继续这样变换手指——让我先剧透一下——实际上这将变成 31。但问题是为什么？但这里的区别是，我们不再使用一进制或基一，而是使用二进制。

Because if we take into account not just the total number of fingers that I'm using, but whether each finger is down or up being therefore in two potential states. Down, up, A, B, black, white, however you want to distinguish those two states of the world, you're now operating what's called base two, and perhaps more familiarly, even if you're not a computer person per se, this is the so-called binary system. And odds are, even if you're not a computer science person at all, you probably generally know that computers only understand or speak what alphabet, so to speak? 
因为如果我们不仅考虑我使用的总手指数，还要考虑每个手指是放下还是举起，因此处于两种潜在状态。放下，举起，A，B，黑色，白色，无论你如何区分这两种状态的世界，你现在正在操作的是所谓的二进制，也许更熟悉，即使你不是计算机专业人士，这也是所谓的二进制系统。而且，即使你不是计算机科学专业人士，你很可能一般都知道，计算机只理解或使用什么字母表，对吧？

So ones and zeros, zeros and ones, otherwise known as the binary system. And in fact, there's a term of art here that's worth noting. When you're using zeros and ones, which, of course, are a total of two digits, you have binary digits, so to speak-- bi implying two, which means there's two possibilities, zero or one. If we actually get rid of some of these letters and then join these two phrases, here you have a technical term that is a bit. A bit is just a binary digit, which is to say it's a zero or one. 
所以一和零，零和一，也就是我们所说的二进制系统。实际上，这里有一个术语值得注意。当你使用零和一时，当然，总共只有两个数字，你就有二进制位，或者说“bi”意味着二，这意味着有两种可能性，零或一。如果我们实际上去掉一些字母，然后合并这两个短语，这里就有一个技术术语，叫做比特。比特就是二进制位，也就是说它是一个零或一。

And this is in contrast, of course, with the system you and I know as the decimal system. Dec implying 10, because in the real world you and I daily use zero through nine, which is 10 possibilities. Computers only use zero and one, that is to say two bits, to represent information instead. So how do we represent this information, especially when at the end of the day what we're using are indeed computers and electronic devices? Well, if I want to represent zero, I can actually think of this as analogous to the physical world. 
这与我们所知的十进制系统形成对比。十进制意味着十，因为在现实世界中，我们每天使用的零到九，也就是十种可能性。计算机只使用零和一，也就是说两个比特，来表示信息。那么我们如何表示这些信息呢？尤其是当我们最终使用的是计算机和电子设备时。嗯，如果我想表示零，我实际上可以将其视为与物理世界相似。

Maybe I have a light bulb that's off or on controlled by a switch that turns it off or on. So you can think of a binary digit that is a zero as really just being a light bulb that is off. By contrast, if you think of a one in the digital world as, of course, being the second of two possibilities, you can think of that in the human or analog world, the physical world, as being a light bulb that is on. And in fact, what's inside of your Mac, your PC, your Android phone, your iPhone are millions of tiny little light switches known as transistors that just can be turned on or off, on or off. 
可能我有一个开关控制的灯泡，它可以打开或关闭。所以你可以把二进制位中的零想象成一个关闭的灯泡。相比之下，如果你在数字世界中把一想象成两种可能性中的第二种，那么在人类或模拟世界中，在物理世界中，你可以把它想象成一个打开的灯泡。实际上，你 Mac、PC、Android 手机、iPhone 里面的数百万个微小的开关，也就是晶体管，可以打开或关闭。

And essentially, you can use those transistors to store information because if you want to store a zero, you turn one of those switches off. If you want to store a one, you turn one of those switches on. Of course, that sort of invites the question, well, how do we count higher than zero or one? Well, we would seem to need to use more than just maybe a single bit, a single light bulb. So if we wanted to count higher than, for instance, zero or one, why don't we go ahead and maybe do this? 
事实上，你可以使用这些晶体管来存储信息，因为如果你想存储零，就关闭其中一个开关。如果你想存储一，就打开其中一个开关。当然，这会引发一个问题，那就是我们如何计数超过零或一？显然，我们需要使用不止一个比特，一个灯泡。那么，如果我们想计数超过零或一，比如，为什么不这样做呢？

So just so I have some place to put these, let me borrow some of our actual physical light bulbs here from the stage. And let me propose that now, with three bits on the stage, three light switches, three transistors, whatever metaphor you're most comfortable with, this is how a computer would represent a zero, because all of them are off. So it's off, off, off. 
所以，为了有一个地方放置这些，让我从舞台上借一些实际的物理灯泡。现在，在舞台上放三个，三个开关，三个晶体管，或者用你最喜欢的任何比喻，这就是计算机如何表示零，因为它们都是关着的。所以是关，关，关。

But if a computer wanted to count to one, we could do naively this. We could turn this on. If the computer wanted to turn represent two, we could do this. And if a computer wanted to represent three, we could do this. But I'm kind of painting myself into a corner and not using these light bulbs as cleverly as I could, because at the moment I've only counted as high as three. So if I want to count to four, to five, to six, I'm going to need more and more light bulbs. Can we be a little more clever? 
但是，如果计算机想要数到一，我们可以这样天真地做。我们可以打开这个。如果计算机想要表示二，我们可以这样做。如果计算机想要表示三，我们可以这样做。但我有点把自己画进了一个角落，没有充分利用这些灯泡，因为我目前只能数到三。所以，如果我想数到四、五、六，我就需要越来越多的灯泡。我们能更聪明一点吗？

Well, again, someone else who's among those more comfortable, what's the spoiler here? How high using binary zeros and ones could I count with three light bulbs total? In back? Yeah. So seven here is the answer. And if that, too, you're sort of wondering, how are people figuring out 31 and 7? That's the goal at hand here. So let me do this. Let me turn all of these off again so that my three light bulbs or switches again represent zero. 
好吧，又是别人，那些更自在的人，这里的悬念是什么？用三个灯泡总共能数到多高？在后面？是的。所以这里七是答案。如果你也在想，人们是怎么算出 31 和 7 的？这就是我们的目标。所以让我来做这个。让我再次把它们都关掉，这样我的三个灯泡或开关再次代表零。

And the first one's easy. This is how a computer would represent the number one. It would be on, off, off. How, though, is a computer going to represent two? Well, just like my proposed finger example. Let's do this. Let's turn this one off and this one on. That is how a computer would represent two. By saying off, on, off. In other words, 010 would be the way to pronounce it digitally. What if I instead want to represent three? That's how on my finger I did this, with two fingers. 
第一个很简单。这就是计算机表示数字一的方式。它会打开，关闭，关闭。那么，计算机是怎么表示数字二的呢？就像我提出的手指例子。让我们来做这个。让我们把这个关掉，把这个打开。这就是计算机表示二的方式。通过说关闭，打开，关闭。换句话说，010 就是数字的发音方式。如果我想要表示三呢？这就是我在手指上做的，用两个手指。

Well, I'm going to turn this one on. This is three. Now, this will, for those less comfortable, be non-obvious. This now is how I would represent the number four. This is how I would represent five. This is how I would represent six. And this, as per the spoiler, is how I would represent seven. So perhaps very non-obvious what it was I just did or why I chose those patterns. But I dare say if you rewind in your mind's eye or literally later on video, you'll find that I actually did show you eight distinct patterns of light bulbs. 
好吧，我要打开这个。这是三。现在，对于那些不太舒服的人来说，这将是非直观的。现在，我将如何表示数字四。这是如何表示五。这是如何表示六。而根据预告，这是如何表示七的。所以，我敢说，如果你在心中回放或者稍后看视频，你会发现我实际上向你展示了八个不同的灯泡模式。

The first one was off, off, off. The last one was, on, on, on. And there were another six total in between then. Well, wait, why seven? Well, if you start counting at zero and I claim there's eight possibilities, you can only count from zero to seven, as we will soon see. So how are these patterns coming about and what is it that our computers are actually doing? Well, it's actually doing something a little like this, quite like in decimal. 
第一个灯是关的，关的，关的。最后一个灯是，开的，开的，开的。在这之间还有另外六个灯。等等，为什么是七？如果你从零开始计数，而我声称有八种可能性，你只能从零数到七，就像我们很快就会看到的那样。那么这些模式是如何产生的，我们的计算机实际上在做什么呢？实际上，它做的是类似这样的事情，非常像十进制。

So in the human world, you and I are very much in the habit of using base 10, zero through nine, a.k.a. Decimal. Well, how do we use it instinctively as humans? Well, what's this number obviously on the screen? 123. But why is it 123? Like, for years you haven't really thought about why this pattern of symbols or digits on the screen, one, two, three, represents mathematically this number that you know obviously as 123. 
所以在人类世界中，我和你都非常习惯使用十进制，也就是从零到九的基数。那么，我们是如何本能地使用它的呢？比如说，屏幕上显然显示的这个数字是什么？123。但是，为什么是 123 呢？就像多年来，你并没有真正思考过为什么屏幕上这些符号或数字的排列，一、二、三，在数学上代表你显然知道的这个数字 123。

But if you rewind to grade school, odds are, like me, you were taught that the rightmost digit is in the ones column, this second digit is in the tens column, this digit is in the hundreds column, and so forth. So even though none of us have to do this math explicitly, what you're instantly doing is 100 times 1 plus 10 times 2 plus 1 times 3, which gives you 100 plus 20 plus 3. Oh, that's why it is 123, because these digits in this order have that significance. The digits to the left have more weight, so to speak, than the digits to the right. 
但是如果你回想起小学时代，很可能像我一样，你被教导说最右边的数字位于个位，第二个数字位于十位，这个数字位于百位，以此类推。所以尽管我们都不需要明确地进行这种数学运算，你瞬间所做的实际上是 100 乘以 1 加上 10 乘以 2 加上 1 乘以 3，这给出了 100 加上 20 加上 3。哦，这就是为什么它是 123 的原因，因为这些数字按照这个顺序具有这样的意义。左边的数字比右边的数字更有权重，换句话说。

So what can we take away from this? Well, let's generalize it first as just any three digit number. So number, number, number. The ones column, the tens column, the hundreds column. But there's some math going on there, and it's not particularly sophisticated. Those are actually powers of 10. So 10 to the 0, 10 to the 1, 10 to the 2, and there's your decimal system. Because the base in this value is a 10, that's because there's 10 possibilities for each of those placeholders, zero through nine. 
所以，我们能从中得到什么？嗯，首先让我们将其泛化为任何三位数。所以数字，数字，数字。个位，十位，百位。但这里有一些数学运算，并不特别复杂。那些实际上是 10 的幂。所以 10 的 0 次方，10 的 1 次方，10 的 2 次方，这就是你的十进制系统。因为在这个值中，基数是 10，这是因为每个占位符都有 10 种可能性，从 0 到 9。

But in the binary world, in the world of computers where all they have are zeros and ones, why? Because all they have physically is transistors. Tiny, tiny, tiny light bulbs that can be off or on. If you only have two digits to play with, the 10 base should, of course, become a two base. And now if we do some math here, 2 to the 0, 2 to the 1, and 2 to the 2, you get the ones column, the twos column, the fours column. And if we keep going 8, 16, 32, 64, 128 and so forth, its powers of 2 instead of powers of 10. 
但在二进制世界中，在计算机的世界里，它们只有 0 和 1，为什么？因为它们在物理上只有晶体管。微小的、微小的、微小的灯泡，可以是关着的或者开着的。如果你只有两个数字可以玩，10 进制当然就变成了 2 进制。现在如果我们在这里做一些数学运算，2 的 0 次方，2 的 1 次方，2 的 2 次方，你得到个位、十位、百位。如果我们继续这样下去，8、16、32、64、128 等等，这些都是 2 的幂而不是 10 的幂。

But this is to say computers represent information in exactly the same way you and I have since childhood, but they have fewer digits at their disposal, so these columns need to be weighted differently. So we can still count from zero all the way up toward infinity. So what does this mean? Well, here we have three bits on the screen, 000. If we were to convert this now mentally or on paper pencil to decimal, how do we do it? Well, 4 times 0 plus 2 times 0 plus 1 times 0. 
但这是说，计算机表示信息的方式与我们自幼以来一样，但它们可用的数字更少，所以这些列需要以不同的方式加权。这样我们仍然可以从 0 一直数到无穷大。那么这意味着什么呢？这里屏幕上有三个比特，000。如果我们现在在心中或者用纸笔将其转换为十进制，我们怎么转换呢？嗯，4 乘以 0 加上 2 乘以 0 加上 1 乘以 0。

That gives us the mathematical number you and I know as zero. That was three light bulbs. Off, off, off. Well, what if we turn on one light bulb all the way on the right? What decimal number does this binary number, 001 represent? Just one, because it's 4 times 0, 2 times 0, 1 times 1. Here's where things got more interesting, even if non-obvious in light bulb form or even physical hand form. 010 in binary is what in decimal? Two, because it's 2 times 1 and that's it. 011 in binary is, of course now three. 
这就给我们带来了数学上的数字，也就是我们知道的零。那是三个灯泡。关掉，关掉，关掉。那么，如果我们把最右边的灯泡完全打开会怎样呢？这个二进制数 001 代表的是哪个十进制数？就是一，因为它是 4 乘以 0，2 乘以 0，1 乘以 1。这里事情变得更有趣了，即使以灯泡的形式或者甚至是物理的手势形式，也并不明显。二进制的 010 是十进制中的什么？是二，因为它是 2 乘以 1，就这么多。二进制的 011 当然是三。

This is now four. This is now five. This is now six and seven. On, on, on or 111 is the highest we can count with these three bits. All right. So how might a computer intuitively count as high as eight? What do you need to do, presumably? You're going to need to add a bit. So you need another light bulb, another switch. You need more memory, so to speak, to use nomenclature with which you're probably familiar. 
现在是四。现在是五。现在是六和七。全开，全开，全开，或者说是 111，这是用这三个比特能数到的最大数。好吧。那么，一台计算机如何直观地数到八呢？你大概需要做什么？你需要增加一个比特。所以你需要另一个灯泡，另一个开关。换句话说，你需要更多的“内存”来使用你可能熟悉的术语。

So in fact, if we change all of those to zero but we give ourself one more bit for a total of four, that's got to be the eighth place because there's just another power of two. So 1000 is the decimal number eight. You don't say 1,000 in binary. You literally say 1000. But that is the number you and I know as eight. And you can keep going up and up and up. And how then computers with Excel or any kind of number crunching software count really high and keep track of really big numbers? 
事实上，如果我们把这些都变成零，但给自己多一个位，总共四个位，那应该是第八位，因为还有一个 2 的幂。所以 1000 是十进制数八。在二进制中你不会说 1,000，你直接说 1000。但这正是我们和你所知道的数字八。你可以一直往上数。那么电脑如何使用 Excel 或任何类型的数字处理软件来计数这么高，并跟踪这么大的数字呢？

The computer just throws more and more transistors at it, more and more bits to count higher and higher and higher than this. It turns out, though, one bit, three bits, even four bits aren't that useful in practice because literally you can count as high as seven or maybe 15 or 31. So more commonly, as is commonly known, is to use a byte of bits instead. How many bits is in a byte, for those familiar? So it's just eight. Why eight? It's just more useful than one or two or three or some other number. 
计算机只是不断增加更多的晶体管，更多的位来计数更高的数字。然而，一个位，三个位，甚至四个位在实践中并不那么有用，因为实际上你可以数到七，或者可能是十五或三十一。所以更常见的是，众所周知，使用一个字节来代替。对于那些熟悉的人来说，一个字节有多少位？所以是八个。为什么是八个？它比一、二、三或其他数字更有用。

And as an aside, it happens to be a power of two, which is just useful electronically as well. So a byte then is just 8 bits. And here are those columns I rattled off off the top of my head. Here is how a computer would represent zero in decimal, but using eight binary digits or bits. Little trivia. And again, this is not what computer science is about, but it helps to know the lower bounds and the upper bounds of these kinds of values. How high can you count with 8 bits or 1 byte if this is zero? 
顺便说一下，它恰好是 2 的幂，这在电子领域也很有用。所以一个字节就是 8 位。这里是我随口提到的那些列。这里是如何用 8 个二进制位或比特表示十进制中的零。一个小知识。再次强调，这并不是计算机科学的主要内容，但了解这些值的上下限是有帮助的。如果你用 8 位或 1 个字节计数，这个零能数到多高？

Yeah. So it's actually 255. So if I were to change all of these zeros to ones and then do some quick mental or calculator math, 128 plus 64 plus 32, 16, 8, 4, 2, and 1 would actually give me 255 total. Plus 0, which gives me 256 total possibilities. So this is only to say-- this is not, again, the kind of math will frequently do, but you'll commonly see in the computer world and programming world powers of two, numbers like 255, 256. 
是的。所以实际上是 255。如果我把这些零都换成 1，然后做一些简单的心理或计算器数学，128 加 64 加 32，16，8，4，2 和 1，实际上会得到 255 个总数。加上 0，总共 256 种可能性。所以这只是想说明——这并不是，再次强调，我们经常做的数学，但在计算机世界和编程世界中，你经常会看到 2 的幂，比如 255、256 这样的数字。

Why? Because these are the common units of measures that systems tend to use. So let me pause here and see, with respect to binary, zeros, and ones, transistors and the like, any questions or confusion we can clear up? Oh, really good question. Why are bits just on or off instead of maybe sort of 0%, 50%, 100% by playing with voltages? So the voltage inference of yours is actually correct. That's what computers typically do. 
为什么？因为这些是系统倾向于使用的常用度量单位。所以让我在这里暂停一下，看看，关于二进制、零和一、晶体管等，有没有什么问题或疑惑我们可以澄清的？哦，这是一个非常好的问题。为什么比特只是开或关，而不是通过调整电压来达到 0%，50%，100%呢？所以你提到的电压推断实际上是正确的。这就是计算机通常的做法。

Maybe they use 0-ish volts to represent 0, maybe 5-ish volts to represent 1. It turns out it's just really easy to do extremes in computers. If you start to split that range of voltage levels, for those who remember any of their electricity, it just gets harder and harder to be exact. And if you get things a little too murky, you might mistake a zero for a one or a two or a three. So it turns out it's just simpler to use the binary system. But there do exist computers known as ternary computers that actually use three values, zero, one, and two, which is somewhere, of course, between binary and decimal. 
可能它们使用 0 左右伏特来表示 0，5 左右伏特来表示 1。结果发现，在计算机中实现极端值非常简单。如果你开始分割电压等级的范围，对于那些还记得他们电学知识的人来说，这只会越来越难以精确。如果你弄得太模糊，你可能会把 0 误认为是 1、2 或 3。所以结果证明，使用二进制系统要简单得多。但确实存在一些称为三进制计算机的计算机，它们实际上使用三个值，即 0、1 和 2，这当然介于二进制和十进制之间。

But you can do different things. It's just simple on and off. In case in point, I don't want to really be dramatic and turn off my computer, but if I pulled out the power plug, that could be off, literally, a.k.a. zero. Plug it back in, that's a one. There's just a cleanliness and simplicity to that. Other questions or confusion that we can clear up? No? 
但是你可以做不同的事情。这很简单，只是开和关。以这个为例，我并不想真的戏剧性地关掉我的电脑，但如果我拔掉电源插头，那它就可以彻底关机，也就是零。再插回去，那就是一。这其中有种简洁和简单。还有其他问题或疑惑需要澄清吗？没有？

OK. So if you're in agreement for the moment that, OK, using just zeros and ones, we can represent any number we want from zero on up, let me propose that we do more useful things with our computers and our pockets and desktops and laps like represent letters, for the sake of Google Docs, Microsoft Word, or any kind of text that we might want to write. 
好的。所以如果你现在同意，使用仅仅零和一，我们可以表示从零开始的任何数字，让我提出一个想法，我们可以用我们的电脑和口袋、桌面和笔记本电脑做更有用的事情，比如表示字母，为了谷歌文档、微软文字或任何我们可能想要写的文本。

So knowing now that computers only contain or only use zeros and ones, and therefore only contain hardware like transistors, how could you represent something like a capital letter A in English inside of a computer? Which, of course, is not a number anymore. Like, what could we do? Yeah? 
现在我们知道电脑只包含或只使用零和一，因此只包含像晶体管这样的硬件，你如何在电脑里表示像英文大写字母 A 这样的东西呢？当然，这不再是数字了。比如，我们能做什么？是的？

AUDIENCE: We could use the alphabet and then use numbers. 
观众：我们可以用字母表，然后使用数字。

DAVID MALAN: OK, yeah. So we could take the alphabet A through Z in English and we could just assign each letter A number. And honestly, that is not only the correct answer, it's really the only answer. Because at the end of the day, if all you have are zeros and ones available to you, that is the entirety of the potential solution to this problem. So it turns out that, yes, capital letter A, some years ago, was decided by a bunch of people in a room shall be represented with this pattern of zeros and ones. 01000001. 
大卫·马尔安：好的，是的。所以我们可以将英语字母表中的 A 到 Z 分配给每个字母一个数字。说实话，这不仅是最正确的答案，也是最唯一的答案。因为最终，如果你只有零和一可用，那么这就是这个问题的全部潜在解决方案。所以，结果就是，是的，大写字母 A，几年前，由房间里的一群人决定，可以用这个零一的序列来表示。01000001。

And now, trained as you are to do a bit of quick binary math, what decimal number is used to represent apparently capital A? So 65, because that's 64 plus 1 plus 1 times 1 is 65. What is B? Turns out it's 66. What is C? 67. So they kept things simple there on out. Might have been nice if A were zero or maybe a were one. But nope, we're stuck with 65 instead. But everything after that is very much predictable. 
现在，你已经训练有素，能够快速进行二进制数学运算，那么用来表示大写字母 A 的十进制数是多少？所以是 65，因为那是 64 加上 1 加上 1 乘以 1 等于 65。B 是多少？结果是 66。C 是多少？67。所以从那时起，他们一直保持简单。如果 A 是零或者 a 是一，那就好了。但是没有，我们只能接受 65。但是从那时起，一切都非常可预测。

And in fact, for lowercase letters, there's a whole other set of numbers such as lowercase A happens to be 97, lowercase B happens to be 98, and so forth. But again, this is like CS trivia. But what's important here is that there are indeed contiguous from 65 to 66 to 67 on up. That's something we're going to be able to leverage beyond the letter A alone. What is this system? What is this mapping that you yourself propose? It's ASCII, the American Standard Code for Information Interchange. 
事实上，对于小写字母，还有一个完整的数字集合，例如小写字母 A 对应的是 97，小写字母 B 对应的是 98，以此类推。但同样，这就像计算机科学 trivia。但重要的是，它们确实从 65 到 66 到 67 连续。这是我们能够利用的，而不仅仅是字母 A 本身。这个系统是什么？你提出的这种映射是什么？它是 ASCII，即美国信息交换标准代码。

And indeed, it was a bunch of Americans years ago who came up with this system. Unfortunately, at the time, they only allocated 7 and eventually 8 bits total for representing letters, both uppercase and lowercase, numbers on the keyboard as well, punctuation symbols as well. And so per our conversation a moment ago, if the Americans in this room, so to speak, only used 8 bits total, how many different characters can we represent with a computer in this story? 
事实上，是多年前的一群美国人提出了这个系统。不幸的是，当时他们只为表示字母（大写和小写）、键盘上的数字以及标点符号分配了总共 7 位，后来增加到 8 位。根据我们刚才的讨论，如果在这个房间里，所谓的美国人只使用了总共 8 位，那么我们在这个故事中可以用计算机表示多少个不同的字符？

So only 255, technically 256 if we, again, start counting from zero. So that's not nearly enough to represent all human languages, but it is enough to represent at least English, among some others. So here, for instance, is a chart of the ASCII mapping. And sure enough, if we zoom in on this column here, 65 is capital A, 66 is capital B, dot, dot, dot 72 is H, 73 is I, and so forth. So there is a standardized mapping for at least all of these English letters. 
所以只有 255 个，技术上说是 256 个，如果我们再次从零开始计数。所以这远远不够表示所有的人类语言，但至少可以表示英语和其他一些语言。所以这里，例如，是一个 ASCII 映射表。果不其然，如果我们放大这个列，65 是大写字母 A，66 是大写字母 B，等等，72 是 H，73 是 I，以此类推。所以至少对于这些英语字母有一个标准化的映射。

Well, suppose you were to receive an email or a text message or like a Google Doc containing this pattern of zeros and ones. So 01001000 and so forth and so forth. So 3 bytes worth. Three sets of 8 bits. That is to say 3 bytes, each of which represents a single letter in ASCII. What message have you received? Well, I'll do the math this time so we don't have to. Suppose what you really received was decimal 72, 73, 33. 
假设你收到了一封电子邮件或短信，或者像 Google 文档这样的包含这种零和一模式的文档。比如 01001000 等等。3 个字节的值。也就是说 3 个字节，每个字节代表 ASCII 中的一个字母。你收到了什么信息？这次我会做数学计算，这样我们就不必了。假设你真正收到的是十进制的 72，73，33。

What message did you just receive? If you recall the previous chart. Hi was in fact correct. Why? Because H is 72, I is 73. And wait a minute, 33. So here's H. Here's I. 33, if we highlight it instead, happens to be an exclamation point. So that is literally what is going on underneath the hood, so to speak, when you get a text message today that literally says in all caps and an exclamation point, HI! Your phone has received at least three bytes, each of which represents a letter of the alphabet. 
你刚才收到了什么信息？如果你还记得之前的图表，那么“Hi”实际上是正确的。为什么？因为 H 是 72，I 是 73。等等，33。所以这里就是 H，这里就是 I，33，如果我们把它突出显示，它恰好是一个感叹号。所以这就是当你今天收到一条实际上全部大写并且带有感叹号的消息时，在引擎盖下实际上发生的事情，也就是说，HI！你的手机至少接收了三个字节，每个字节代表字母表中的一个字母。

Your computer is quickly doing the mental math to figure out exactly what numbers those are and then looking up in the so-called ASCII chart in its memories, in some sense, what letter should you actually see on the screen there. And so if you were to then display that message, you would see it indeed in English as opposed to those numeric equivalents. How else might we use this then? 
你的电脑正在快速进行心理计算，以确定这些数字是什么，然后在它的内存中的所谓的 ASCII 表中查找，从某种意义上说，你应该在屏幕上看到什么字母。所以如果你显示这条消息，你确实会看到英文，而不是那些数字等效物。我们还能如何使用它呢？

Well, here again is that chart. And maybe just to vary things, maybe take a little pressure off of me here, why don't we try spelling something else? This time a different three letter word, but maybe eight volunteers. Could we get a bytes' worth of volunteers? And I can sweeten the deal with some stress balls in exchange. You just have to be comfortable coming up on stage and being on the internet. So yes. One, two. How about three, four. How about five, six, seven. And how about eight. Come on up. A round of applause for our volunteers. Yep. 
好吧，这里又是那张图表。也许为了改变一下气氛，也许可以稍微减轻一下我的压力，我们为什么不尝试拼写其他东西呢？这次是一个不同的三个字母的词，但也许需要八位志愿者。我们能召集到八位志愿者的支持吗？我可以用一些减压球来增加吸引力。你只需要在舞台上感到舒适，并在互联网上出现。所以，是的。一，二。那么三，四。五，六，七。那么八。请上来。为我们的志愿者鼓掌。是的。

[APPLAUSE]   [掌声]

All right. So what I'm going to have each of you do is represent a bit in a particular order. So if you want to just, in any order, line yourselves up here facing the audience. Come on over. All right. And we will have you represent-- well, we got to see who ends up where. Scooch this way a little bit. This way, this way. 
好的。所以我要让你们每个人按照特定的顺序代表一个片段。所以如果你们想随便，按任何顺序，站在这里面对观众。过来吧。好的。然后我们会让你们代表——我们要看看最后谁在哪个位置。往这边挪一点。这边，这边。

All right. So you shall be the ones place and just hold that in front of you. Twos place. Threes. Fours place. Eights place. 16, 32, 64, and 128. And just compress yourselves a little bit if you could. So each of these folks represents a bit in a particular place. And let's say this. If you're just standing there uncomfortably without any hand raise, we'll assume that you're representing a zero, quite simply. 
好的。所以你们将是这些位置的人，只需将它们放在你们面前。十位。百位。千位。万位。八位。16，32，64 和 128。如果可以的话，请稍微压缩一下自己。所以这些人都代表特定位置的一个位。让我们这么说。如果你只是不舒服地站在那里，没有举手，我们就会假设你代表一个零，很简单。

If your hand goes up, though, the audience should assume that you're representing a one. And therefore, what we'll do is spell out a three letter word, and on each round of this, you'll either stay, stay like this, or you'll raise your hand. But first, let's actually meet some of our volunteers here, starting with position number one, if you'd like to say your name, perhaps where you're from and/or studying. 
如果你的手举起来，那么观众应该认为你代表一。因此，我们将拼写一个三个字母的词，在每一轮中，你将保持不动，或者举起你的手。但首先，让我们真正认识一下我们这里的志愿者，从一号位置开始，如果你愿意，可以说出你的名字，也许是你来自哪里以及/或正在学习什么。

AUDIENCE: Hi. My name is Brooke. I'm from Indiana, and I'm studying biology and computer science. 
观众：嗨，我叫布鲁克。我来自印第安纳州，我正在学习生物学和计算机科学。

DAVID MALAN: Nice. Welcome. 
大卫·马兰：好。欢迎。

AUDIENCE: Hi, I'm Becca. I'm from, like, Maryland, DC area, and I'm studying electrical engineering. 
观众：嗨，我是贝卡。我来自马里兰州，DC 地区，我正在学习电气工程。

DAVID MALAN: Welcome.   大卫·马兰：欢迎。

AUDIENCE: Hi, I'm Addison. I'm from Maryland. I'm studying engineering. 
观众：嗨，我是艾迪森。我来自马里兰州。我正在学习工程。

AUDIENCE: Hi. I'm Sharon. I'm from Rwanda and I'm studying CS and math. 
观众：嗨。我是莎伦。我来自卢旺达，我正在学习计算机科学和数学。

DAVID MALAN: Welcome.   大卫·马兰：欢迎。

AUDIENCE: Hi, I'm Grace. I'm from Alabama and I'm studying electrical engineering. 
观众：嗨，我是 Grace。我来自阿拉巴马，正在学习电气工程。

DAVID MALAN: Welcome.   大卫·马兰：欢迎。

AUDIENCE: Hi, I'm Angelina. I'm from Maryland. And also, I stay in Matthews. 
观众：嗨，我是 Angelina。我来自马里兰州。而且，我住在马修斯。

DAVID MALAN: Nice. Matthews. Nice. 
大卫·马兰：好。马修斯。好。

[APPLAUSE]   [掌声]

AUDIENCE: And I'm studying applied math and econ, as well as environmental science and public policy. 
观众：我正在学习应用数学和经济学，以及环境科学和公共政策。

DAVID MALAN: Welcome.   大卫·马兰：欢迎。

AUDIENCE: I'm Owen Bells and I'm from rural Virginia and I'm studying CS. 
观众：我是欧文·贝尔斯，来自弗吉尼亚州的农村，我正在学习计算机科学。

DAVID MALAN: Nice, welcome. And? 
大卫·马尔安：好，欢迎。那么呢？

AUDIENCE: My name is Max. I'm from London. I'm also staying in Matthews and I'm studying computer science and neuroscience. Thank you. 
观众：我叫 Max，来自伦敦。我住在 Matthews，正在学习计算机科学和神经科学。谢谢。

DAVID MALAN: Welcome aboard as well. If you're wondering, too, why I was wearing these glasses at the start-- so very common on the internet nowadays as these POV videos. So it turns out these Ray-Bans actually record video footage, and we have a couple of them, and we'd thought we would offer them to a couple of volunteers. If anyone wants to record their point of view for everyone here. And Vlad here is going to help make sure they're recording. Second volunteer. Yes, number two. 
大卫·马尔安：欢迎加入我们。如果你也想知道，为什么我开始时戴着这些眼镜——现在在互联网上非常常见，因为这些 POV 视频。结果是这些雷朋眼镜实际上可以录制视频，我们有一些，我们想提供给几位志愿者。如果有人想记录他们的视角供大家观看。Vlad 在这里将确保他们能够录制。第二位志愿者。是的，第二位。

All right. So as Vlad gets those set, on the backs of your pieces of paper you have instructions for the following three rounds. Each round represents a letter. The audience participation part of this is to actually do the mental math to figure out what number these volunteers are representing. So go ahead and execute round one, either keeping your hand down or raising it appropriately. OK. What number are our volunteers here representing? 
好的。所以当 Vlad 准备这些的时候，在你们的纸张背面有接下来三轮的指示。每一轮代表一个字母。观众参与的环节是实际上进行心理计算，以确定这些志愿者代表的是哪个数字。所以请进行第一轮，要么把手放下，要么适当地举起。好的。我们的志愿者在这里代表的是哪个数字？

AUDIENCE: 66.   观众：66。

DAVID MALAN: 66, because we have a 64 plus a 2. That then maps to what ASCII letter? 
大卫·马兰：66，因为我们有一个 64 加上一个 2。那么它对应哪个 ASCII 字母？

AUDIENCE: B.   观众：B。

DAVID MALAN: B was the first letter. OK, hands down. Round two, go. A little harder. What's now being represented? 
大卫·马兰：B 是第一个字母。好吧，毫无疑问。第二轮，开始。现在代表的是什么？

AUDIENCE: 79.   观众：79。

DAVID MALAN: I'm starting to hear it. 79 is in fact correct. 79, because we have a 64 and an 8 and 4 and 2 and a 1. So if it's a 79, we have the ASCII letter O. So we've got BO, and then lastly, third round. Go. We have 01010111. What number is this? 
大卫·马兰：我开始听到了。79 确实是正确的。79，因为我们有一个 64 和一个 8，还有一个 4，一个 2 和一个 1。所以如果它是 79，我们就有了 ASCII 字母 O。所以我们有了 BO，然后最后，第三轮。开始。我们有 01010111。这是哪个数字？

AUDIENCE: 87.   观众：87。

DAVID MALAN: 87. Which spells the letter? 
大卫·马兰：87。这代表哪个字母？

AUDIENCE: W.   观众：W。

DAVID MALAN: W. Which spells the word? 
大卫·马尔安：W。这个词怎么拼写？

AUDIENCE: Bow.   观众：鞠躬。

DAVID MALAN: Not bow. Take a bow if you could. All right. A round of applause for our volunteers here. 
大卫·马尔安：不是鞠躬。如果你能的话，请鞠躬。好吧。为我们的志愿者鼓掌。

[APPLAUSE]   [掌声]

And come on off this way and help yourself to a CS50 stress ball. Thank you to our volunteers. So this is only to say we've now agreed on how we can represent numbers from zero on up. We've agreed on how we can represent letters. But at least letters using ASCII, and in fact, these are more than just decoration. In fact, it's a little bit of trivia by lecture's end. If you to come up for your very own CS50 stress ball, turns out there are 64 light bulbs at the foot of the stage here. 
欢迎过来拿一个 CS50 压力球。感谢我们的志愿者。所以这只是想说明我们现在已经达成一致，关于如何表示从零开始的数字。我们已经达成一致，关于如何表示字母。但至少是使用 ASCII 码的字母，实际上，这些不仅仅是装饰。实际上，到课程结束时，这会变成一个小趣闻。如果你来拿你自己的 CS50 压力球，结果发现这里舞台底部有 64 个灯泡。

If you break them down into 8 byte or single-- 8 bit or single byte chunks, there's an eight letter word that happens to be spelled out today using this here ASCII chart. So today's mystery is what exactly is that there word. But of course, if you have only 8 bits, you can only represent, like, 256 characters, which sounds like plenty for English, and indeed, it is. Zero through nine, A through B, capital and lowercase, uppercase and lowercase, as well as punctuation. 
如果您将它们分解为 8 字节或单个--8 位或单个字节块，那么今天恰好使用这个 ASCII 图表拼写出了一个 8 个字母的单词。所以今天的谜题就是那究竟是什么单词。当然，如果您只有 8 位，您只能表示大约 256 个字符，这听起来对英语来说足够多了，实际上也是如此。从零到九，从 A 到 B，大写和小写，以及标点符号。

But there's so many other human languages in the world that have other characters. For instance, we have not just the English alphabet we might see here on a US English keyboard. We have accented characters, we have various Asian languages have even many more glyphs. We need more than 256 possible characters. And so nowadays computers do not just use 7 or even 8 bits. They might use 8 bits for some letters, like all of the English letters. 
但是世界上有那么多使用其他字符的人类语言。例如，我们不仅仅有在这里的美国英语键盘上可能看到的英语字母表。我们有带重音的字符，还有各种亚洲语言，甚至有更多的符号。我们需要超过 256 个可能的字符。因此，如今计算机不仅仅使用 7 位或甚至 8 位。它们可能为某些字母使用 8 位，比如所有的英语字母。

They might use 16 bits for certain other languages. Maybe even 24 or 32 bits. And fun fact, if you have 32 bits-- and we have more than that on the stage. If you've got 32 bits, you can actually represent as many as 4 billion possible characters, which is quite a bit. No pun intended. So what else can we represent? Well, the goal of this system, not just ASCII, but something known as Unicode, which is a newer standard, is to be backwards compatible with ASCII. 
它们可能为某些其他语言使用 16 位，甚至 24 位或 32 位。有趣的事实是，如果你有 32 位——而且我们舞台上的位数比这还多。如果你有 32 位，你实际上可以表示多达 40 亿个可能的字符，这相当多。不是字面上的意思。那么我们还能表示什么？嗯，这个系统的目标，不仅仅是 ASCII，还有一种称为 Unicode 的新标准，它的目标是与 ASCII 向后兼容。

So humans left all of those other numbers alone, 65, 66, 67 and so forth, but they added to it a super set of representations that maybe are 16, 24, or 32 bits. The goal being to be able digitally to represent all human languages, past, present, and future, and even through pictograms, things like smiley faces and the like, even people, places, things and emotions that transcend human language. 
所以人类让所有其他的数字保持原样，65、66、67 等等，但他们添加了一个超集的表示，可能是 16 位、24 位或 32 位。目标是在数字上能够代表过去、现在和未来的所有人类语言，甚至通过象形文字，比如笑脸符号等，甚至超越人类语言的人、地点、事物和情感。

And in fact, odds are within the past few minutes or hours, most of you have used one or more of these here emoji, these pictograms, which it turns out are just characters on a keyboard. You might have to hit a special button to pull up that form of the keyboard, but these are just here characters. And so these emoji have exploded in popularity for a number of reasons, one of which is, my God, what are we going to do with 4 billion possible patterns of zeros and ones? 
事实上，在过去的几分钟或几小时内，你们大多数人可能已经使用了一个或多个这些表情符号，这些象形文字，它们实际上只是键盘上的字符。你可能需要按一个特殊的按钮来调出这种键盘形式，但这些只是字符。因此，这些表情符号因其众多原因而迅速流行起来，其中之一就是，天哪，我们该如何处理 4 亿种可能的零和一的组合呢？

We can start to have some fun with it and represent things beyond English and human languages alone. Now, as an aside, when it comes to Unicode, it turns out Unicode, years ago, standardized this pattern of 32 zeros and ones to represent just one of those emoji. So emoji tend to use even more bits here. Anyone know what decimal number this is? This is not a fun mathematical exercise. The spoiler is 4,036,991,106 is the decimal number that actually represents, as of present, the most popular emoji in the world. Does anyone want to hazard a guess what emoji this here number represents? 
我们可以开始玩一些有趣的事情，用它来表示超越英语和人类语言的事物。现在，顺便说一下，Unicode 多年前就标准化了这个 32 个零和一的图案，用来表示其中的一个表情符号。所以表情符号在这里使用的位数更多。有人知道这个十进制数是多少吗？这可不是一项有趣的数学练习。剧透一下，目前世界上最受欢迎的表情符号的十进制数实际上是 4036991106。有人敢猜这个数字代表的是哪个表情符号吗？

AUDIENCE: Heart.   观众：心形。

DAVID MALAN: Heart? Hearts? No, but it's actually this so-called face with tears of joy. So perhaps think about the frequency with which you send that one. And even though it's obviously a picture on the screen, sure, it actually is more like a font, because underneath the hood, it's indeed just a pattern of zeros and ones or a decimal number that the computer is storing. But the computer, be it Mac OS or Windows or iOS or Android, know to display that pattern as this here picture. 
大卫·马尔安：心形？心形？不，实际上是这个所谓的“泪流满面的脸”。所以也许你可以想想你发送这个表情的频率。尽管屏幕上显然是一个图片，没错，它实际上更像是一种字体，因为在其底层，它实际上只是一个零和一的图案，或者是一个计算机存储的十进制数。但无论是 Mac OS、Windows、iOS 还是 Android，它们都知道如何将这个图案显示成这里的图片。

But the pictures might look different depending on the hardware. Why? Because there's companies like Google and Microsoft and Meta and others that have their own artists on staff as employees, and those artists interpret the descriptions like face with tears of joy differently. So those of you with an Android phone actually see face with tears of joy looking a little something like this. 
但图片可能因硬件不同而有所差异。为什么？因为像谷歌、微软、Meta 这样的公司都有自己的艺术家员工，这些艺术家对“面带笑容”等描述有不同的解读。所以，那些使用安卓手机的人实际上看到的“面带笑容”可能看起来像这样。

And if you have Telegram, for instance, installed on your phone, it's even more animated than that. It's this here emoji using the same pattern of zeros and ones. So different artists render these here emoji in different ways, but all they are here are patterns. Now, for all of the other answers, save one that was shouted out a moment ago, this is a sort of cloud diagram of the most popular emoji as of a couple of years ago per Unicode, whereby the size of the emoji indicates its relative popularity. So heart, I did here over here, is indeed one of the most popular ones as well. Question? 
例如，如果你在手机上安装了 Telegram，它甚至比这更生动。这里使用的同样是零和一的图案。所以不同的艺术家以不同的方式绘制这些表情符号，但它们在这里都是模式。至于其他所有答案，除了刚才喊出的那个，这是一个基于 Unicode 的云图，显示了几年前的最受欢迎的表情符号，其中表情符号的大小表示其相对流行度。所以，这里的心形确实是最受欢迎的之一。有问题吗？

AUDIENCE: Why do certain emojis show up [INAUDIBLE]? 
观众：为什么某些表情符号会显示出来[听不清]？

DAVID MALAN: Oh, really good question. Why do certain emoji not show up on one device or another? It depends on how recent the software is. Pretty much every year the humans behind the Unicode consortium release new emoji. Which is to say they decide that this other pattern will represent this new emoji, this other pattern will represent this new emoji. 
大卫·马兰：哦，这是一个很好的问题。为什么某些表情符号在某些设备上无法显示？这取决于软件的更新程度。几乎每年，Unicode 联盟背后的人类都会发布新的表情符号。也就是说，他们决定这个图案代表这个新的表情符号，那个图案代表那个新的表情符号。

And unless you update your phone, your laptop, your desktop to the very latest software and the manufacturer of that device or software also updates by hiring an artist to draw those pictures in their own fonts, in their own style, you're going to see usually just an empty black square or maybe just a black and white heart instead of something more colorful. Really just placeholders, because, it's as though you don't have the right font installed or really, you have an older version of that same font installed. But it's become sort of an annual tradition that new and more emoji are released every year, which is among the reasons why these updates contain more and more. Yeah? 
除非您将您的手机、笔记本电脑、台式机更新到最新的软件，并且该设备的制造商或软件提供商也通过雇佣艺术家绘制他们自己的字体、他们自己的风格来更新，否则您通常会看到一个空白的黑色方块，或者只是一个黑白心形，而不是更丰富多彩的东西。实际上只是占位符，因为，好像您没有安装正确的字体，或者实际上您安装的是该字体的旧版本。但每年发布新的和更多的表情符号已经成为一种年度传统，这也是为什么这些更新包含越来越多的内容之一。是吗？

AUDIENCE: How do you represent color in bytes? 
观众：如何在字节中表示颜色？

DAVID MALAN: That is an amazing segue. How do you represent color in bytes? Well, you use RGB, which happens to be, by coincidence, the next slide. So let's again, recap. We know how to represent letters. We know how to represent numbers. We can even represent emoji. But those emoji technically on the screen are, of course, composed of colors, like a whole bunch of yellow for that there smiley face? How do computers, then, using only zeros and ones, represent colors? 
大卫·马尔安：这是一个令人惊叹的过渡。如何在字节中表示颜色？嗯，你使用 RGB，碰巧这也是下一张幻灯片。所以，让我们再次回顾一下。我们知道如何表示字母，我们知道如何表示数字，我们甚至可以表示表情符号。但那些屏幕上的表情符号实际上是由颜色组成的，比如那个笑脸是由一大堆黄色组成的？那么，计算机是如何仅使用零和一来表示颜色的呢？

Well, by convention, they typically use a system that, by an acronym, is called RGB. Red, green, blue. And this is to say that a computer, to represent a single dot on the screen-- maybe this one, this one, this one-- will allocate some number of bits or some number of bytes to represent the color of just that, their dot, otherwise known as a pixel. You can actually see pixels on your phone or even on your TV or monitor. If you go really close, especially if it's an older monitor, you can see the tiny little squares. 
按照惯例，它们通常使用一个被称为 RGB 的缩写系统。红色、绿色、蓝色。这意味着计算机为了在屏幕上表示一个单独的点——比如这个、这个、这个——会分配一定数量的位或字节来表示这个点的颜色，也就是像素。你实际上可以在你的手机上，甚至在你的电视或显示器上看到像素。如果你真的靠近看，尤其是如果它是一个老式的显示器，你可以看到那些小小的方块。

Each of those has some number of bits telling the device what color to use. In particular, these devices typically use three numbers in total, three bytes. So that is to say 24 bits per pixel. And they do this. If you were to represent a single dot on the screen using these three numbers, just by intent here, this is 72, 73, 33, which in the context of a text message, an email, a Google Doc represents, of course, hi, textually. 
每个这样的都有一些比特数告诉设备使用什么颜色。特别是，这些设备通常总共使用三个数字，三个字节。也就是说，每个像素 24 位。他们就是这样做的。如果你用这三个数字来表示屏幕上的一个点，仅从意图上讲，这是 72、73、33，在文本消息、电子邮件、Google 文档的上下文中，当然代表的是文本上的“hi”。

What if a computer uses that same pattern of zeros and ones, that is the same pattern of decimal digits, to represent the color on a screen? Which is germane if you're opening an image using Photoshop. So using a different piece of software that knows about colors and images and not just text. Well, this would imply that you want that dot on the screen to have a medium amount of red, a medium amount of green, and a little bit of blue. Why do I say medium and little? 
如果计算机使用相同的零和一的模式，即相同的十进制数字模式，在屏幕上表示颜色呢？如果你在 Photoshop 中打开图像时，这是相关的。所以使用另一款了解颜色和图像的软件，而不仅仅是文本。这会意味着你想要屏幕上的点有中等程度的红色、中等程度的绿色和一点蓝色。我为什么说中等和一点？

Well, again, if each of these numbers is using 8 bits or 1 byte, the highest we can count, as we discovered, was 255. So I'm kind of averaging here. So 72 at a 255 feels to me like a medium amount of red. 33 feels relatively little blue. But if now the computer combines those wavelengths of light, so to speak, a medium amount of red, medium amount of green, a little bit of blue, what you get is the color code for a single dot. And does anyone want to guess what color roughly this represents, these three bytes? 
嗯，再次强调，如果这些数字都使用 8 位或 1 字节，那么我们能数到的最大值，正如我们发现的，是 255。所以我在这里做了一些平均。所以 72 在 255 中对我来说就像是一个中等程度的红色。33 感觉相对较少的蓝色。但如果现在计算机将这些光波组合起来，也就是说，中等程度的红色，中等程度的绿色，一点蓝色，那么你得到的就是单个点的颜色代码。那么，有人能猜出这三种字节的颜色大约是什么吗？

AUDIENCE: White.   观众：白色。

AUDIENCE: Purple.   观众：紫色。

DAVID MALAN: Not white, not purple. 
大卫·马兰：不是白色，也不是紫色。

AUDIENCE: Brown.   观众：棕色。

DAVID MALAN: Not brown. 
大卫·马尔安：不是棕色。

AUDIENCE: Yellow.   观众：黄色。

DAVID MALAN: Yellow, in fact, is the answer. So it represents in a single pixel roughly this shade here of yellow. Which is to say, if we look back at any of those emoji, which, again, are represented by patterns of zeros and ones, but you and I as humans perceive them as images on the screen-- let me actually go ahead and zoom and zoom in further to one such sample emoji. And when you zoom in far enough or you put the phone close enough to your face, you can actually see all of those little dots known as pixels, all of the little squares. 
大卫·马尔安：实际上，黄色是答案。也就是说，如果我们回顾那些表情符号，它们再次是由零和一的模式表示，但你我作为人类，将它们感知为屏幕上的图像——让我实际放大并进一步放大这样一个表情符号样本。当你放大足够远或者将手机贴近脸部时，你实际上可以看到所有那些被称为像素的小点，所有那些小方块。

And given that so many of these pixels are yellow, that is to say that that pattern of three bytes, 72, 73, 33, is used to represent this pixel. Another 3 identical bytes are used to represent this pixel, this one, this one, and so forth. So now if you've taken digital photos on your phone or a camera, you're probably generally familiar from the internet and hardware today that a photograph is, what, 1 megabyte, 10 megabytes depending on the resolution of it? 
由于这些像素中有许多是黄色的，也就是说，这个由三个字节组成的模式，72，73，33，被用来表示这个像素。还有另外 3 个相同的字节被用来表示这个像素，这个，这个，以此类推。所以现在，如果你用手机或相机拍摄了数码照片，你很可能从互联网和现在的硬件中普遍了解到，照片的大小是 1 兆字节，10 兆字节，这取决于它的分辨率？

Well, megabyte means millions of bytes. Where are all of these bytes inside of these photographs or these images you're taking or downloading? They correspond to every one of the single pixels on the screen. There's at least three bytes being used to represent every one of those dots. As an aside, bit of a white lie because nowadays there's fancy compression software that can use fewer than that many bytes. But in general, that's where all of those bytes, those millions of bytes are coming from. 
好吧，兆字节意味着百万字节。这些字节都存储在您拍摄的或下载的照片或图像中吗？它们对应于屏幕上的每一个单独的像素。至少有三个字节被用来表示每一个点。顺便说一句，这有点像是个小谎言，因为现在有高级的压缩软件可以使用少于这些字节的字节。但一般来说，所有这些字节，数百万字节都来自这里。

So how is that for an answer to how do we represent colors? Thank you. So if we agreed now that there's this way and perhaps others to represent colors, well, how do we represent not just images, but videos? Well, videos once upon a time, or movies, were called motion pictures. So motion pictures with motion. Why is that? Well, it's analogous to growing up. If you ever played with one of these picture books-- and in fact, there's memes nowadays that have made these popular again, whereby why you have a whole bunch of images on individual sheets of paper. 
那么，这如何回答我们如何表示颜色的疑问呢？谢谢。如果我们现在同意有这种表示颜色的方法，也许还有其他方法，那么，我们如何表示不仅仅是图像，还有视频呢？曾经，视频或电影被称为“活动影像”。所以，活动影像，有运动。为什么叫这个名字呢？因为它与成长相似。如果你曾经玩过这种图画书——实际上，现在有一些流行的梗让这些图画书再次流行起来，为什么会有很多图片印在单独的纸张上。

And if you flip through them fast enough, your human mind and eyes perceive it as actual motion, even though you're just seeing image, image, image, image, image, image. But it's so fast, it looks like motion. That's all a video is on your screen. That's all a film is on your TV. It is not in fact, continuous motion. It's maybe 30 frames or images per second, maybe 24 frames or images per second. Which is to say, we know how to represent numbers, we know how to represent letters, we know how to represent colors and thus images. 
如果你快速翻动它们，你的大脑和眼睛会把它感知为真正的运动，尽管你只是看到了图像，图像，图像，图像，图像，图像。但是因为翻动得很快，所以看起来像是运动。这就是屏幕上的视频，这就是电视上的电影。实际上，它并不是连续的运动。它可能是每秒 30 帧或图像，也可能是每秒 24 帧或图像。也就是说，我们知道如何表示数字，我们知道如何表示字母，我们知道如何表示颜色和图像。

Now we kind of get videos for free because it's just more of the same. Use more and more of those patterns. Why are videos so darn large? Why are they gigabytes to download, billions of bytes? Because there's so many darn images. 30 some odd images per second in those kinds of videos. And maybe lastly, just to top off our multimedia, how could you represent sound? Maybe musicians in the room. How, using only zeros and ones, could you represent something as sonorous as music? Something analog as digital. Yeah? 
现在我们几乎可以免费获得视频，因为它们只是更多类似的内容。使用越来越多的这些模式。视频为什么这么庞大？为什么下载下来是几吉字节，数十亿字节？因为里面有很多图像。每秒大约有 30 多个这样的图像。最后，为了丰富我们的多媒体，我们如何表示声音？也许房间里有一些音乐家。如何只用零和一，来表示如此悦耳的音乐？将模拟的转化为数字的。是吗？

AUDIENCE: So each number corresponds to a frequency. 
观众：所以每个数字对应一个频率。

DAVID MALAN: Yeah. So each number that we store in the computer could correspond to a certain frequency, which has a direct relationship to the sound or the pitch of a note. For instance, in the world of piano and many other instruments, you've got like your A, your B, your C, maybe you have sharps and flats as well. We could just agree, like the ASCII people did years ago, to represent the musical note A, let's use this pattern, musical note A-sharp, let's use this pattern and so forth. 
大卫·马兰：是的。所以我们在电脑中存储的每个数字都可以对应一个特定的频率，它与声音或音符的音高有直接关系。例如，在钢琴和许多其他乐器的世界中，你有像 A、B、C 这样的音符，也许你还有升调和降调。我们可以像多年前 ASCII 那样达成一致，用这个模式来表示音乐中的音符 A，让我们用这个模式来表示音乐中的音符 A#，以此类推。

But maybe pitch alone or frequency alone is not enough. Maybe we need that number, but maybe a second number for the volume, the sort of digital equivalent of how hard are you hitting the key on the piano. Maybe a third number for how long are you holding the key down. So maybe the pitch and the volume and the duration, kind of like RGB, we could use three bytes to represent every musical note in some piece. 
但也许单独的音高或频率还不够。也许我们需要那个数字，也许还需要第二个数字来表示音量，就像数字上钢琴键的力度。也许还需要第三个数字来表示按键的持续时间。所以，音高、音量和持续时间，就像 RGB 一样，我们可以用三个字节来表示某个乐章中的每一个音符。

And if we wanted to keep track of what instrument should be played by the computer to sound that music, well, maybe that's just a fourth byte or something else as well. Which is to say, at the end of the day, all we have are these zeros and ones to throw at the problem. So for now, that's it for representing information. We've got our numbers, we've got our letters, we've got our colors and images, our videos, and now sound. Any questions on how computers, then, are representing, as promised, those inputs and outputs using just zeros and ones? Yeah, in the middle. 
如果我们想要记录计算机应该演奏哪种乐器来发出那首音乐，也许那只是一个第四个字节或者别的什么。也就是说，最终我们面对的只是这些零和一。所以，现在关于表示信息就到这里。我们有了数字，有了字母，有了颜色和图像，有了视频，现在也有了声音。关于计算机如何使用零和一来表示输入和输出，有什么问题吗？嗯，就在中间。

AUDIENCE: The computer is taking it as input. 
观众：计算机正在将其作为输入。

DAVID MALAN: Correct. So the computer is taking as input at the end of the day, zeros and ones and is outputting zeros and ones. However, as we'll learn in this class, by writing software, by writing code that understands those zeros and ones we will enjoy not just literally seeing zeros and ones, we will see A, B, C, we will see colors, we will see video, we will hear sounds so long as we write the code to interpret those zeros and ones. 
大卫·马尔安：正确。所以最终计算机以零和一作为输入，输出也是零和一。然而，正如我们将在本课程中学到的，通过编写软件，通过编写理解这些零和一的代码，我们不仅能够看到零和一，我们还能看到 A、B、C，我们能看到颜色，我们能看到视频，我们能看到声音，只要我们编写代码来解释这些零和一。

And indeed, it's worth noting now that same pattern I keep using for an example, 72, 73, 33, how does a computer know? Is that the message hi? Is that the color yellow? Is it a dot in a video alone? Just depends on the context. Simply put, if you're opening that pattern of zeros and ones with Excel or a calculator program, odds are the software will interpret those three bytes as numbers, of course. If, though, you open that same pattern in a text messaging program, Google Docs, Microsoft Word, that same pattern will be interpreted as a sequence of letters. 
事实上，现在值得指出的是，我一直在用的同一个例子模式，72、73、33，计算机是如何知道的？这是消息“hi”吗？这是颜色黄色吗？这是一个视频中的点吗？这完全取决于上下文。简单来说，如果你用 Excel 或计算器程序打开这个零和一的模式，软件很可能会将这些三个字节解释为数字。然而，如果你在短信程序、Google Docs 或 Microsoft Word 中打开相同的模式，那么相同的模式将被解释为一系列字母。

Instead, if you open Photoshop, that same pattern, you'll probably see a single dot that happens to be yellow. Conversely, once you yourself are a programmer or even better programmer, you will be able to write in code how you want the computer to treat these patterns of zeros and ones. You can essentially tell the computer, use this to store a number or a letter or a color or something else. That's the power the programmer themselves have at the end of the day. Other questions on representing things with bits? No? 
取而代之，如果你打开 Photoshop，同样的图案，你可能会看到一个黄色的单独的点。相反，一旦你自己成为程序员，甚至更好的程序员，你将能够用代码来编写你想要计算机如何处理这些零和一的模式的指令。你实际上可以告诉计算机，用这个来存储数字或字母、颜色或其他东西。这就是程序员最终拥有的力量。关于用位表示事物的问题还有其他问题吗？没有？

All right. So lastly, then, in this middle of this black box, so to speak, is the sort of secret sauce that solves problems, that converts those inputs to outputs, those problems to solutions. So what is an algorithm? It's really just step by step instructions for solving some problem. And indeed, I think back to my own first time in CS50 where we learned the same from Professor Brian Kernighan. And as luck would have it, just had my 25th reunion where we pulled some video footage from 1996. 
好吧。最后，在这个所谓的黑盒子的中间，是那种解决问题的“秘密配方”，它将输入转换为输出，将问题转换为解决方案。那么什么是算法呢？它实际上只是解决问题的逐步指令。确实，我想起了我在 CS50 的第一堂课，我们从教授 Brian Kernighan 那里学到了同样的东西。而且，幸运的是，我刚刚参加了 25 周年聚会，我们从 1996 年的视频中找到了一些片段。

And so we're actually fortunate to have the very first few minutes of CS50 over 25 years ago when I myself took it. But the lessons back then, as today, are fundamentally the same. And what's important, indeed, is to not only express yourself correctly, but precisely, as we'll explore today. This then is Professor Brian Kernighan, who, years ago, very memorably introduced us and my classmates to algorithms by actually, in class, shaving his beard. If we could dim the lights here for Brian. 
事实上，我们很幸运能在 25 年前亲身体验 CS50 课程的第一几分钟。那时的课程，正如今天，其本质是相同的。重要的是，不仅要正确表达自己，还要精确，这正是我们今天要探讨的。这就是教授布莱恩·克恩 ighan，多年前，他通过在课堂上刮胡子，非常难忘地向我们和他的同学们介绍了算法。如果我们能将灯光调暗，为布莱恩照明。

[VIDEO PLAYBACK]   [视频播放]

- The other thing that we're going to talk about in this class is the notion of an algorithm. An algorithm is a very precise description of how to do something. And the operative word there is precise. It has to be very, very, very, very precise. And the task that I'm going to do is that I'm going to trim my beard, which has gotten out of whack. 
在本节课中，我们还将讨论算法的概念。算法是对如何做某事的非常精确的描述。那里的关键词是精确。它必须非常、非常、非常、非常精确。我将要做的任务是修剪我的胡子，因为我的胡子已经乱糟糟的。

[APPLAUSE]   [掌声]

And I brought a variety of things which one might use to trim beards with. 
我带来了各种可以用来修剪胡子的东西。

[LAUGHTER]   [笑声]

[APPLAUSE]   [掌声]

[END PLAYBACK]   [播放结束]

DAVID MALAN: So suffice it to say, I don't have much of a beard. But I do have this here other technology known once upon a time as a phone book. And these phone books, of course, have lots of information in them. Happen to be storing numbers and letters in particular. For those unfamiliar, they are storing human's names from A to Z here in English and associated with everyone's name is a number. So even if you've never had occasion to physically use this kind of device, turns out it's pretty much equivalent to the contacts or the address book app on your iOS phone or your Android phone as well. 
大卫·马兰：这么说吧，我几乎没有胡子。但我这里有一项曾经被称为电话簿的技术。当然，这些电话簿里有很多信息。特别是存储数字和字母。对于那些不熟悉的人来说，它们在这里以英语从 A 到 Z 存储人的名字，并且每个人的名字都附有一个号码。所以即使你从未有机会实际使用这种设备，结果证明它几乎等同于你 iOS 手机或 Android 手机上的联系人或地址簿应用。

Why? Because if you pull up your contacts, of course, you see some familiar names here alphabetized by first name or last name. And if you click on any of those names, you reach the person you're presumably trying to call or text. Pictured here then is John Harvard's, whose number here is plus 1-949-468-2750, which you're welcome to call or text at your leisure. But here is John Harvard that's partway through the phone book digitally. 
为什么？因为当你打开你的联系人时，当然，你会看到一些熟悉的名字在这里按名字或姓氏字母排序。如果你点击任何一个名字，你就会联系到你可能想要打电话或发短信的人。这里展示的是约翰·哈佛的，他的号码是+1-949-468-2750，你可以随时打电话或发短信。但这里展示的是约翰·哈佛在电话簿中的部分数字。

Well, it turns out that physically in the phone book, we might use an algorithm, step by step instructions, for finding John Harvard in pretty much the same way as iOS, Android, Mac OS, Windows, or other operating systems themselves use. So I could, when looking for John Harvard, first name, starting with J, I could start at the beginning of the phone book and start looking page by page by page for John Harvard. And if he's there, I can call. This is an algorithm. 
嗯，实际上在电话簿中，我们可能会使用一个算法，一步一步的指令，来查找约翰·哈佛，几乎和 iOS、Android、Mac OS、Windows 或其他操作系统本身使用的方式一样。所以，当我在寻找约翰·哈佛时，首先名字以 J 开头，我可以从电话簿的开始处开始，一页一页地寻找约翰·哈佛。如果他真的在那里，我可以给他打电话。这是一个算法。

It's indeed step by step, but that was a bug. A few pages turned. But is this algorithm correct? Step by step, assuming I'm paying attention. So yes, if John Harvard is in here, I will eventually find him once I get to the J section. Now, this is a little tedious. It's going to take a while. A few dozen, a few hundred pages. So maybe I could do things a little smarter from grade school, like 2, 4, 6, 8, 10, 12, 14, 16, and so forth, going twice as fast. Is that algorithm correct? So no, but why? 
确实是逐步的，但那是一个错误。翻了几页。但是这个算法正确吗？逐步的，假设我注意到了。所以，如果约翰·哈佛在这里，我最终会在到达 J 部分时找到他。现在，这有点繁琐。会花一些时间。几十页，几百页。所以，也许我可以从小学时就开始聪明一点，比如 2、4、6、8、10、12、14、16 等等，每次翻倍。这个算法正确吗？不，但为什么？

AUDIENCE: You could miss it. 
观众：你可能会错过它。

DAVID MALAN: I could miss him, right? I could just get unlucky, really, with 50/50 probability, because John Harvard could be sandwiched between two pages. Now, this isn't a complete loss, this algorithm. Maybe what I could do is if I get past the J section to K, I could double back at least one page just to make sure I didn't miss John Harvard. So I can still go twice as fast plus an extra step just to make sure I didn't mess up. So the first algorithm might take as many pages as there are in the phone book. 
大卫·马兰：我会错过他吗？实际上，我有 50/50 的概率会不幸地错过，因为约翰·哈佛可能被夹在两页之间。现在，这个算法并不是完全的损失。也许我可以做到的是，如果我翻到了 J 区到 K 区，我至少可以回头翻一页，以确保我没有错过约翰·哈佛。这样我仍然可以快两倍，再加上一个额外的步骤来确保我没有出错。所以第一个算法可能需要和电话簿一样多的页数。

So if this phone book has a thousand pages, in the worst case, if I'm not looking for John Harvard, but someone whose name starts with Z, might take me a thousand pages to actually get there. Second algorithm, twice as fast. Literally, it might take me 500 plus one step to get there because I'm going two at a time, so as long as I indeed fix that bug. But what we used to do back in the day and what your phone is doing today, albeit digitally, is going roughly to the middle of the phone book, looking down and realizing, oh, I'm accidentally in the M section, so halfway through the phone book. 
所以如果这本电话簿有一千页，在最坏的情况下，如果我不找约翰·哈佛，而是找以 Z 开头的某人，可能需要一千页才能找到。第二个算法快两倍。实际上，可能只需要 500 页加一步就能找到，因为我一次翻两页，只要我确实修复了那个错误。但过去我们做的方法，以及今天你的手机所做的方法，尽管是数字化的，就是大致找到电话簿的中间，然后向下看，意识到，哦，我意外地到了 M 区，所以我在电话簿的中间。

But what do I now know about John Harvard? Is he to the left or to the right? So he's obviously to the left, because J comes before M. So what I can do literally and what your computer does figuratively is tear the problem in half, throw half of the problem away, leaving us now with the same fundamental problem, but it's half as big. So I've gone from a thousand pages suddenly to 500 pages. And compare this to the other two, 1,000 pages, 999, 998, versus 1,000 pages, 998, 996, 994. 
但是我现在对约翰·哈佛了解多少？他在左边还是右边？所以他显然在左边，因为 J 在 M 之前。所以我可以做的，还有你的电脑象征性地做的，就是将问题一分为二，扔掉一半的问题，现在我们面临的是同样基本的问题，但规模减半了。所以我突然从一千页变成了五百页。再和另外两个比较，一千页，999 页，998 页，和一千页，998 页，996 页，994 页。

That's still slow. I went from 1,000 to 500 in just one step of this algorithm. What do I do next? I go roughly to the middle here. Oh, I went a little too far. I'm in the E section now. So is John Harvard to the left or right now? So he's to the right. So I can again tear the problem in half, throw the left half away, knowing now that John Harvard must alphabetically be in here. 
这仍然很慢。我只通过这个算法的一步就从一个一千变成了五百。接下来我该做什么？我大致走到这里中间。哦，我走得太远了，我现在在 E 部分了。那么约翰·哈佛现在是在左边还是右边？所以他现在在右边。所以我可以再次将问题一分为二，扔掉左边的一半，现在我知道约翰·哈佛必须在这里面按字母顺序排列。

And I can divide and divide and divide and conquer this problem again and again by using that heuristic of going left or going right. And I dare say, if I do this correctly, I'll eventually be left with one single page on which John Harvard's number actually is. Or maybe he's not in the phone book at all. So how many steps maximally might that third and final algorithm take? It's not a thousand. It's not even 500 or 501. How many times can you divide a thousand pages in half again and again and again, roughly? 
我可以不断地分割、分割、分割，再次征服这个问题，通过使用向左或向右的启发式方法。我敢说，如果我能正确地做到这一点，最终我会只剩下一页，上面可能写着约翰·哈佛的号码。或者也许他根本不在电话簿里。那么，第三个和最后一个算法最多需要多少步？不是一千步。甚至不是 500 步或 501 步。你大约能将一千页分成多少次一半再一半呢？

AUDIENCE: I want to say nine. 
观众：我想说是九。

DAVID MALAN: So 9, 10. So typically 10 times, give or take. There's a bit of rounding there because it's not a perfect power of two, but roughly 10 times. Like, that is fundamentally better than both of the two algorithms because I go from a thousand pages to 500 to 250 to 125 and so forth, literally halving the problem again and again. So we can actually appreciate and see this even more so graphically. 
大卫·马兰：所以是 9，10。通常情况下是 10 次，略有波动。因为这不是一个完美的 2 的幂，所以有一些四舍五入，但大致上是 10 次。就像这样，这比两个算法都好，因为我将一千页分成 500 页，再分成 250 页，125 页，等等，实际上是一直在将问题减半。所以我们甚至可以从图形上更清楚地看到这一点。

And this is among the things we'll do later in the term when we speak to not only writing correct code, but is your code well designed? Is it better than your previous code? Is it better than someone else's code? Is it better than some other product? If you have given more thought to the algorithms and the quality thereof, you can perhaps minimize the time required to solve problems but no less correctly. 
这是我们将在学期后期讨论的事情之一，不仅是要编写正确的代码，还要考虑你的代码是否设计良好？它是否比你的上一段代码更好？它是否比别人的代码更好？它是否比其他产品更好？如果你对算法及其质量有更多的思考，你或许可以最小化解决问题所需的时间，但至少要正确无误。

So if we have a simple xy plot here, on the y-axis or vertical is the amount of time to solve in whatever unit of measure, seconds, pages, however you want to count. On the horizontal or x-axis is the size of the problem measured in, for instance, numbers of pages. So this would mean zero pages in the phone book. This would mean a lot of pages in the phone book. This would mean no time to solve. This would mean a lot of time to solve. What's the relationship then, among those three algorithms? 
所以，如果我们这里有一个简单的 xy 图，y 轴或垂直轴表示解决问题所需的时间，以任何单位衡量，秒、页数，或者你想如何计数。x 轴或水平轴表示问题的规模，例如，页数。这意味着电话簿中没有页数。这意味着电话簿中有很多页数。这意味着解决问题不需要时间。这意味着解决问题需要很多时间。那么，这三个算法之间的关系是什么呢？

Well, the first one is essentially a straight line, a slope of one. And if the phone book has n pages in it, we'll describe the slope here as essentially 1 over 1 for the algorithm with the first algorithm, turning page by page by page. Which is to say, if we were to add one more page to the phone book next year, first algorithm is going to take one more step. But the second algorithm is definitely better. It's definitely faster, but it's still a straight line. 
好吧，第一个算法基本上是一条直线，斜率为 1。如果电话簿有 n 页，我们在这里将斜率描述为基本上是 1 除以 1，对于第一个算法，是一页一页翻。也就是说，如果我们明年给电话簿增加一页，第一个算法将多走一步。但第二个算法绝对更好。它绝对更快，但仍然是一条直线。

So it's going to take roughly n over 2 steps on average, because you only have to go through half of the phone book because you're going two pages at a time, instead of the whole phone book in the worst case, if someone's name is Z, to go through every page in total. So if we actually compare these-- let me just draw some dashed lines. Suppose that you have this many pages in the phone book. 
因此，平均来说，它将需要 n 除以 2 步，因为你只需要翻阅电话簿的一半，因为你一次翻两页，而不是在最坏的情况下，如果某人的名字是 Z，你需要翻阅所有页面。所以，如果我们实际比较这些——让我画一些虚线。假设电话簿有这么多页。

If you just draw this vertical white line here, it's going to take this much time in red using the first algorithm, but it's going to literally take half as much time in yellow for the second algorithm because you're literally going two pages at once. But the third and final algorithm is a fundamentally different shape. It instead looks a little something like this. It looks like it's flatter and flatter and flatter. It's always increasing. It never gets perfectly flat. But it grows so much more slowly as a function of phone book size. 
如果你在这里画一条垂直的白色线，使用第一个算法将会花费这么多时间，但使用第二个算法黄色将会节省一半的时间，因为你实际上一次翻了两页。但第三个也是最后的算法形状完全不同。它看起来越来越平，一直在增加，永远不会完全平坦。但随着电话簿大小的增加，它的增长速度会慢得多。

And for those who recall their logarithms, this would be described as log base 2 of n. And in fact, that's where the math came from. Log base 2 of 1,000 is roughly 10 in total, even if you need a calculator to confirm as much. But this shape is fundamentally different. Why? Well, suppose that Cambridge, where we are, and Allston, the town across the street next year, combine their two phone books. And they go from a thousand pages each to one phone book with 2,000 pages. 
对于那些还记得对数的人来说，这将是 2 的 n 次方对数。实际上，数学就来源于这里。2 的 1000 次方对数大约是 10，即使你需要计算器来确认也是如此。但这个形状本质上是不同的。为什么？假设我们所在的剑桥和明年对面的 Allston 镇合并他们的两个电话簿。他们从每个 1000 页增加到一本有 2000 页的电话簿。

The first algorithm is going to literally take twice as many steps or pages. Second algorithm is going to take half as many or 50% more because you're going two at a time. But the third algorithm is going to barely miss a beat. Why? Because if this is a thousand pages here and 2,000 pages is over there, just inferring from the shape of the green line, it's not going to be much higher on the vertical axis than the other two were. 
第一个算法将实际上需要两倍多的步骤或页面。第二个算法将减少一半或增加 50%，因为你是同时处理两个。但第三个算法几乎不会受到影响。为什么？因为如果这里有 1000 页，那边有 2000 页，仅从绿色线的形状推断，它在垂直轴上的高度不会比其他两个高多少。

So more specifically, if you have a 2,000 page phone book next year, how many more steps will it take you using that third and final algorithm? Just one, because you'll divide and conquer a 2,000 page phone book into a 1,000 page phone book, and then you're back at the original story. And that's the sort of power of learning algorithms. That's the power of learning computer science and learning how to program is to be able to navigate big data, so to speak. 
更具体地说，如果你明年有一本 2000 页的电话簿，使用这个第三个和最后一个算法需要多少额外的步骤？只需要一个，因为你会将 2000 页的电话簿分成 1000 页的电话簿，然后你回到了原来的故事。这就是学习算法的力量。这就是学习计算机科学和编程的力量，能够处理大数据，如此而已。

Things the size of google, things the size of artificial intelligence training data sets using better and better, more clever algorithms that perform faster, and therefore not only make the software more competitive, but also make it more usable and more favorable for people like you and me when using that software. So when it comes to implementing algorithms as programmers, as computer scientists, what you're really doing is taking these algorithms, which might be expressed in English conceptually as we just did, but really just translating them to code, be it C or C++ or Python or R or Ruby or any number of other languages that exist in the world. 
事物的大小如同谷歌，如同人工智能训练数据集，使用越来越好的、更聪明的算法，运行速度越来越快，因此不仅使软件更具竞争力，而且使软件更加易于使用，对我们这样的人来说更加有利。所以当程序员、计算机科学家实现算法时，你实际上所做的就是将这些算法，可能用英语概念性地表达，就像我们刚才做的那样，但真正地翻译成代码，无论是 C 或 C++、Python、R、Ruby 或其他世界上存在的任何一种语言。

But for now, let's consider how we might implement that algorithm using something that's literally still English, but pseudocode. Something that is still correct, but precise and finite, as per Professor Kernighan's advice, which is to say use your own vernacular of English and just say what you mean but very succinctly. There's no one way to write pseudocode. It's not some formal language. I'm just going to convert the steps I did intuitively to step by step instructions as follows. 
但现在，让我们考虑如何使用某种实际上是英语的东西来实现该算法，即伪代码。这是一种仍然正确、精确且有限的伪代码，正如 Kernighan 教授的建议，也就是说，使用你自己的英语词汇，简洁地表达你的意思。编写伪代码没有一种固定的方法。它不是某种正式语言。我只需将我直观进行的步骤转换为以下逐步指令。

Step one, what I did was pretty much pick up the phone book. Step two, what I did was pretty much open to middle of phone book for the third algorithm. Step three, look at page. Step four, if person is on page, then, step five, call person. If that does not prove to be the case, step six, else if the person is earlier in the book, then open to the middle of the left half of the book and then go back to line three. 
第一步，我基本上是拿起电话簿。第二步，我基本上是翻到电话簿的中间部分，为第三个算法。第三步，查看页面。第四步，如果人在页面上，那么，第五步，打电话给人。如果那不能证明是这种情况，第六步，否则如果人在书中较前部分，那么打开书的左半部分的中间，然后回到第三步。

Then, else if the person is later in the book, open to the middle of the right half of the book and, again, go to line three. Else, there's a fourth and final case. If the person like John Harvard is not on the page, is not earlier, is not later, what's the fourth scenario we'd best consider? He's just not there. Else we should do something specific like quit. 
然后，否则如果人在书中较后部分，打开书的右半部分的中间，然后再次回到第三步。否则，还有第四种和最后一种情况。如果像约翰·哈佛这样的人不在页面上，不在较前部分，也不在较后部分，我们最好考虑的第四种情况是什么？他只是不在那里。否则我们应该做些具体的事情，比如退出。

Now, as an aside, everyone in this room has probably had one of these stupid technical support issues where your phone or your laptop or your desktop computer just freeze all of a sudden, or maybe it spontaneously reboots for no reason. Odds are that's because not you but some other human made a mistake. They probably wrote code working at Microsoft or Apple or Google or somewhere else, and they didn't actually anticipate that, oh, there could be a fourth scenario that could happen in the real world. 
现在，顺便说一下，这个房间里的人可能都遇到过这样的愚蠢的技术支持问题，你的手机、笔记本电脑或台式电脑突然冻结，或者可能是无缘无故地自动重启。概率上，这并不是你的错，而是其他某个人类犯了一个错误。他们可能正在微软、苹果、谷歌或其他地方编写代码，他们实际上并没有预料到，哦，在现实世界中可能还会出现第四种情况。

But if there's no code that tells the computer what to do in that fourth and final scenario, who knows what the computer is going to do? It might, by default, reboot. It might, by default, freeze. That's just a hint of the bugs, the mistakes in software to come. 
但是，如果没有代码告诉计算机在第四种和最后一种情况下该做什么，谁知道计算机会做什么呢？它可能会默认重启。它可能会默认冻结。这只是未来软件中可能出现的错误和错误的暗示。

But even though this is just one way to write this code, a.k.a. pseudocode, there are some salient characteristics that we'll use throughout today. One, there are these verbs, these actions. And henceforth, as aspiring computer scientists or programmers, we're going to start to call these by what a more and more technical audience would. These are functions. A function is an action or a verb. It's like a bite-sized task that a computer can do for you. Those then are functions in this here pseudocode. 
尽管这只是编写此代码的一种方式，即伪代码，但其中有一些显著特征我们将贯穿今天使用。一是这些动词，这些动作。因此，作为有抱负的计算机科学家或程序员，我们将开始用更技术性的观众可能会用的方式来称呼它们。这些都是函数。函数是一个动作或动词。它就像是一个计算机可以为你完成的微型任务。那么，这些就是这里的伪代码中的函数。

But there's other types of code in here. There are these things here. If else if else if else. Those are examples of what we're going to start calling conditionals. These are sort of proverbial forks in the road where maybe you go this way, maybe you go this way, but you decide which way to go based on a question. The questions that you ask are what we'll technically call Boolean expressions named after mathematician Boole. 
但是这里还有其他类型的代码。这里有一些东西。如果 else if else if else。这些都是我们将开始称之为条件语句的例子。这些就像是道路上的分岔口，你可能走这条路，也可能走那条路，但你根据一个问题来决定走哪条路。你提出的问题就是我们技术上所说的布尔表达式，以数学家布尔命名。

A Boolean expression is a question with a yes or no answer, a true or false answer, a black or white answer, a one or zero answer. There's two possibilities, and there's a hint of the binary underneath. A Boolean expression is going to tell you yes or no, you should go down that fork in the road. Notice what's important here is that indentation mattered as a result. 
布尔表达式是一个有是或否、真或假、黑或白、一或零答案的问题。有两种可能性，其中隐含着二进制的影子。布尔表达式会告诉你是否应该走这条路。注意，这里重要的是缩进很重要。

Notice that on line four when I first asked if the person is on page question mark, so to speak, I should only do line five per its indentation if the answer is yes or true, I should only open to the middle of the left half of the book and go back to line three if person is instead earlier in the book. So indentation in pseudocode and in many programming languages has logical significance. It tells you whether to do things or not. But there's another construct in here. 
注意，在第四行我第一次问这个人是否在书中的某个位置时，如果答案是“是”或“真”，那么我应该根据缩进只做第五行，如果这个人在书的前面，我应该回到第三行。所以伪代码和许多编程语言中的缩进具有逻辑意义。它告诉你是否执行某些操作。但这里还有一个结构。

Go back to. Go back to, which literally makes me go back to line three, potentially again and again and again, creating some kind of cycle or what we'll typically call a loop instead. So even in this relatively simple real world algorithm, we have these four fundamental characteristics of most computer programs that we will write in this class, and you might write beyond this class, that we have some technical jargon now to describe them. 
返回。返回，字面上让我返回到第三行，可能一次又一次，形成一个循环或我们通常所说的循环。所以即使在相对简单的现实世界算法中，我们也有大多数我们将在这个班级中编写的计算机程序，甚至可能在这个班级之外编写的程序这四个基本特征，我们现在有一些术语来描述它们。

But what's important to note is that line 8 and line 11, even though they're saying go back to line three, go back to line three, you might think you're running the risk of what we'll call an infinite loop where you literally get stuck in a loop forever, which doesn't sound like a good thing if, at some point, you want to turn your computer off, even though it's still working. But these will not induce infinite loops. Why? What is happening in this particular algorithm every time we go back to line three that guarantees eventually we will stop going back to line three? 
但重要的是要注意，第 8 行和第 11 行，尽管它们都在说返回到第三行，返回到第三行，你可能会认为你正在冒我们所说的无限循环的风险，你可能会永远卡在循环中，这听起来并不好，如果你想在某个时候关掉电脑，即使它还在工作。但它们不会导致无限循环。为什么？在这个特定的算法中，每次我们返回到第三行时会发生什么，保证我们最终会停止返回到第三行？

AUDIENCE: The person is on the page, you call it. 
观众：那个人在页面上，你叫他。

DAVID MALAN: Exactly. If the person is on the page, we will call them or we will quit. But more importantly, because we keep dividing and conquering the problem, in this case, having the phone book, having the phone book, eventually we're going to run out of phone book, in which case, indeed, John Harvard is either on that page or not And we will call or we will quit instead. So we'll see in time. 
大卫·马兰：没错。如果这个人出现在页面上，我们会给他打电话，或者我们会放弃。但更重要的是，因为我们一直在分而治之，在这个例子中，拥有电话簿，拥有电话簿，最终我们会用完电话簿，到时候，的确，约翰·哈佛要么就在那一页上，要么就不在。然后我们会打电话或者放弃。所以我们会看到结果。

And in fact, allow me to promise. Odds are at some point you will write code that seems to take control over the computer for you, where it's doing something, doing something, doing something, and it literally won't respond to you anymore. That's just going to be because of a mistake, a so-called bug that you yourself will invariably have added to your code accidentally. But we'll show you ways for terminating it or breaking out of those conditions. 
事实上，让我承诺。很可能在某个时候，你会编写出似乎能够控制计算机的代码，它正在做某事，做某事，做某事，而且它根本不会响应你。那只是因为一个错误，一个所谓的错误，你无意中添加到代码中的错误。但我们会教你如何终止它或从中退出这些条件。

And indeed, what we'll do in just a little bit after a break for today's lecture is explore not just these concepts, but some of the ways you can use them to solve real and very visual and audio problems. But for now, let's at least connect it to something that's been all too germane in recent months, the past few years, namely artificial intelligence, which is a topic we'll come back to at the end of the course, too, to give you a sense of what the connection is with what everyone's been talking about in the world of AI and what it is we're going to spend the next few weeks building up to by writing code. 
确实，在今天的讲座休息之后，我们将不仅探讨这些概念，还会探讨一些使用这些概念解决真实、非常直观和音频问题的方法。但就目前而言，让我们至少将其与最近几个月、过去几年一直非常相关的话题联系起来，即人工智能，我们将在课程结束时再次回到这个话题，让您了解它与大家在世界人工智能领域所谈论的内容之间的联系，以及我们将在接下来的几周内通过编写代码来构建的内容。

If you were to try to implement something like a chat bot, for instance, that just answers questions and has a conversation with you, you could do that using pseudocode, and as we'll soon see, you can use C, Python, any number of other languages too. That pseudocode might look like this when implementing a chat bot. You could tell the chat bot, if the student says hello to you, then say hello back. And the indentation, as per earlier, implies this is conditional. 
假如您要尝试实现一个像聊天机器人这样的东西，比如回答问题和与您进行对话，您可以使用伪代码来实现，而且正如我们很快就会看到的，您可以使用 C 语言、Python 或其他许多语言。当实现聊天机器人时，伪代码可能看起来像这样。您可以告诉聊天机器人，如果学生向您说你好，那么就回应你好。并且，正如之前所提到的，缩进表示这是一个条件语句。

Else if the student says goodbye to you, say goodbye to the student. Else if the student asks you how you are, say you are well. So you can just enumerate question after question after question and just handle all of these conditional possibilities. But things kind of escalate quickly, especially with the tools of today like ChatGPT. Are we really going to have the wherewithal as programmers to write another conditional like else if the student asks why 111 in binary is 7 in decimal-- like, this kind of hints at, oh my God, there's an infinite number of things this human could ask the chat bot. 
如果学生向你告别，你也向学生告别。如果学生问你过得怎么样，你就说你很好。所以你可以一个接一个地列举问题，并处理所有这些条件可能性。但是事情会迅速升级，尤其是在今天这样的工具，比如 ChatGPT 的帮助下。我们作为程序员真的有足够的精力去编写另一个条件吗——比如学生问为什么二进制的 111 等于十进制的 7——这就像，哦我的天哪，这个人类可以向聊天机器人提出无限多的问题。

Do we really have to write an infinite number of conditionals? That's just not possible. Like, there's not enough time in the day, there's not enough lines of code available. Artificial intelligence surely needs to be able to figure some of this out instead. And so indeed, this is not how you implement AI, but rather how you implement an AI like a chat bot is you typically train it based on lots and lots of data. 
我们真的需要编写无限多的条件吗？这是不可能的。就像，一天的时间不够，可用的代码行数也不够。人工智能肯定需要能够自己解决一些问题。所以，实际上，这不是实现人工智能的方式，而是实现一个像聊天机器人这样的 AI，你通常是通过大量数据来训练它的。

You give it lots of inputs, lots of inputs, training data, and let it figure out what it should say in response to certain questions. And it boils down to a lot of probability, a lot of statistics, otherwise known now as large language models, which, if we really peek under the hood, are actually typically implemented with what are called neural networks inspired by the world of biology, whereby we humans have all of these neurons that transmit electrical signals such that my brain tells my hand to move this way, this way, and this other way. 
你给它提供大量的输入，大量的输入，训练数据，然后让它自己找出对某些问题的回答。这归结于大量的概率，大量的统计，现在被称为大型语言模型，如果我们真正揭开它的面纱，实际上通常是用所谓的受生物学世界启发的神经网络来实现的，我们人类有所有这些神经元来传递电信号，这样我的大脑就能告诉我的手这样移动，那样移动。

And so what computer scientists have been doing over the past many years is implementing in software using literally zeros and ones, graphs or networks, neural networks, that look a little something like this, where each of the circles represents a neuron, each of the arrows represents a pathway between them, and provides as input to these networks huge amounts of data like all of the internet, all of Wikipedia, all of the books that it might consume as input. 
因此，在过去的许多年里，计算机科学家们一直在软件中实现这些，用 literally zeros and ones，即零和一，构建图或网络，神经网络，它们看起来有点像这样，其中每个圆圈代表一个神经元，每条箭头代表它们之间的路径，并为这些网络提供大量数据，如整个互联网，所有维基百科，所有可能作为输入的书籍。

And then the goal of this neural network, as per this single final neuron right here, is to produce an answer to a question. Maybe it's simple like, yes, no, or maybe it's something like the answer to the 111 question or how are you or goodbye or hello or the like. And what these neural networks do is use statistics and probability and try to output the most probabilistically likely answer to this question that's been asked and really just hope that it is correct. 
然后这个神经网络的目的是根据这个单独的最终神经元产生一个问题的答案。可能很简单，比如是、否，或者可能是回答第 111 个问题，或者你好，再见，或者类似的话。这些神经网络使用统计学和概率，试图输出最可能的问题答案，并真的希望它是正确的。

There is no programmer at OpenAI or Google or Microsoft that's trying to anticipate every one of these questions we might ask, not only in English but in other languages as well. So you might be wondering why there's this 8 foot duck on the stage. So the persona that CS50's own AI takes is in fact that of a rubber duck, because it turns out in programming circles-- and this is true long before CS50-- it has often been recommended to students and aspiring programmers that you keep literally a physical rubber duck on your desk. 
在 OpenAI、谷歌或微软，没有程序员试图预测我们可能会问的每一个问题，不仅限于英语，还包括其他语言。所以你可能想知道为什么舞台上有一只 8 英尺高的鸭子。CS50 自己的 AI 所扮演的角色实际上是一只橡皮鸭，因为据编程圈子所说——这早在 CS50 之前就是真的——经常建议学生和有志于编程的人在他们桌子上放一只实际的橡皮鸭。

The idea being, in the absence of a friend, family member, colleague, TA who could answer technical questions for you, if you're alone in your room in Mather at night, you can talk to the duck, maybe door closed, and ask the duck your questions, or, more importantly, talk the duck through what confusion you're having. And the mere act of talking through the problem, explaining logically what you're trying to do, what you're actually doing, and what the error actually is, invariably, that sort of proverbial light bulb goes off and you realize, oh, I'm an idiot. 
想象一下，在没有朋友、家人、同事或助教可以为你解答技术问题时，如果你独自一人在 Mather 的房间里过夜，你可以和鸭子说话，也许门是关着的，向鸭子提出你的问题，或者更重要的是，和鸭子谈谈你遇到的困惑。仅仅通过谈论问题，逻辑地解释你试图做什么，实际上在做什么，以及错误实际上是什么，这种传说中的灯泡就会亮起，你会突然意识到，哦，我是个傻瓜。

I hear in my own words where I've gone awry. And even though this duck will never say anything back to you, that alone, rubber duck debugging or rubber ducking, tends to be a valuable programming technique, believe it or not. But thanks to these large language models, we have not only physical but virtual ducks as well. And so available to you will be in this class not tools like ChatGPT and the like, which are, through policy, disallowed. It is not reasonable to use ChatGPT and the like. 
我能听到自己出错的地方。尽管这只鸭子永远不会对你说话，但仅此一点，橡皮鸭调试或橡皮鸭法，实际上是一种很有价值的编程技巧，信不信由你。但是，多亏了这些大型语言模型，我们现在不仅有物理的鸭子，还有虚拟的鸭子。因此，在这个课程中，你将不会得到像 ChatGPT 这样的工具，这些工具由于政策原因被禁止使用。使用 ChatGPT 这样的工具是不合理的。

But you are allowed and encouraged to use CS50's own AI based tools, which resemble those same tools but know something about CS50 and aspire to behave akin to a good teaching fellow guiding you to solutions as opposed to handing you something outright. So this is a tool that will be available at literally this URL throughout the course. CS50.ai. It will also be embedded in the programming environment you'll soon meet, which is called Visual Studio Code, a cloud based version thereof. 
但你被允许并鼓励使用 CS50 的基于 AI 的工具，这些工具与那些工具相似，但了解 CS50，并渴望表现得像一位优秀的助教，引导你找到解决方案，而不是直接给你答案。所以这是一个将在整个课程中实际可用的工具，网址为 CS50.ai。它还将嵌入你即将遇到的编程环境中，该环境被称为 Visual Studio Code，这是一个基于云的版本。

The duck will live in that environment as well, as well as on stage from time to time, which is to say we'll not only talk about, but use throughout the course this thing known as AI. But this is ultimately code that we're going to start writing next week. And unfortunately, this code here is written in a language called C. This is essentially the program that I lost two points on some 25 plus years ago. 
鸭子也将生活在这个环境中，有时也会出现在舞台上，也就是说，我们不仅会讨论，而且会在整个课程中使用这个被称为 AI 的东西。但下周我们将开始编写的代码最终是 C 语言编写的。这实际上是我 25 年前丢失了两分的程序。

It does look admittedly cryptic. That's why today what we'll focus on is not what this code looks like, nor the zeros and ones that that code gets converted to so your computer can understand as input what you want it to do. We're going to focus on a much more visual incarnation of this. But I know thus far this has been a lot. So let's go ahead and take a five minute break here, and when we come back in five, we'll do some actual programming. So see you in five. 
诚然看起来有些晦涩难懂。这就是为什么今天我们要关注的不是代码看起来如何，也不是代码转换成零和一的过程，这样你的电脑才能理解你想要它做什么的输入。我们将关注一个更加直观的版本。但我知道到目前为止这已经很多了。所以，让我们在这里休息五分钟，五分钟后回来，我们将进行一些实际的编程。五分钟后见。

All right. So it's now time to solve with actual code some actual problems, albeit in a fun and visual and audio way. But recall that where we left off was this. Starting next week, you'll be writing code that ultimately looks like this, but thankfully, you will not be writing zeros and ones, and no normal person, myself included, can understand what all of these zeros and ones are at a glance. We could take out some paper, pencil, and probably figure it out very tediously. 
好的。现在是我们用实际的代码解决一些实际问题的时候了，虽然是以有趣、直观和音频的方式。但请记住，我们上一次停在了这里。从下周开始，你将编写最终看起来像这样的代码，但幸运的是，你将不会编写零和一，而且包括我在内的任何正常人都无法一眼看懂所有这些零和一。我们可以拿出一些纸和笔，可能非常费力地弄清楚。

But this is exactly the point. Computers only understand this stuff, but what we as programmers will start writing today and beyond is code at a higher level. And indeed, this is going to be-- this is going to be frequent within computer science where there's different levels of abstraction that we operate at. And the lowest level, the nittiest gritty, is like the zeros and ones that computer understand. 
但这正是关键所在。计算机只理解这些，但我们作为程序员今天开始编写以及未来将要编写的将是更高层次的代码。的确，在计算机科学中，我们将操作不同层次的抽象，其中最低层次，最精细的部分，就像计算机理解的零和一。

That's it in this class for zeros and ones. Hopefully you at least have wrapped your mind around why zeros and ones can be used in triples and as bytes to represent higher and higher numbers. But let's just now agree that computers can do that. Let's abstract away from that detail and focus on higher level languages than zeros and ones, namely a language like this. So this is an example of the very first programming language I learned back in the day as per that homework in a language called C. 
这节课关于零和一的内容就到这里。希望你们至少已经理解了为什么零和一可以用来表示更高的数字，作为三进制和字节。但现在我们达成共识，计算机可以做到这一点。让我们从这些细节中抽象出来，关注高于零和一的更高层次的语言，比如这种语言。这是我在那个时代学习的第一种编程语言的例子，正如那个作业中提到的，这种语言叫做 C。

It's an older language, but it remains one of the most popular languages in omnipresent languages nowadays because it's incredibly fast and it's particularly good at making devices operate quickly. For us pedagogically, the value of C is not that you're probably in Silicon Valley and other such jobs going to be using C yourself that much, but because it's going to provide a conceptual foundation on top of which we introduce other languages, like Python, which is newer and improved, so to speak, that gives you more and more functionality for free out of the box by abstracting away some of the stuff we'll focus on in the coming days first. 
它是一种较老的语言，但仍然是当今无处不在的语言中最受欢迎的语言之一，因为它非常快，而且在使设备快速运行方面特别出色。对我们来说，C 语言的教育价值不在于你可能在硅谷或其他类似的工作中会大量使用 C 语言，而在于它将提供一个概念性的基础，在此基础上我们引入其他语言，比如 Python，这是一种更新、更完善的语言，可以说，它通过抽象出我们将在未来几天重点关注的某些内容，为你免费提供越来越多的功能。

So at the end of the day, you should better understand languages like Python and JavaScript and SQL because of your underlying understanding of a language like C. But this is too much for the first day. Many of you will think that this is too much for the second week. But in fact, C is really only sort of scary looking because all of this darn punctuation and syntax, the semicolon, the parentheses, the double quotes, the curly braces, and the like. And I concur. 
所以，最终，你应该更好地理解 Python、JavaScript 和 SQL 等语言，因为你对像 C 这样的语言有深入的理解。但这对于第一天来说太多了。你们中的许多人会认为这对于第二周来说也太多了。但实际上，C 语言之所以看起来有点吓人，只是因为所有的这些讨厌的标点符号和语法，分号、括号、双引号、花括号等等。我同意这一点。

This is intellectually uninteresting, and a lot of the challenges early on when learning programming is you just don't have the muscle memory that I or some of the teaching fellows might for knowing what symbol should be where. But that's going to come with time and practice, I guarantee it. What we'll do for today, though, is just throw away all of that intellectually uninteresting detail and focus really on ideas. 
这在智力上并不有趣，而且在学习编程的早期阶段，你可能没有像我或一些教学助理可能拥有的肌肉记忆，不知道符号应该放在哪里。但请相信，这会随着时间和练习而逐渐掌握。不过，今天我们要做的是抛开所有这些智力上无趣的细节，真正关注思想。

And some of you might be in your comfort zone here because if back in middle school you were playing with a programming language called Scratch, you were probably using at the time just to have fun in class or out of class, making games, animations, interactive art. What you probably didn't use it for, at least in middle school, was to consider and explore programming languages themselves. 
可能有些人已经进入了舒适区，因为如果在中学时你玩过一种叫做 Scratch 的编程语言，你当时可能只是用来在课堂上或课后娱乐，制作游戏、动画、互动艺术。但在中学时，你可能没有用它来考虑和探索编程语言本身。

But what's wonderful about Scratch, which is this graphical programming language from down the street at MIT, where it was invented some years ago, is you can program not by using your keyboard per se, but by dragging and dropping puzzle pieces, otherwise known as blocks, that will snap together if it makes logical sense to do so. And what you won't have to deal with is parentheses and double quotes and semicolons and all of that, at least until next week. 
但 Scratch 的奇妙之处在于，它是一种来自麻省理工学院街区的图形化编程语言，几年前在那里被发明出来，你可以通过拖放拼图块（也就是我们所说的积木）来编程，如果这样做在逻辑上合理，它们就会自动拼合在一起。而且你不需要处理括号、双引号、分号等等，至少在下周之前是这样的。

But the nice thing about Scratch is that after this week and after the so-called problem set zero, the first assignment in which you'll use Scratch, you'll have a mental model via which it will be easier to pick up all of the subsequent syntax as well. So let's see how we can start programming in Scratch by making the simplest of programs first. You can do this at scratch.mit.edu. 
但 Scratch 的好处在于，经过这周以及所谓的“问题集零”之后，你将使用 Scratch 的第一个作业，你将有一个心理模型，这将使你更容易掌握所有后续的语法。那么，让我们看看如何通过编写最简单的程序来开始使用 Scratch 编程。你可以在 scratch.mit.edu 上做到这一点。

You needn't do this now in the moment. Problem set zero will walk you through all of these steps. But what I've done here is opened up at scratch.mit.edu, precisely the default web page therein. This is after having clicked the Create button in Scratch, which is going to allow me to create my first program. But first, a tour of the user interface here, and what is ultimately available to you. 
你现在不必这么做。零号问题集会带你完成所有这些步骤。但我在这里做的是打开 scratch.mit.edu，正是其中的默认网页。这是在点击了 Scratch 中的创建按钮之后，这将允许我创建我的第一个程序。但在那之前，我们先来浏览一下用户界面，以及你最终可以使用的功能。

Well, within the Scratch environment, we'll see a few different regions of the screen. One, we have this palette of puzzle pieces at left. The blue ones relate to motion, the purple ones relate to looks, the pink ones relate to sound, and so forth. So the color of the blocks just roughly categorizes what that block's purpose in life is. We're going to be able to use those puzzle pieces by dragging and dropping them from left to right. In the right here, in the middle of the screen is where I'm going to write my actual programs. 
好的，在 Scratch 环境中，我们会看到屏幕上的几个不同区域。首先，左侧有一个拼图块的工具箱。蓝色的与运动相关，紫色的与外观相关，粉色的与声音相关，等等。所以这些块的颜色大致分类了它们在生活中的用途。我们将能够通过从左到右拖放这些拼图块来使用它们。在屏幕的右侧中间，我将编写我的实际程序。

This is where I'll drag and drop these puzzle pieces, lock them together, and actually write my code. What am I going to be coding? Well, I'm going to be controlling one or more sprites. Much like in the world of games are familiar, a sprite is like a character that you might see on the screen. The default character in the world of Scratch is, in fact, a cat that looks like this. 
这里我将拖放这些拼图块，将它们锁在一起，并真正编写我的代码。我将编写什么代码呢？我将控制一个或多个精灵。就像在大家熟悉的游戏世界中一样，精灵就像你可能在屏幕上看到的角色。在 Scratch 的世界中，默认的角色实际上是一只看起来像这样的猫。

And if in this case, I have just one cat, I can then make that cat do things in his own little world at top right by making the cat move up, down, left, right, spinning around, or doing other things as well. But if you want to introduce a dog or a bird or any number of other custom characters, you just add more sprites and they get their own place in that same world. As for how to think about movement in this world, it's actually pretty familiar, even though it gets a little numeric for a moment. 
如果在这个例子中，我只有一只猫，我就可以通过让这只猫向上、向下、向左、向右移动，旋转或做其他事情，在右上角自己的小世界中让它做事情。但如果你想引入一只狗、一只鸟或其他任何自定义角色，你只需添加更多精灵，它们就会在那个相同的世界中拥有自己的位置。至于在这个世界中如何思考运动，实际上非常熟悉，尽管有时会变得有点数值化。

If Scratch at the moment is in the middle of the screen, the cat is at 0, 0 if you think about x, y-coordinates or latitude longitude. If you move the cat all the way up, this would still be x equals 0, but it would be y 180. What's the 180? 180 pixels vertically or dots on the screen. This is negative 180 pixels on the screen at the bottom. By contrast, if you go left and right, your x value might change. Negative 240, but y is 0, or positive 240 and y is 0 as well. 
如果 Scratch 此时位于屏幕中央，那么猫在 x、y 坐标或经纬度上就是 0, 0。如果你把猫完全向上移动，这仍然是 x 等于 0，但 y 将是 180。180 是什么意思？是垂直方向上的 180 个像素或屏幕上的点。这是屏幕底部的负 180 个像素。相比之下，如果你向左或向右移动，你的 x 值可能会改变。可能是负 240，但 y 仍然是 0，或者正 240，y 也是 0。

But most of the time you won't need to know or care about what the pixel coordinates of the cat are. All you're generally going to care about is the programmer, most likely, is do you want the cat to go relatively up, down, left, or right, and let MIT figure out the mathematics of moving this thing around in most cases. 
但大多数时候，你不需要知道或关心猫的像素坐标。你通常最关心的可能是程序员，你想要猫相对向上、向下、向左还是向右移动，让麻省理工学院在大多数情况下来计算这个物体移动的数学问题。

All right. So let's go ahead and introduce the first of these programs by doing something quite simple, as we did in C there, but a little more simply by writing code as follows. I'm going to go back to scratch.mit.edu. I've already clicked, per before, the Create button. And if I click on the yellow category of blocks here at left-- and I'll zoom in-- we'll see a whole bunch of yellow puzzle pieces. And probably the most common one you will use to write code in Scratch for just this first week is literally when green flag clicked. 
好的。那么我们就简单介绍一下这些程序中的第一个，就像我们在 C 语言中做的那样，但稍微简单一些，编写如下代码。我将回到 scratch.mit.edu。我已经点击了之前的创建按钮。如果我在左侧的黄色类别上点击，我会放大，我们会看到一大堆黄色的拼图块。而在这第一周，你可能会最常用到的是当绿色标志被点击时。

Why? Well, if we go back over to the cat's world at top right, notice that above the cat's rectangular world, there's not only a green flag for starting, there's a red stop sign for stopping as well. So let's do this. Let me go ahead and click and drag. When green flag clicked anywhere into the middle and let go. And now I'm going to go to looks, and it looks like there's a whole bunch of purple puzzle pieces here. I'm going to choose something simple like say hello, drag it. 
为什么呢？如果我们回到右上角的猫的世界，注意在猫的矩形世界上方，不仅有启动的绿色标志，还有一个停止的红色交通标志。所以让我们这样做。让我先点击并拖动。当绿色标志在任何地方被点击并释放时。现在我将转到外观，看起来这里有很多紫色的拼图块。我会选择一个简单的，比如说“你好”，然后拖动它。

And notice if I get just close enough, it's going to want to magnetically snap together. So I'll just do that and it does its thing. The fact that there's this white oval with text means that is an input to this, say, puzzle piece. I can literally then change what the input is if I want to more conventionally say hello, world. Which in fact, according to lore, was the very first program written in C, and nowadays in most every language, including in Brian Kernighan's book. So hello world is generally the first program that most any programmer first writes. 
注意，如果我离得足够近，它就会想要磁性地吸附在一起。所以我只需这样做，它就会完成它的任务。这个白色椭圆形带有文字意味着它是这个，比如说，拼图块的输入。我实际上可以改变输入的内容，如果我想更传统地写“你好，世界”。事实上，根据传说，这是用 C 语言编写的第一个程序，现在在大多数语言中，包括在 Brian Kernighan 的书中。所以“你好，世界”通常是大多数程序员首先编写的第一个程序。

So that's it as programs go. Let me go ahead and zoom out here. Let me go over to the right and click the green flag, and somewhat excitingly, maybe underwhelmingly, we've now written a program that quite simply says hello world on the screen. Now let's make this a little more technical for just a moment. What is this here puzzle piece, as I keep calling it? It's actually a similar-- it's an incarnation one of the ideas from our pseudocode before. What did we call those actions and verbs last time in my pseudocode? 
这样，程序就完成了。让我先放大一下。让我转到右边，点击绿色标志，有点令人兴奋，也许又有点令人失望，我们现在已经编写了一个简单的程序，它在屏幕上显示“你好，世界”。现在让我们稍微技术性地讨论一下。我刚才一直说的这个拼图块是什么？实际上，它是我们之前伪代码中一个想法的实现。我们上次在伪代码中叫那些动作和动词是什么？

AUDIENCE: [INAUDIBLE].   观众：[听不清]。

DAVID MALAN: Functions. That's right. So these purple puzzle pieces here are indeed functions, and some functions, as we can see, take inputs, like hello comma world. After all, how does Scratch know what to say? You have to provide the cat with input, which is to say functions can indeed take inputs like this. In this case one input, but we'll see opportunities for passing in more input as well. 
大卫·马尔安：函数。没错。所以这里这些紫色的拼图块确实是函数，而且我们可以看到，有些函数确实需要输入，比如“hello, world”。毕竟，Scratch 是怎么知道该说什么的呢？你必须给猫提供输入，也就是说函数确实可以接受这样的输入。在这种情况下只有一个输入，但我们会看到传递更多输入的机会。

What the cat is doing though, visually on the screen here at top right, is what's generally called a side effect. Sometimes when you call a function, it does something visually. And in this case, you're seeing literally a cartoon speech bubble, hello world. That is the side effect of this function. So if we now want to map this to our world of inputs and outputs and see where this side effect is, this is the paradigm I proposed at the start of class that is computer science in a nutshell and will be the framework we use literally throughout the class, no matter how-- no matter how the languages in particular evolve. 
然而，猫在屏幕右上角所做的事情，通常被称为副作用。有时候当你调用一个函数时，它会在视觉上做一些事情。在这种情况下，你看到的是一个卡通式的对话气泡“hello world”。这就是这个函数的副作用。所以如果我们现在想要将这个映射到我们的输入和输出世界中，看看副作用在哪里，这就是我在课程开始时提出的范式，这就是计算机科学的精髓，并且我们将以此为框架，贯穿整个课程，无论特定的语言如何演变。

So what's the input to this particular program? Well, this white oval, hello world is my input. The algorithm, step by step instructions for solving some problem, is implemented in code, this language called Scratch by way of this purple puzzle piece. And the output of that function, given this input, is the side effect whereby the cat indeed says hello world visually on the screen in that speech bubble. So the exact same paradigm with which we began today governs how exactly this cat here works. 
那么，这个特定程序的输入是什么？嗯，这个白色的椭圆形，"你好，世界"是我的输入。解决某个问题的算法，逐步的指令，通过这个紫色拼图块，用这种叫做 Scratch 的语言实现。给定这个输入，该函数的输出是副作用，即猫确实在屏幕上的话泡中视觉上说了"你好，世界"。所以今天我们开始时的相同范式正是这个猫在这里工作的方式。

Well, let's actually go back to this program and make it a little more interesting than that. Let me go ahead and click the red stop sign. And let me actually use a different type of puzzle piece, another function that does something a little different. First, I'm going to get rid of the say block. So I'm going to not only pull it away, I'm going to drag it over anywhere at left and just let go and it will delete itself automatically. Or I could right click or Control click, and from a little menu I could also explicitly say delete. 
好吧，让我们回到这个程序，让它比原来更有趣一些。让我先点击这个红色的停止标志。然后，让我使用一个不同的拼图块，另一个做不同事情的函数。首先，我要去掉这个"说"块。所以，我不仅要把它拉走，还要把它拖到左边任何地方然后放手，它会自动删除。或者，我可以右键点击或 Ctrl 点击，然后从一个小菜单中明确选择删除。

And what I'm going to do now is under sensing, which is a light blue shade of puzzle piece-- there's a whole bunch here, but I'm going to focus on this one. Ask something and wait. And the default text is, what's your name? And that's fine. But because it's a white oval, that input can be manually changed by me if I wanted to change the question. I'm going to drag it over here. It's going to magnetically snap together. And I'm OK with that question. 
现在我要做的就是在感应模块，这是一个浅蓝色的拼图块——这里有很多，但我将专注于这个。问一个问题并等待。默认文本是“你叫什么名字？”这很好。但因为它是白色的椭圆形，所以如果我想改变问题，我可以手动更改输入。我将把它拖到这里。它会磁性地吸附在一起。我对这个问题没有问题。

But what do I want to say with the answer? Well, let's go ahead and do this. I could go to looks again. I could grab another say block, let it snap in, and I could say something like, hello, David. But this is going to be the first of many bugs that I make, intentionally or otherwise. Let me click the green flag. Scratch is now, just like in a web browser, prompting me for some input here. So let me go ahead and type in my name. David. Enter. And voila. It works. Hello, David. 
但是我想通过答案表达什么？好吧，让我们继续这样做。我可以再次去外观，抓取另一个说块，让它吸附，然后可以说，你好，大卫。但这将是我会故意或无意中制造的许多错误中的第一个。让我点击绿色标志。Scratch 现在就像在网页浏览器中一样，在这里提示我输入。所以让我先输入我的名字。大卫。回车。哇，成功了。你好，大卫。

I'm kind of cheating, though, right? Because if I zoom out, stop, and play again. Let me type in Julia's name here, enter, and it still says hello, David. So that didn't really implement the idea that I wanted. All right, so how can I fix this? Well, it seems that this time I want more than a side effect. I want to use the value that the human types in. And for this, we need another feature of functions, which is that not only can they sometimes have side effects, something visually happens. 
我有点作弊，对吧？因为如果我放大，停止，然后再播放。让我在这里输入朱莉娅的名字，回车，它仍然说你好，大卫。所以这并没有真正实现我想实现的想法。好吧，那么我该如何解决这个问题呢？嗯，这次我想要的不仅仅是副作用。我想使用人类输入的值。为此，我们需要函数的另一个特性，那就是它们有时不仅会有副作用，还会有一些视觉上的效果。

Some functions can hand you back a value, a so-called return value, that will allow you to actually reuse whatever the human typed in. So a return value is something that gets virtually handed back to you and you can store it in something called a variable, like x, y, and z in mathematics, and you can generally reuse it one or more times. So let me actually draw our attention then to, at left, not only the blue puzzle piece, ask what's your name and wait, but notice that there's a special puzzle piece below it, this blue oval called answer, and that represents what a computer scientist would call a return value. 
一些函数可以返回一个值，即所谓的返回值，这将允许你实际上重用人类输入的内容。所以返回值就是一种被虚拟地交还给你的东西，你可以将其存储在称为变量的东西中，就像数学中的 x、y 和 z，你可以一般性地重用一次或多次。所以让我把我们的注意力引到左边，不仅蓝色的拼图块“请问你的名字”，等待，还要注意下面有一个特殊的拼图块，这个蓝色的椭圆形叫做“答案”，这代表了计算机科学家所说的返回值。

So MIT has kind of bundled it together side by side to make clear that one of those pieces relates to the other. What it means is that I can do this. I can drag this oval and use this oval as the input to the save function. Now, notice it's not the same size, but it is the right shape, so that's OK. Scratch will grow or shrink things to fit properly. But this too isn't quite right. Let me go ahead and do this. Let me go ahead and stop that, click the green flag. I'll type in my name again. D-A-V-I-D. Enter. 
所以麻省理工将其放在一起，以便清楚地表明其中一部分与另一部分相关。这意味着我可以这样做。我可以拖动这个椭圆形，并使用这个椭圆形作为保存功能的输入。现在，请注意，它的大小并不相同，但形状是正确的，所以没问题。Scratch 会调整大小以适应。但这还不够准确。让我先做这个。让我先停止，点击绿色标志。我会再次输入我的名字。D-A-V-I-D。回车。

And it's just kind of weird or rude. Like, I wanted a hello at least, and it just said David on the screen. OK, so I can fix that. Let me stop with the red stop sign. Let me just separate these temporarily. And I can leave it in the middle there, but they have no logical connection temporarily. Let me go back up to looks. Let me grab a say block, a second one, and let me go ahead and say, just to be grammatical, hello, space. And then I'll reconnect this here. 
这有点奇怪或者无礼。就像，我至少想要一个问候，但屏幕上只显示了 David。好吧，我可以修复这个问题。让我用红色停止标志停下来。让我暂时分开它们。我可以在中间留一个，但它们暂时没有逻辑上的联系。让我回到外观。让我抓取一个说块，再抓取一个，然后我来说，为了语法正确，你好，空格。然后我会在这里重新连接。

So at the moment it looks like what I want, I want a hello, comma, and then the return value printed out based on whatever the human typed in. So let me zoom out. Let me click the green flag. Again, what's your name? D-A-V-I-D. And watch the cat's side effect. Enter. It's still not greeting me properly. There's no hello. And if in case it was too fast, let's do it again. Green flag. D-A-V-I-D. Enter. It rudely just says my name, which is weird. What's the bug here, though? It's a little more subtle. Why? Yeah? 
目前看起来就像我想要的，我想输出一个“你好”，然后是逗号，然后根据人类输入的返回值打印出来。那么让我放大一下。点击绿色标志。再次，你叫什么名字？D-A-V-I-D。看看猫的副作用。输入。它仍然没有正确问候我。没有“你好”。如果太快了，我们再试一次。绿色标志。D-A-V-I-D。输入。它粗鲁地只说了我的名字，这很奇怪。那么这里的 bug 是什么？它有点微妙。为什么？是吗？

AUDIENCE: It's just quickly going. 
观众：它只是很快地过去。

DAVID MALAN: Yeah. It's just too quickly going over the say command or the say function, in this case. My Mac, your PC, your phone, it's just so darn fast. Both are happening, but too fast for my human eyes to even notice. So we can solve this in a number of ways. I could actually use a different puzzle piece altogether. In fact, MIT kind of anticipated this. Notice the first puzzle piece in purple is say hello for a specific number of seconds, and you can specify not just the message, but the number of seconds, ergo two inputs, otherwise now known as arguments to a function. 
大卫·马拉恩：是的。只是太快地跳过了“说”命令或“说”函数。我的 Mac，你的 PC，你的手机，都太快了。两者都在发生，但太快以至于我的肉眼甚至注意不到。所以我们可以用几种方法解决这个问题。我实际上可以使用一个完全不同的拼图块。实际上，麻省理工学院已经预料到了这一点。注意第一个紫色的拼图块是“说你好，持续几秒钟”，你可以指定不仅仅是消息，还可以指定秒数，也就是函数的参数，也就是现在所说的输入参数。

An input to a function is just an argument now. And that would be a fix here. I could maybe a little more explicitly do this. I could go under events, scroll down a little bit, and-- sorry, under control in orange, I could grab a wait block and I could kind insert it in the middle. And this might actually help. So I could click on the green flag. D-A-V-I-D. Enter. Hello, David. And I could change the timing to be a little more natural. But what if I want the cat to just say hello, David all in one breath, so to speak. Well, for that I'm going to need to use a slightly different technique as follows. 
函数的输入现在只是一个参数。这里可能需要做一个修正。我或许可以更明确地做这件事。我可以进入事件，向下滚动一点，然后——抱歉，在橙色控制下，我可以抓取一个等待块，然后可以插入到中间。这实际上可能有所帮助。所以我可以点击绿色的标志。D-A-V-I-D。回车。你好，大卫。我可以调整时间，让它更自然一些。但如果我想让猫一口气说出“你好，大卫”，那么我需要使用稍微不同的技巧，如下所示。

Let me go ahead and get rid of the wait. Let me get rid of the second say block and stop the cat with the stop sign. Let me go under operators here and let me somewhat cleverly grab this. A join block at the bottom. By default, it's using apple and banana as placeholders, but those are white ovals so I can change those. Let me drag this over the white oval for the save function and let go, and it will snap to fill. Let me go ahead here and type hello, comma, space instead of apple. And what should I do instead of banana? 
让我先去掉等待。去掉第二个说块，用停止标志停止猫。让我在运算符这里，巧妙地抓取这个。底部的连接块。默认情况下，它使用苹果和香蕉作为占位符，但那些是白色的小圆圈，所以我可以更改它们。让我把这个拖到保存函数的白色小圆圈上，然后放手，它会自动填充。让我在这里输入 hello, comma, space 代替苹果。那么香蕉应该用什么代替呢？

AUDIENCE: Answer.   观众：回答。

DAVID MALAN: Yeah. So it'd be answer return value-- the return value. So let me go under sensing again. Let me just drag another copy of it. And you can use these again and again and again. They don't disappear. I want to drag answer over banana so that the second input to join is actually, if you will, the output of the ask block, like that. And it snaps to fit. So now if I go ahead and click the green flag once more. D-A-V-I-D. Enter. 
DAVID MALAN: 嗯。所以答案是返回值——返回值。让我再次进入感应部分。让我再拖动一个副本。你可以反复使用这些，它们不会消失。我想把“answer”拖到“banana”上，这样第二个输入连接的实际上是，如果你愿意的话，ask 块的输出，就像那样。它会自动对齐。所以现在，如果我再次点击绿色标志。D-A-V-I-D。回车。

Now we have the behavior aesthetically that I cared about. But beyond the aesthetics of this, the goal here really was to map it to, again, this same paradigm, which we'll see here. The algorithm and the output and the input for this example are as follows. The input to the say block was, quote, unquote, what's your name? The function, of course, implementing that algorithm in code was the ask and wait block. The output, though, of the ask block recalls not some visual side effect. 
现在我们有了我关心的行为美学。但除了这个美学之外，这里的真正目标是将其映射到，再次，这个相同的范式，我们在这里会看到。这个示例的输入、算法和输出如下。say 块的输入是，“quote, unquote, what's your name?”当然，实现该算法的代码块是 ask and wait 块。但是，ask 块的输出并不是某种视觉副作用。

It is a return value called answer, like a variable, a special variable like x, y, and z in math. But in this one, we generally in programming describe variables with actual words, not just letters. But this output of the say block, I kind of want to make room for it to pass it into the say block as a second argument. So let's do this. Let's take one step back and propose that now for the join block that I just used. It takes two inputs hello, space and answer. The function in question is indeed the join block. 
这是一个名为 answer 的返回值，就像一个变量，就像数学中的 x、y 和 z 这样的特殊变量。但在这种情况下，我们在编程中通常用实际的单词来描述变量，而不仅仅是字母。但这个 say 块的输出，我想要给它留出空间，以便将其作为第二个参数传递给 say 块。所以让我们这样做。让我们退一步，提出现在对于我刚刚使用的 join 块。它接受两个输入 hello，空格和 answer。问题中的函数确实是 join 块。

The output of this had better be hello, David. What do I want to do with the output of the join block? Well, let me clear the screen. Let me move this over, because now the output of the join block is going to instantly become the input to the say block so that the output now in this multistep process is the side effect of hello, David. So the fact that I nested these blocks on top of one another was very much deliberate. If I zoom in here, notice that hello and answer are on top of join, join is on top of the say block. 
这个输出的结果最好是 hello，David。我想对 join 块的输出做些什么？好吧，让我清屏。让我把它移过来，因为现在 join 块的输出将立即成为 say 块的输入，所以在这个多步骤的过程中，输出现在是 hello，David 的副作用。所以我在这些块上面嵌套是非常有意的。如果我放大这里，注意 hello 和 answer 在 join 的上面，join 在 say 块上面。

And if you think back to high school math, this is like when you had parentheses and you had to do the things inside parentheses before the things outside parentheses. It's the same idea, but I'm just visually stacking them instead. But outputs can become inputs depending on what the function there expects. Let me pause here and see if there's any questions about not so much what the cat is doing, but how the cat is doing this. Questions at hand? 
如果回想一下高中数学，这就像你遇到括号时，你必须先做括号里面的，再做括号外面的。这个想法是一样的，但我只是从视觉上堆叠它们。但输出可以成为输入，这取决于那里的函数期望什么。让我在这里暂停一下，看看有没有关于猫不是在做什么，而是在如何做的问题。有什么问题吗？

All right. Well, let's make the cat more cat-like and do this. Let me throw away all the say block and just let go there. And let me introduce at bottom left a nice feature of scratch whereby there's also these extensions that tend to use the cloud, the internet, to give you even more functionality. And in fact, I'm going to click on this extension up here, text to speech. And if I click on that, I suddenly get a whole new category of blocks at the bottom. Text to speech. They happen to be green. 
好吧。那么，让我们让这只猫更像猫，这样做。让我扔掉所有的“说”块，就那么放手。让我在左下角介绍 Scratch 的一个很酷的功能，那就是还有一些扩展，它们倾向于使用云、互联网来给你提供更多的功能。实际上，我要点击这里这个扩展，文本到语音。如果我点击它，我突然在底部得到了一个全新的类别。文本到语音。它们碰巧是绿色的。

But what's nice here is that I can actually now have the cat say something audibly. So let me drag the speak block here instead of the say block. I don't want it to just say hello. Let me stop that. So let me go back under operators. Let me grab another join block, because I threw the other one away. Let me change apple to hello, space again. Let me go to sensing. Let me drag answer to banana again. And now let me hit the green flag and let me type in my name, D-A-V-I-D. And in a moment I'll hit enter and. 
但是这里很棒的是，我现在实际上可以让猫发出声音。所以让我把说话块拖到这里，而不是说块。我不想它只说“你好”。让我停下来。所以让我回到操作符下。让我抓另一个连接块，因为我把另一个扔掉了。让我把苹果换成“你好”，再空格一次。让我去感知。让我把回答拖到香蕉上。现在让我按绿色旗子，输入我的名字，D-A-V-I-D。过一会儿我会按回车键。

COMPUTER: Hello, David.   计算机：你好，大卫。

DAVID MALAN: All right. It's not exactly cat-like, but it was synthesized. But it turns out under these text to speech blocks, there are some others. Set voice to alto, for instance, seems to be the default. But let's change this. So notice that some puzzle pieces don't just take white ovals. They might even have drop downs. 
大卫·马尔安：好吧。这并不完全像猫，但它已经被合成了。但是，在这些文本到语音块中，还有一些其他的。例如，将声音设置为 alto，这似乎是默认的。但让我们改变一下。注意，一些拼图块不仅仅接受白色椭圆形。它们甚至可能有下拉菜单。

So whoever created that puzzle piece decided in advance what the available choices are for that input per the dropdown. So I'm going to change it to squeak, which sounds-- or actually kitten sounds even more apt. Let me zoom out, click the green flag, type my name. D-A-V-I-D. Enter. 
所以 whoever created that puzzle piece decided in advance what the available choices are for that input per the dropdown. So I'm going to change it to squeak, which sounds-- or actually kitten sounds even more apt. Let me zoom out, click the green flag, type my name. D-A-V-I-D. Enter.

COMPUTER: Meow, meow.   计算机：喵喵喵。

DAVID MALAN: That's interesting. So it doesn't seem to matter what I type. So how about David Malan. 
大卫·马尔安：这很有趣。所以似乎我输入的任何内容都不重要。那大卫·马尔安怎么样？

COMPUTER: Meow, meow, meow. 
计算机：喵喵喵喵喵。

DAVID MALAN: So it seems to meow proportional to how long the phrase is that I typed in. It can get a little creepy quickly. If I change kitten to giant. Let me go ahead and hit Play. D-A-V-I-D. Enter. 
大卫·马尔安：在我看来，喵喵的次数似乎与我所输入的短语长度成正比。这可能会很快变得有点令人毛骨悚然。如果我将小猫改为巨人。让我先按播放。D-A-V-I-D。回车。

COMPUTER: Hello, David.   计算机：你好，大卫。

DAVID MALAN: So you can, for very non-academic ways, start to have fun with this, but just playing around with these various inputs and outputs. But let's actually make the cat do something more cat-like and indeed meow instead of saying any words at all. So let me throw all of that away. Let me go now under sound. 
大卫·马拉恩：所以，你可以以非常非学术的方式开始享受这个过程，只是随意尝试这些各种输入和输出。但是，让我们实际上让这只猫做点更像猫的事情，确实发出喵喵声，而不是说任何话。所以，让我把所有这些都扔掉。现在让我进入声音部分。

Let me drag the play sound until done. And notice in the dropdown here, by default, you just get the cat sound. You can record your own sounds. There's a whole library of dogs and birds and all sorts of sounds you can import into the program. I'll keep it simple with cat. And let me click the green flag. 
让我拖动播放声音直到完成。注意在这里的下拉菜单中，默认情况下，你只能得到猫叫声。你可以录制自己的声音。这里有一个完整的狗、鸟和各种声音库，你可以将其导入程序中。我会用猫叫声来保持简单。然后让我点击绿色标志。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: All right. So the cat meowed once. If I want the cat to meow again, I could do this. 
大卫·马尔安：好的。所以猫喵了一声。如果我想让猫再喵一声，我可以这样做。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: If I want the cat to meow a third time, I could again hit play. 
大卫·马尔安：如果我想让猫再喵第三次，我再次点击播放。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: So this is kind of tedious if to play this game, I have to keep clicking the button, keep clicking the button to keep the cat alive virtually in this way. So maybe I want this to happen again and again and again. Well, let me just do that. Let me sort of drag and drop. Or I could right click or Control click and then a little menu would let me Copy-Paste or duplicate blocks. But I'll just keep dragging and dropping. Let's do this. 
大卫·马兰：所以玩这个游戏有点麻烦，我得一直点击按钮，一直点击按钮来虚拟地保持这只猫活着。也许我想让它一遍又一遍地发生。好吧，让我试试拖放。或者我可以右键点击或按住 Ctrl 点击，然后一个小菜单会让我复制粘贴或复制块。但我只是会一直拖放。让我们试试。

COMPUTER: Meow. Meow. Meow. 
计算机：喵喵喵喵。

DAVID MALAN: Cat's kind of hungry, unhappy. So let's slow things down so it's adorable again. So let me go under control. Let me grab one of those wait one second, and I'll plop this here. Another one. Let me plop it here. Click play again. 
大卫·马兰：猫有点饿了，不开心。让我们放慢速度，让它再次变得可爱。所以让我去控制一下。让我抓起那个等待一秒，然后把它放在这里。再来一个。让我把它放在这里。再次点击播放。

COMPUTER: Meow. Meow.   计算机：喵喵喵。

DAVID MALAN: Cuter. Less hungry. Sure. But this program is now, I daresay, correct if my goal is to get the cat's meow three times. But now, even if you've never programmed before, critique this program. It is not well-designed, even though it is correct. In other words, it could be better. How, might you think? Yeah? 
大卫·马尔安：更可爱。不那么饿。当然。但据我所知，如果目标是让猫叫三次，那么这个程序现在是正确的。但现在，即使你从未编程过，也来批评一下这个程序。尽管它是正确的，但设计得并不好。换句话说，它可以更好。你怎么看？嗯？

AUDIENCE: A loop.   观众：一个循环。

DAVID MALAN: So using a loop. And why? Why are you encouraging me to use a loop even though it works as is? 
大卫·马兰：所以使用循环。为什么？为什么你鼓励我使用循环，尽管它现在这样也能工作？

AUDIENCE: It's easier to plot. 
观众：更容易绘制。

DAVID MALAN: Yeah. So to summarize, it's just easier to use a loop because I could specify explicitly in one place how many times I want it to loop. And moreover, frankly, any time you are copying and pasting something in code or dragging the same thing again and again, odds are you're doing something foolish. Why? Because you're repeating yourself unnecessarily. 
大卫·马尔安：是的。总结一下，使用循环更简单，因为我在一个地方就可以明确指定循环的次数。而且坦白说，每次你在代码中复制粘贴或者重复拖拽相同的内容，你很可能在做一件愚蠢的事情。为什么？因为你正在无谓地重复自己。

And this is a bit extreme, but suppose I want to change this program later so that the cat pauses two seconds in between meows. Well, obviously I can just go in here and do two. But what if I forget? And suppose this program isn't, like, five or six puzzle pieces. Suppose it's 50 or 60 or 500 or 600. Eventually I or a colleague I'm working with is going to screw up. 
这有点极端，但假设我以后想修改这个程序，让猫在喵喵叫之间暂停两秒钟。显然，我只需要在这里改为两秒即可。但如果我忘记了怎么办？而且假设这个程序不是像五六个拼图碎片那样简单。假设它是 50、60、500 或 600 个拼图碎片。最终，我或者我合作的同事很可能会出错。

They're going to change a value in one place, forget to change it in another. So why are you inviting the probability of making a mistake? Just simplify things so that you only have to change inputs in one place. So how can I do this? Let me zoom out. Let me throw most of this duplication away, leaving me with just the play and the wait function. 
他们会在一个地方更改一个值，却忘记在另一个地方更改。所以你为什么要邀请犯错的概率呢？简化一下，这样你只需要在一个地方更改输入。那么我该如何做到这一点呢？让我退一步，让我去掉大部分的重复代码，只留下播放和等待函数。

Let me now, under control as well, grab one of these. I could, for instance, repeat as follows. Let me grab a repeat. I'm going to have to move these in two parts. So I'm going to move this down. It's too small, but it will grow to fit the right shape. Then let me reattach it up here. Let me change the default 10 to a 3. And now I think I've done exactly what you were encouraging, which is simplify. And I click play now. 
让我现在，在控制之下，拿一个这样的。比如，我可以这样重复。让我重复一下。我必须分两部分移动这些。所以我将把它向下移动。它太小了，但它会变大以适应正确的形状。然后让我在这里重新连接它。让我把默认的 10 改为 3。现在我认为我已经做到了你鼓励的事情，那就是简化。然后我点击播放。

COMPUTER: Meow. Meow.   计算机：喵喵喵。

DAVID MALAN: Now and. 
大卫·马尔安：现在和。

COMPUTER: Meow.   计算机：喵喵喵。

DAVID MALAN: Yeah. So still correct, but arguably better designed as a result. I can keep things simple and change things now in just one place and it will continue to work. But this is getting a little tedious now, I claim. Like, why am I implementing the idea of meowing? Wouldn't MIT have been better to have just implemented a meow puzzle piece for us? Because the whole thing is themed around a cat. Why is there not a meow puzzle piece? Why do I need to go through all of this complexity to build that functionality? 
大卫·马尔安：是的，仍然正确，但可以说是设计得更好。我可以保持简单，现在只需在一个地方更改，它仍然会继续工作。但现在这有点令人厌烦了，我声称。比如，我为什么要实现喵喵叫的想法？麻省理工学院为什么不直接为我们实现一个喵喵谜题块呢？因为整个主题都是围绕猫的。为什么没有喵喵谜题块？我为什么要经历所有这些复杂性来构建这个功能？

Well, what's nice about Scratch and what's nice about programming languages in general is you can generally invent your own puzzle pieces, your own functions, and then use and reuse them. So let me go ahead and do this. I'm going to go under my blocks in pink down here. I'm going to go ahead and click make a block, and I'm going to be prompted with this interface here. And I'm going to call this block literally meow, because apparently MIT forgot to implement it for us. 
好吧，Scratch 和编程语言的一般优点是你通常可以发明自己的谜题块、自己的函数，然后使用和重用它们。所以让我先做这个。我要点击下面的粉色块，创建一个新块。我会把这个块命名为“喵喵”，因为显然麻省理工学院忘记为我们实现它了。

And I'm just going to go ahead and immediately click OK. And what you'll see now is two things. One, on the screen, I've been given this placeholder pink piece that says define meow as follows. So anything I attach to the bottom of that define block is going to define the meaning of meowing. And at top left, notice what I have under my blocks. I now have a pink puzzle piece called meow that is a new function that will do whatever that other block of code tells the cat to do. 
我将立即点击确定。现在您会看到两件事。一是屏幕上，我得到了一个表示“定义如下”的占位符粉色块。所以，我附加到那个“定义”块底部的任何内容都将定义喵喵声的含义。二是注意我块的最左上角。现在我有一个名为“meow”的粉色拼图块，这是一个新功能，将执行其他代码块告诉猫做的任何事情。

So what do I want to do here? Well, I'm going to keep it simple for now. I'm going to move the play sound meow until done and wait two seconds. Though let's change it back to one second to move things along. And now let me drag the meow puzzle piece over to my loop such that now, what's it going to do? It's going to meow three times. And just to be dramatic, out of sight, out of mind. 
那么，我这里想做什么呢？好吧，我现在先保持简单。我将移动“播放声音 meow”直到完成，并等待两秒钟。不过，让我们将其改为一秒钟以加快进度。现在，让我把“meow”拼图块拖到我的循环中，那么现在它会做什么呢？它会喵喵叫三次。为了更戏剧化，眼不见为净。

Let me, for no technical reason, just drag this all the way to the bottom of the screen and then scroll back up just to make the point visually that now meowing exists. That is an implementation detail that we can abstract away, not caring how it exists, because I now know at a higher conceptual level, if I want a meow, I just use the meow puzzle piece, and I or someone else dealt with already how to implement meowing. So now let me go ahead and hit play. 
让我没有技术原因，只是把这个东西拖到屏幕底部，然后再滚动回来，只是为了在视觉上说明现在有喵喵声存在。这是一个我们可以抽象出来的实现细节，我们不在乎它是如何存在的，因为现在我知道在更高的概念层面上，如果我想有喵喵声，我只需要使用喵喵拼图块，我已经处理了如何实现喵喵声的问题。所以现在让我先播放一下。

COMPUTER: Meow. Meow. Meow. 
计算机：喵喵喵喵。

DAVID MALAN: OK, so same exact code, but arguably better design because I've now given myself reusable code so I don't have to Copy-Paste those several blocks. I can just use meow again and again. But let's make one refinement. Let me actually scroll down to where I did in fact implement this. Let me Control click or right click on it and let me edit the pink block that I created a moment ago, because I want to practice what I've been preaching about inputs. 
大卫·马尔安：好的，所以代码完全一样，但可以说是更好的设计，因为我现在给自己提供了可重用的代码，所以我不用复制粘贴那些几个块。我可以反复使用喵喵。但让我们做一个改进。让我实际滚动到刚才我实现的地方。让我按住 Ctrl 点击或右键点击它，然后编辑我刚才创建的粉红色块，因为我想要练习我一直在宣扬的输入。

So I don't want this function just to be called meow. I want this function to also take an input, and just for consistency with our use of n earlier, which in computer science generally means number, let me meow n times. And just so that this puzzle piece is even more programmer friendly, let me add just a textual label that has no technical significance other than to make this function read left to right in a more English friendly way. Meow n times. 
因此，我不想这个函数仅仅被称作“喵”。我希望这个函数还能接受输入，并且为了与之前我们使用的“n”保持一致性，在计算机科学中通常表示数字，让我“喵”n 次。为了让这个编程难题更加友好，我还可以添加一个没有技术意义的文本标签，只是为了使这个函数的阅读方式更符合英语习惯。喵 n 次。

Let me click OK. And now notice this thing at the bottom has changed such that it's not only called meow, there's explicit mention of n, which is a circle, which is exactly the variable shape that we saw earlier when it was called answer. This is not a return value, though. This is what, again, we're going to call an argument, an input to a function. So let me do this. 
让我点击“确定”。现在注意底部的内容已经改变，不再只是“喵”，而是明确提到了 n，这是一个圆圈，这与我们之前看到的当它被称作“answer”时的变量形状完全一致。但这不是一个返回值。这又是一个我们将要称作“参数”，即函数的输入。所以让我这样做。

I'm going to move this back up to the top so I can see everything in one place, and I'm going to make one modification, because my goal now is to make a new and improved version of meowing that actually takes into account how many times I want the cat to meow. So instead of using a loop in my own program under when green flag clicked, I'm going to detach this temporarily. I'm going to move this away. I'm going to move this code over here, and I'm going to reattach it here. 
我要去把这个东西移到顶部，这样我就能在一个地方看到所有内容，并且我要进行一个修改，因为现在的目标是制作一个新改进的喵喵版本，这个版本会真正考虑到我想让猫叫多少次。所以，我不再在我的程序中使用当绿色标志被点击时的循环，我将暂时断开这个连接。我要把这个东西移开。我要把这个代码移到这边，然后再重新连接到这里。

So focusing for the moment on just the left, meow is now defined as repeating three times the following two functions. Play sound and wait. But that's not quite right. I want to get rid of the three. So what can I do? Because I created this input to the meow function myself a moment ago, I can actually drag a copy of it over right that is change the three to be generally an n. 
现在暂时专注于左边，喵喵被定义为重复三次以下两个函数：播放声音和等待。但这还不够准确。我想去掉这个三。我能做什么呢？因为刚才我自己创建了输入给喵喵函数，我实际上可以拖一个副本过来，把三改成一般性的 n。

So now I have a function called meow that will meow any number of times. And what's nice now is my actual program that is governed by that green flag, I can type in three, I can type in 10, I can type in 100, and it will just work. And henceforth, I can, again, dramatically scroll this down so we don't know or care about it anymore. Now my program is a single line whereby this notion of meowing has been abstracted away by just defining my own function or custom block. 
现在我有一个名为 meow 的函数，它可以重复 meow 任意次数。现在很棒的是，受绿色标志控制的实际程序，我可以输入 3，可以输入 10，可以输入 100，它都会正常工作。从今往后，我还可以再次大幅滚动它，这样我们就不再关心它了。现在我的程序只有一行，因为通过定义自己的函数或自定义块，我已经将 meowing 的概念抽象化了。

Questions, then, about just this idea, this principle of creating your own functions to hide implementation details once you've solved a problem? Therefore, you don't want to have to think about that same problem ever again. And that's the beauty of programming, typically. Questions on what here we just did? No? 
那么，关于这个想法，这个创建自己的函数来隐藏实现细节的原则有什么问题吗？一旦你解决了问题，你就不想再考虑同样的问题了。这就是编程的美妙之处。关于我们刚才做了什么，有什么问题吗？没有？

All right. Well, let's do this. Let's now make this a little more interactive in code. Let me go to this green flag. Let me scroll down and just throw all of this hard work away that we have copies on the courses website of all of these programs step by step if you want to review them in slower detail. Let's do this. Under control, turns out there's other ways to loop. There's this forever block that will just do something forever. So in the forever block, there's some place for some other code. 
好吧。嗯，让我们来做这件事。现在让我们在代码中让它变得更加互动。让我去这个绿色的标志。让我向下滚动，然后把我们在课程网站上所有这些程序的复制品都扔掉，如果你想要更慢地详细查看它们的话。让我们来做这件事。在控制之下，结果还有其他循环的方法。有一个会永远执行的“永远”块。所以在“永远”块中，有一些其他代码的地方。

And I'm going to move to the control section here and grab one of these if blocks, so one of these conditionals. Let's plug that in here. And now notice if, and then there's this sort of trapezoid-like placeholder that's going to probably fit what? The if is a conditional. Forever is a loop. Say and so forth have been functions. What was the other key term we used? 
我要移动到控制部分，并抓取其中一个这些“if”块，也就是这些条件之一。让我们把它插在这里。现在注意，if，然后这里有一个类似梯形的地方，可能会适合什么？if 是一个条件。永远是一个循环。说和等等是函数。我们刚才用的另一个关键术语是什么？

So a Boolean expression. We need to put one of those yes, no or true, false questions here. So what are those? Well, I've been using Scratch for some years, so I under sensing there's one of these shapes here. Touching mouse pointer, question mark. The question mark literally evokes the whole idea of a Boolean expression being yes, no. It's way too big to fit, but it is the right shape. 
所以这是一个布尔表达式。我们需要在这里放置一个这样的“是”、“否”或“真”、“假”问题。那么这些是什么？嗯，我已经使用 Scratch 有几年了，所以我明白这里有一个这样的形状。触摸鼠标指针，问号。问号字面意义上唤起了布尔表达式是“是”或“否”的整体概念。它太大，无法容纳，但它确实是正确的形状。

So let me drag it. Let go. It's going to grow to fill. And now let me go to sound. Let me grab that play sound, meow until done, and put it inside that conditional such that what kind of program have I just implemented here, arguably? What will this program do when I click the green flag? Well, nothing at the moment. 
那么让我拖动它。放手。它会扩展以填充。现在让我去声音。让我抓住那个播放声音，喵喵叫直到完成，并将其放入条件中，这样我刚刚实现了什么样的程序，可以说是？当我点击绿色旗帜时，这个程序会做什么？目前什么都不会。

AUDIENCE: Not touching the cat. 
观众：没有触摸猫。

DAVID MALAN: But I'm not touching the cat. So if I move the mouse pointer to the cat. 
大卫·马尔安：我没有触摸猫。所以如果我将鼠标指针移到猫上。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: Again.   大卫·马尔兰：再来一次。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: Again.   大卫·马尔安：又是这样。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: It's kind of implementing the idea of petting a cat, if you will, because I'm forever just waiting and waiting and waiting. Is the mouse pointer touching that sprite, touching that cat? And only if so, go ahead and play that sound meow until done. But now we can make things a little more interesting. Let me stop this and let me do something actually completely different. 
大卫·马尔安：这有点像是抚摸猫的感觉，如果你愿意的话，因为我一直在等待，等待，再等待。鼠标指针是否触碰到那个精灵，触碰到那只猫？只有在这种情况下，才继续播放那只猫的叫声。但现在我们可以让事情变得更有趣。让我停下来，做一些完全不同的事情。

Let me throw all this hard work away. Let me go under extensions. Let me go to video sensing, because lots of laptops, my own included, has a little webcam nowadays. Let me approve use of that there. And you can see me in the frame. And let me do this. Let me drag one of these when motion exceeds some measure. And through trial and error, I figured out that 50 tends to work well. Let me step out of frame here and program off to the side. 
让我把所有的努力都扔掉。让我进入扩展模式。让我去视频感应，因为现在很多笔记本电脑，包括我的，都配备了一个小摄像头。让我批准使用那个摄像头。你可以在画面中看到我。让我这样做。当运动超过某个阈值时，让我拖动其中一个。通过试错，我发现 50 通常效果不错。让我离开画面，把程序放在旁边。

And if I go to play sound meow until done, notice that this is an alternative to using when green flag clicked. This is a category of block that's constantly waiting for what we'll call an event. An event is just something that can happen on the screen, a click, a drag, a mouse movement, and so forth. So let me zoom out here. And now, if I can do this-- here we go. No, too slow. Still too slow. Wait, did I click play? Let's see. Try again. 
如果我去播放声音喵直到完成，注意这实际上是使用绿色标志点击时的一个替代方案。这是一个不断等待我们称之为事件的块的类别。事件只是屏幕上可能发生的事情，比如点击、拖动、鼠标移动等等。所以让我缩小一下这里。现在，如果我能够这样做——这里我们走。不，太慢了。仍然太慢。等等，我点击播放了吗？让我们看看。再试一次。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: There we go. OK. 50 is a little too high, apparently. So let's make this a little gentler. 10. 
大卫·马尔安：我们做到了。好吧。50 似乎有点太高了。所以我们让它变得温和一些。10。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: OK, well. 
大卫·马尔安：好吧。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: There we go. 
大卫·马尔安：就这样。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: There we go. 
大卫·马尔安：我们做到了。

COMPUTER: Meow.   计算机：喵喵。

DAVID MALAN: OK, so we've implemented now more physically the idea of actually responding to petting a cat. 
大卫·马尔安：好的，所以我们现在更实际地实现了对抚摸猫的响应。

COMPUTER: Meow. Meow.   计算机：喵喵喵。

DAVID MALAN: Oh, damn it. OK. 
大卫·马尔安：哦，该死。好吧。

COMPUTER: Meow. Meow. Meow. 
计算机：喵喵喵。

DAVID MALAN: All right. So this is a bug. Like now-- this is MIT's fault. So it's not stopping in response to the red stop sign. So what do you do in doubt? Most extreme, you reboot. For now, I'm just going to close the window. OK. So now we've seen all of those primitives that we saw in that pseudocode, but incarnated in this graphical programming language, and again, without parentheses and semicolons and double quotes and all that punctuation that we will introduce before long. 
大卫·马尔安：好吧。这是一个错误。就像现在——这是麻省理工学院的错。所以它没有在红灯停下来。那么在怀疑的时候你会怎么做？最极端的做法，就是重启。现在，我只是要关闭这个窗口。好的。所以现在我们已经看到了那些在伪代码中看到的那些原语，但在这里以图形编程语言的形式呈现，而且，又没有括号、分号、双引号以及所有那些我们很快就会引入的标点符号。

But for now, we have the mechanisms in place where we can do some really interesting things. So in fact, I thought, in the spirit of thinking back on olden times, thought I'd open up the very first program I wrote when I actually took-- I was cross-registered in an MIT class and took a class that introduced aspiring teachers to Scratch. 
但现在，我们已经有了可以做一些非常有趣的事情的机制。所以实际上，我想到，在回顾过去的精神下，我想打开我第一次编写的程序，当时我实际上是在麻省理工学院的一个课程中跨专业注册，并参加了一个介绍 Scratch 的入门课程。

And I implemented this program here called Oscartime, which was a game that used a childhood song that I was a fan of and it allows you to drag trash into a trash can. But to bring this to life and perhaps in exchange for one stress ball, could I get one brave volunteer who wants to come up and control this here keyboard? I saw your hand first. Come on up. Come on up. And you'll see, thanks to the team, we also have this amazing lamppost here, being on Quincy Street as we are. Do you want to introduce yourself to the group? 
我在这里实现了一个名为 Oscartime 的程序，这是一个游戏，它使用了我喜欢的童年歌曲，并允许你将垃圾拖到垃圾桶里。但是为了使这个游戏变得生动，也许为了换取一个减压球，我能得到一位勇敢的志愿者上来控制这里的键盘吗？我看到你的手先举起来了。来吧，来吧。你会看到的，多亏了团队，我们这里还有这个神奇的街灯柱，就在我们所在的昆西街上。你想要向小组介绍一下自己吗？

AUDIENCE: Hi, my name is Anna. I'm from Richmond, Virginia, and I'm in Weld. 
观众：嗨，我叫安娜。我来自弗吉尼亚州的里士满，我在焊接。

DAVID MALAN: Nice. Weld. 
大卫·马尔安：好。焊接。

AUDIENCE: Yes!   观众：是的！

DAVID MALAN: All right, come on over. So here, Anna, you'll have a chance to play the very first game I wrote in Scratch, which admittedly is more complicated typically than we would expect of a student doing this for the very first time, as in problem set zero. But what I'm going to do is full screen this here. I'm going to click the green flag, and what you'll see on the screen are these instructions. Drag as much falling trash as you can to Oscar's trashcan before his song ends. And here we go. 
大卫·马尔兰：好的，过来一下。在这里，安娜，你将有机会玩我写的第一个 Scratch 游戏，这个游戏承认地比我们通常期望的学生第一次做这个问题的零号问题集要复杂。但我将要全屏显示这个。我要点击绿色标志，你会在屏幕上看到这些指示。在奥斯卡的歌声结束之前，尽可能多地拖动掉落的垃圾到奥斯卡的垃圾桶里。我们开始吧。

[OSCAR THE GROUCH, "I LOVE TRASH"] 
[奥斯卡，"我爱垃圾"]

Oh, I love trash 
哦，我爱垃圾

Anything dirty or dingy or dusty 
任何脏的、灰暗的或灰尘的

Anything ragged or rotten or rusty 
任何破旧、腐烂或生锈的东西

Yes, I love trash 
是的，我喜欢垃圾

DAVID MALAN: There we go. So as Anna continues to play, let's tease this apart a little bit. So one, there's some costumes on the stage. Like that lamppost is actually never going to move. But there's a couple of sprites. There's the trash can, which seems to be a character unto itself. There's this piece of trash that keeps coming back and back. That is a sprite. There's now this sneaker, which is another sprite. And in fact, notice that Oscar, of course, keeps popping up from his sprite once in a while. 
大卫·马尔兰：就这样。当安娜继续玩耍时，让我们稍微分析一下。首先，舞台上有一些服装。比如那个路灯实际上永远不会移动。但是有几个精灵。有一个垃圾桶，它似乎是一个角色本身。有一块垃圾一直在来回出现。这是一个精灵。现在还有一双运动鞋，这也是一个精灵。实际上，注意奥斯卡，当然，偶尔会从他的精灵中冒出来。

So Oscar seems to have multiple costumes. So I offer this as an example, as you keep playing, if you would. Very good job so far. The song goes on forever. This was a nightmare to implement, to listen to this all day long. But how do we implement the rest of this? Well, notice that the trash, every time she throws into the trash can, does reappear somewhere different. 
奥斯卡似乎有多个服装。所以我提供这个作为例子，如果你继续玩的话。到目前为止做得很好。这首歌永远都唱不完。实现这个是一个噩梦，整天听这首歌。但我们如何实现剩下的部分呢？注意，每次她把垃圾扔进垃圾桶，它都会在不同的地方重新出现。

So there's some kind of randomness involved. And indeed, Scratch will let you pick random numbers in a range. So maybe it could be negative 240, maybe it could be positive 240, at the 180 point on the top of the screen. So you can randomly put things on the screen. There's apparently what kind of construct that makes the trash fall again and again. I think no one's listening to me. They're all just watching you. 
因此，这里涉及某种随机性。确实，Scratch 允许你在一定范围内选择随机数。所以它可能是负 240，也可能是正 240，在屏幕顶部的 180 点处。你可以在屏幕上随机放置东西。显然，有一种构造可以让垃圾不断掉落。我觉得没有人听我说话。他们都在看着你。

What's making the trash fall from top to bottom? So it's actually some kind of loop because there's a motion block inside of a forever loop, probably, that just keeps moving the trash one pixel, one pixel, one pixel, one pixel, one pixel, creating the illusion, therefore, of motion. And if we can crank the song a little bit more, you'll see that this is all synchronized now. 
是什么让垃圾从顶部掉落到底部？实际上，这应该是一个循环，因为有一个运动积木在无限循环中，可能就是这样，它只是不断移动垃圾一个像素、一个像素、一个像素、一个像素、一个像素，从而产生运动的错觉。如果我们把歌曲的节奏再加快一点，你会发现现在这一切都是同步的。

OSCAR THE GROUCH: (SINGING) Because they're trash 
奥斯卡·格鲁奇：（唱歌）因为它们是垃圾

Oh, I love trash 
哦，我喜欢垃圾

Anything dirty or dingy or dusty 
任何脏的、灰暗的或灰尘的

Anything ragged--   任何破旧的--

DAVID MALAN: The song keeps going forever, seemingly. And now notice more and more sprites are appearing because they waited for-- here we go. Climax. 
大卫·马兰：这首歌似乎永远在继续。现在注意，越来越多的精灵出现了，因为它们一直在等待——我们来了。高潮。

OSCAR THE GROUCH: (SINGING) I love trash 
奥斯卡恶搞者：（唱歌）我喜欢垃圾

DAVID MALAN: All right. A big round of applause for Anna. Nicely done. OK, here you go. Here you go. All right. So this is an interminable song. And indeed, I spent hours building that, and just listening to that song on loop was not the best way to program. But the goal here is to really use it as just an intellectual exercise as to how that was implemented. And we won't do the entire thing in detail, because I will say back in the day when I was younger, I didn't necessarily write the cleanest code. 
大卫·马兰：好吧。为安娜鼓掌。做得好。好的，给你。给你。好吧。这是一首永无止境的歌。确实，我花了好几个小时来制作这首歌，而且反复听这首歌并不是编程的最佳方式。但这里的目的是真正地将其用作一个智力练习，看看它是如何实现的。我们不会详细讲解整个过程，因为我会说我年轻的时候，我并不一定写出了最干净的代码。

And in fact, if we see inside this and we poke around the bottom of the screen here, you can see all of my different sprites. And the code is kind of complex. Like, things just kind of escalated quickly. But I did not set out and write all of these programs all at once for each sprite. I pretty much took baby steps, so to speak. And so, for instance, let me open up just a few sample building blocks here that speak to this that are written in advance. 
事实上，如果我们查看这个并在这个屏幕底部附近探索，你可以看到我所有的不同精灵。代码有点复杂。就像事情迅速升级一样。但我并没有一开始就为每个精灵编写所有这些程序。我基本上是逐步进行的，所以比如说，让我打开一些预先编写的样本积木，这些积木与这个相关。

So here's version zero. Computer scientists typically start counting at zero. And let me show you this example here that only has two sprites on the screen. We have Oscar the trashcan and we have the piece of trash. And now notice, what does Oscar do? Well, let me go ahead and zoom in on this script, as it's called. A program is a script. When the green flag is clicked, Oscar switches his costume to Oscar one. That's his default costume where the lid is closed. 
那么，这是版本零。计算机科学家通常从零开始计数。让我给你展示一个例子，这里屏幕上只有两个精灵。我们有奥斯卡垃圾桶和那块垃圾。现在注意，奥斯卡会做什么？好吧，让我先放大这个脚本，因为它被称为。程序就是脚本。当绿色旗帜被点击时，奥斯卡会切换到奥斯卡一。这是他默认的服装，盖子是关闭的。

Then Oscar does this forever. If Oscar is touching the mouse pointer, change the costume to Oscar two, otherwise change it back to Oscar one. So that whole idea of animation where Oscar is popping in and out is just like a quick costume change based on a loop inside of which is a conditional waiting for the cursor, like Anna did, to get near the trash can. 
然后，奥斯卡会一直这样做。如果奥斯卡接触到鼠标指针，就切换到奥斯卡二，否则切换回奥斯卡一。所以奥斯卡在屏幕上跳进跳出的动画效果，就像是一个基于循环的快速服装变化，循环内部有一个条件等待光标靠近垃圾桶，就像安娜做的那样。

Meanwhile, if we look at the piece of trash here, notice that the trash is actually not doing anything in this first version because I didn't even implement falling first. So let me hit the green flag. Nothing is happening in this very first version. But notice, if I click on the trash and drag as soon as I'm touching Oscar, there comes that trash can lid. And it was just the result of making this one program respond to that input. All right. What did I do next? 
同时，如果我们看看这里的垃圾，会发现在这个第一个版本中，垃圾实际上什么都没做，因为我甚至还没有实现下落功能。所以让我点击绿色标志。在这个非常第一个版本中，什么都没有发生。但是请注意，如果我点击垃圾并拖动，当我接触到奥斯卡时，就会出现垃圾箱盖。这只是让这个程序对那个输入做出反应的结果。好吧。接下来我做了什么？

Well, next, after taking that single baby step, I added one other feature. Let's see inside this version one. Again, Oscar is behaving the exact same way. But notice this time the trash is designed to do the following. First, I'm telling the program that the drag mode is draggable. That is, I want the trash to be movable when the user clicks on it. Then I tell the piece of trash to go to a random x location. x is the horizontal, so it's going somewhere between 0 and 240, but all the way at the top of the screen. 180. 
好的，接下来，在迈出这一小步之后，我又添加了一个新功能。让我们看看这个版本一。奥斯卡的行为方式和之前完全一样。但请注意，这次垃圾被设计成以下功能。首先，我告诉程序拖动模式是可拖动的。也就是说，我想在用户点击时让垃圾可移动。然后我告诉这块垃圾随机移动到 x 坐标位置。x 是水平坐标，所以它在屏幕的 0 到 240 之间，但一直位于屏幕顶部。180。

Then forever, the piece of trash just changes by negative one. So it just moves down and down and down. And without looking at the second script yet, let me just hit play. And notice, without even doing anything-- and eventually, once there was lots of trash falling, like Anna was struggling to keep up with this. It's just moving one pixel at a time forever until, thankfully, MIT does stop things automatically if they hit the bottom, lest a six-year-old get upset that all of a sudden their sprite is gone forever. 
永远如此，这块垃圾只是减少一个单位。所以它只是不断地向下移动。即使还没有看第二个脚本，我也先播放一下。注意，即使什么都没做——最终，当垃圾掉落得越来越多时，就像安娜一样，她努力跟上这个节奏。它只是每次移动一个像素，永远如此，直到幸运的是，如果它们触碰到底部，麻省理工学院会自动停止，以免一个六岁的孩子突然发现他们的精灵永远消失了而感到沮丧。

So there is some special casing there. But what else is this trash doing? Let me zoom in here. The piece of trash also, when the green flag is clicked, is forever asking this question. If you are touching Oscar, then pick a new random location between 0 and 240 at positive 180 and go back to the top. So in other words, as soon as this piece of trash is dragged over to Oscar like this and I let go, it recreates itself at the top. It's just sort of teleporting to the top, and thus was born this feature. 
所以这里有一些特殊处理。但是这块垃圾还在做什么呢？让我放大一下。这块垃圾在点击绿色标志后，会永远提出这个问题。如果你触碰到奥斯卡，那么就在 0 到 240 之间随机选择一个位置，向上移动到 180，然后回到顶部。换句话说，当这块垃圾被拖动到奥斯卡这里，我放手后，它就会在顶部重新创建自己。它就像是在瞬间传送到顶部，于是这个功能就这样诞生了。

And I won't slog through all of the individual features here, but if we do just one more and see inside this one-- so now let me go ahead and hit Play. Notice at the top left of the screen, there's a score. Currently zero. But now when I click the trash and let go, notice that the score is being incremented by one. And this, in fact, is how, Anna, your score kept going higher and higher and higher. 
并且我不会在这里详细说明所有单个功能，但如果我们再进行一个操作并查看这个功能——现在让我先点击播放。注意屏幕左上角有一个分数。目前是零。但现在当我点击垃圾桶并松开时，注意分数正在增加一。实际上，安娜，你的分数就是这样一直持续上升。

Every time I noticed, oh, the trash is touching Oscar, let's not only teleport, let's also increment a variable. And we didn't see this before, but if I go to this Oscar Scratch now, you'll see that it is exactly the same. But if I now go to the trash piece here and we go to when green flag clicked, you'll see that I'm initializing a variable in orange called score to zero. But if we scroll down to the bottom, Oscar is also doing another thing in parallel at the same time. 
每次我注意到，哦，垃圾接触到了奥斯卡，我们不仅要传送，还要增加一个变量。我们之前没有看到这一点，但如果我现在去这个奥斯卡 Scratch，你会看到它确实是这样的。但如果我现在去这里的垃圾块，我们回到绿旗点击时，你会看到我在橙色中初始化了一个名为 score 的变量，其值为零。但如果我们滚动到页面底部，奥斯卡同时还在做另一件事。

When the green flag is clicked, Oscar is forever checking, is the piece of trash touching Oscar? If so, change the score by one and then go to top, which is another location on there, that screen. So in other words, even though at a glance something like Oscar time might look very complicated and it did take me hours, the goal, especially with problem set zero, is not going to be to bite off all of that at once, but to take proverbial baby steps. Implement one tiny feature so that you feel like you're making progress. 
当绿色旗帜被点击时，奥斯卡会永远检查，那块垃圾是否触碰到奥斯卡？如果是，则增加一分，然后回到屏幕上的顶部，那里是另一个位置。换句话说，尽管乍一看奥斯卡时间可能看起来非常复杂，而且确实花了我几个小时，但特别是对于零号问题集，目标不是一次咬下所有东西，而是要采取比喻性的小步骤。实现一个微小的功能，让你感觉自己在进步。

Add another feature, another. And invariably you might run out of time and not get to the best version of your vision, but hopefully it'll be good. Hopefully it'll be better, but you'll have these sort of mental milestones, hoping that you at least get to that point. Because as you will soon discover, everything in the world of programming unfortunately takes longer than you might expect. That was true for me 25 years ago and is still true today. Well, let me introduce one final set of examples here. 
添加另一个功能，再添加一个。不可避免的是，你可能会用完时间，无法达到你最好的愿景，但希望它会很好。希望它会更好，但你会有这些心理里程碑，希望至少能达到那个点。因为很快你就会发现，世界上所有关于编程的事情，不幸的是，都会比你预期的花费更长的时间。这在 25 年前对我来说是真的，现在仍然是。好吧，让我在这里介绍最后一组示例。

This one written by one of your own predecessors, a former student. Let me go ahead and open up three baby steps, if you will, toward an end of implementing a game called Ivy's Hardest Game, whereby it's now more interactive, quite like Oscartime. So at top right here, notice-- and I'll zoom in-- we have this world that's initially very simple. Two black lines, two walls, if you will, and a Harvard sprite in the middle. But when you click the green flag, notice that nothing happens initially except that the sprite jumps to the middle. 
这一段是由你的前辈之一，一位前学生所写。让我先迈出三个小步骤，如果你愿意的话，朝着实现一个名为 Ivy's Hardest Game 的游戏迈进，使其更加互动，就像 Oscartime 一样。注意右上角这里——我会放大——我们有一个最初非常简单的世界。两条黑色线条，就像两面墙，中间有一个哈佛精灵。但是当你点击绿色旗帜时，注意最初什么也没有发生，除了精灵跳到了中间。

But I can hit the up key or the down key or the left key or the right key. But if I try to go too far, even though it's not the edge of the world, it's only touching that there black line, it's still going to stop as well. So intuitively, how could you implement that type of program? How could you get a sprite from what we've seen to respond to up, down, left, right, but actually move when I touch my arrow keys? Like, what does it mean to move? Yeah? 
但我可以按上键、下键、左键或右键。但如果我走得太远，即使不是世界的边缘，只是接触到那条黑色线条，它也会停下来。所以直观地来说，你该如何实现这样的程序？如何让精灵从我们所看到的能够响应上、下、左、右键，但实际上当我按下箭头键时才会移动？比如，移动是什么意思？是的？

AUDIENCE: Maybe if then. 
观众：也许如果那么。

DAVID MALAN: Exactly. So much like with representing information, at the end of the day, all we've got is zeros and ones. When it comes to algorithms, at the moment, all we have are functions and loops and conditionals and Boolean expressions and soon some more things too. But there's not all that much we have at our disposal. So let me zoom out from this and let me actually show you what the Harvard sprite is doing. It's doing this. 
大卫·马尔安：没错。就像表示信息一样，最终我们只有 0 和 1。至于算法，目前我们只有函数、循环、条件语句和布尔表达式，很快还会有些其他的东西。但我们能利用的资源并不多。所以让我从这一点上退一步，实际上展示一下哈佛精灵正在做什么。它正在这样做。

When I go up to the green flag here, the Harvard sprite is going to 0, 0. So dead center in the middle. And then it's forever doing two things, listening for the keyboard and feeling for walls, left and right. Now, those are not puzzle pieces that come with Scratch. I created my own custom blocks, my own functions to implement those ideas. Let's not abstract away for now. Let's actually look at these features. And indeed, to your instincts at left here, what does it mean to listen for the keyboard? 
当我点击这里的绿色标志时，哈佛精灵会移动到 0,0 的位置。也就是正中间。然后它会永远做两件事，监听键盘和感知墙壁，左右两侧。这些并不是 Scratch 自带的拼图块。我创建了自定义的积木，自定义的函数来实现这些想法。现在我们先不抽象，让我们实际看看这些功能。确实，根据你的直觉，在这里监听键盘是什么意思？

Well, if the up arrow key is pressed, change y by one. Move up. If the down arrow key is pressed, change y by negative one. If the right arrow key is pressed, change x by one. If the left arrow key is pressed, change x by negative one. So take all the magic out of moving up, down, left, right by just quantizing it as plus, minus, this, and that. It's all numbers, indeed, at the end of the day. But what else is it doing? Notice that it did, indeed, bounce off the wall. 
好吧，如果按下上箭头键，y 坐标增加一。向上移动。如果按下下箭头键，y 坐标减少一。如果按下右箭头键，x 坐标增加一。如果按下左箭头键，x 坐标减少一。所以，将上下左右移动的魔法简化为加减，这全是数字，毕竟到最后。但是它还在做什么呢？注意，它确实反弹了墙壁。

So my other custom function, which I chose, feel for walls to evoke this idea, it's asking two questions. If you're touching the left wall, then change x by one, so bounce in the other direction. Else if you're touching the right wall, bounce in the negative one direction. And so what are left wall and right wall? I mean, I kind of cheated. I just used two more sprites. These sprites are literally nothing except black lines. 
所以我选择的另一个自定义函数，用来感受墙壁，它提出了两个问题。如果你触碰到左墙，那么 x 坐标增加一，所以向另一个方向反弹。否则，如果你触碰到右墙，向负一方向反弹。那么左右墙是什么意思呢？我的意思是，我有点作弊。我只是使用了两个额外的精灵。这些精灵实际上什么也没有，除了黑色线条。

But because they exist, I can ask that question in my conditional saying, are you touching those other sprites? And I could have colored them any way I want, but this is enough, if I zoom in, to implement this idea of going up, down, left, and right, and preventing the sprite from leaving that little world. All right. So if you'll agree that there's a way now to implement motion up, down, left, right, let's go ahead and implement this idea by adding a rival into the mix, like a Yale sprite. 
但是因为它们存在，我可以在条件语句中提出那个问题，你在触摸那些其他精灵吗？我本可以随意给它们上色，但这样已经足够了，如果我放大，就可以实现向上、向下、向左、向右移动的想法，并防止精灵离开那个小世界。好吧。所以如果你同意现在有办法实现上下左右移动，那我们就来实施这个想法，加入一个对手，比如耶鲁精灵。

And what the Yale sprite is going to do, if I click the green flag, is this. So Harvard at the moment is still going to be movable with the arrow keys, up, down, left, right. But Yale, for better or for worse, is just going to mindlessly bounce back and forth from left to right forever, it would seem. The operative word being forever. So how is that working? 
如果我点击绿色旗帜，耶鲁精灵将会这样做。所以哈佛目前仍然可以通过箭头键上下左右移动。但耶鲁，不管好坏，似乎会无意识地永远从左到右弹跳。关键词是永远。那么这是怎么工作的呢？

Well, let's look. Here's the Yale sprite at the bottom. Let's zoom in on its actual code here. The Yale sprite starts at 0, 0. It points in direction 90 degrees, which means left, right, essentially. And then it forever does this. If touching the left wall or touching the right wall, turn around 180 degrees. So I don't want the Yale sprite to just stop by moving it one pixel to bounce off slightly. I want it to wrap around and just keep going and going and going forever. 
好吧，让我们看看。这是底部的耶鲁精灵。让我们放大它的实际代码。耶鲁精灵从 0，0 开始。它指向 90 度方向，也就是向左，向右。然后它永远这样做。如果碰到左墙或右墙，就转 180 度。我不想让耶鲁精灵只是移动一个像素就停下来弹跳，我想让它绕着走，永远走下去。

And that's it. Everything else is the same. So one final flourish. Let's add a more formidable adversary, like MIT here, whereby if I zoom in and hit play, notice that if I move the Harvard sprite, MIT comes chasing me now. Now, how is this actually working? Yale is just kind of doing its thing, bouncing back and forth. Now MIT has really latched on to me and it's following me up, down, left, right. So how is that logic now working? 
就这样。其他一切都是一样的。所以最后来点精彩的东西。让我们添加一个更强大的对手，比如这里的麻省理工。如果我们放大并播放，注意如果移动哈佛精灵，麻省理工现在会追着我。那么这是怎么实现的呢？耶鲁只是做着自己的事情，来回弹跳。现在麻省理工真的跟上了我，它跟着我上下左右移动。那么现在的逻辑是怎么工作的呢？

Well, again, it's probably doing something forever, because that's why it's continually doing it. Let's click on MIT. This too is pretty simple, even though it's a pretty fancy idea. Initially the MIT sprite goes to a random position, but thereafter, it forever points toward the Harvard logo outline, which is just the long name that your predecessor or former student gave the name for that sprite. And then it moves one step, one step, one step. 
嗯，又是一次，它可能永远在做一些事情，因为这就是它不断做这件事的原因。让我们点击一下麻省理工。这个想法虽然很复杂，但也很简单。最初，麻省理工的精灵会随机移动到一个位置，但之后，它将永远指向哈佛标志的轮廓，这只是一个你的前辈或前学生为这个精灵起的名字。然后它移动一步，一步，再一步。

So suppose this were an actual game, and in games things get harder and harder, the adversary moves faster and faster. How could we make MIT even faster by changing just one thing here? Like, how do we level up? Change the one to two pixels at a time, two steps at a time. So let's see that. Let's go ahead and zoom out. Let's hit play. And now notice that MIT is coming in much faster this time. 
假设这是一个真正的游戏，在游戏中，事情会越来越难，对手会越来越快。我们如何通过改变这里的一件事来让麻省理工变得更快？比如，我们如何升级？将每次移动的像素数从一变为两，每次移动两步。让我们看看这个。让我们放大看看。让我们开始播放。现在注意，这次麻省理工来得更快了。

All right. So it wasn't noticeably faster. Let's do this. Let's move 10 steps at a time. So 10 steps faster than originally. I mean, now-- and now notice it's kind of twitching back and forth in this way. Why? Well, probably, if we worked out the math, probably the MIT sprite is touching the sprite and it's bouncing off of it, but then it's realizing, oh, I went too far. Let me move back. Wait a minute. I'm still touching it. Let me move down. So you can get into these perverse situations where there is actually a bug, be it logical or aesthetical. 
好吧。它并没有明显地更快。让我们一次移动 10 步。所以比原来快了 10 步。我的意思是，现在——现在它有点在来回抽搐。为什么？嗯，如果我们计算出数学，可能是因为 MIT 精灵触碰到精灵并弹开，然后意识到，哦，我走得太远了。让我退回来。等一下。我还在触碰到它。让我向下移动。所以你可能会遇到这些奇怪的情况，其中实际上存在一个错误，无论是逻辑上的还是美学上的。

But in this case, we probably want to fix that. So 10 is probably too fast for this to work particularly well. But the final flourish here really is to show you the actual version of a game that one of your predecessors, a past classmate, actually implemented. Before, thereafter, we will adjourn for cake in the transept, which is the CS50 tradition. But can we get one more final volunteer to come on up to play Ivy's Hardest Game? I'm seeing your hand most enthusiastically there. Yeah, come on down. Very happily. 
但在这种情况下，我们可能想要修复它。所以 10 步可能对这个效果不太好。但这里的最后一点是为了展示你的一位前辈，一位过去的同学，实际上实现的游戏版本。在此之前，之后，我们将去中庭吃蛋糕，这是 CS50 的传统。但我们可以再找一个最后的志愿者上来玩 Ivy 的最难游戏吗？我看到你的手最热情了。来吧。很高兴。

[APPLAUSE]   [掌声]

In just a moment, we will indeed adjourn. But the goal here now is going to be to navigate a maze that's a little more difficult than the last. Let's have you first, though, introduce yourselves to your classmates in front. 
稍后我们将确实休会。但现在的目标将是导航一个比上次更难迷宫。不过，你首先向你的同学介绍一下自己。

AUDIENCE: Hi, y'all. I'm Eric. I'm from Philadelphia and I'm also from Hollis Hall. 
观众：嗨，大家好。我是埃里克。我来自费城，也来自霍利斯堂。

[CHEERS]   [ Cheers ]

DAVID MALAN: One person from Hollis. Nice. OK. Welcome. All right. Eric, go ahead and take the keyboard here. It, too, will be all about up, down, left, right as soon as you click the green flag. And if we can crank the music. 
大卫·马尔兰：霍利斯有一个人。不错。好的。欢迎。好的。埃里克，请过来拿键盘。点击绿色标志后，它也会是关于上下左右。如果我们能提高音乐音量。

[MC HAMMER, "U CAN'T TOUCH THIS"] 
[ 麦 Hammer, "你触不到我" ]

You Can't touch this 
你触不到我

DAVID MALAN: So notice, the black walls are a little more involved than last time. But the goal is to get to the sprite all the way at right and just touch it, at which point you move to the next level. The next level, of course, has Yale doing its thing back and forth. You've made it to level three. 
大卫·马兰：注意，这次的黑墙比上次复杂一些。但目标是到达最右边的精灵并触摸它，此时你将进入下一关。下一关，当然，是耶鲁在来回做它的事情。你已经到达第三关了。

But now there's two Yale. So another sprite is in the mix that's randomly moving a little different in terms of direction. Three Yales. Next level. MIT is in. Nice. 
但现在有两个耶鲁。所以又有一个精灵加入了，它在方向上随机移动得有点不同。三个耶鲁。下一级。麻省理工也加入了。不错。

The walls are now gone. Princeton's in the mix. Nice. Two Princetons. OK. New life. OK, another life. Nice. Nice. Oh. Nice. Second to last level. Three Princetons. Last level. Yeah! Congratulations. 
墙已经不见了。普林斯顿在名单上。不错。两个普林斯顿。好的。新生活。好的，另一种生活。不错。不错。哦。不错。倒数第二个关卡。三个普林斯顿。最后一个关卡。耶！恭喜！

[APPLAUSE]   [掌声]

Thank you. All right. This, then, was CS50. Welcome aboard. Cake is now served. 
谢谢。好的。那么，这就是 CS50。欢迎加入。蛋糕现在可以享用。

[MUSIC PLAYING]   [音乐播放]

  查看源代码