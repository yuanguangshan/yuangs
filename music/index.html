<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>å¹¿å±±éŸ³ä¹</title>

    <!-- PWA  æ ¸å¿ƒé…ç½® -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#0a0a0a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="å¹¿å±±éŸ³ä¹">

    <!-- å›¾æ ‡é…ç½® -->
    <link rel="icon" type="image/x-icon" href="./icon/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="./icon/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./icon/icon-16x16.png">
    <link rel="apple-touch-icon" href="./icon/apple-touch-icon.png">

    <style>
        :root {
            --primary: #1db954;
            --primary-dark: #1aa34a;
            --accent: #ff6b6b;
            --bg: #0a0a0a;
            --card: #161616;
            --card-hover: #1f1f1f;
            --text: #ffffff;
            --text-secondary: #a0a0a0;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            min-height: 100dvh;
            overflow-x: hidden;
            position: relative;
        }

        /* åŠ¨æ€èƒŒæ™¯ */
        .bg-gradient {
            position: fixed;
            inset: 0;
            z-index: 0;
            opacity: 0.6;
            transition: opacity 0.8s ease;
            background: radial-gradient(ellipse at 50% 0%, var(--primary) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 50%, #6366f1 0%, transparent 40%),
                radial-gradient(ellipse at 20% 80%, #ec4899 0%, transparent 40%);
            filter: blur(80px) saturate(150%);
        }

        .bg-album {
            position: fixed;
            inset: 0;
            z-index: 0;
            background-size: cover;
            background-position: center;
            opacity: 0;
            transition: opacity 1s ease;
            filter: blur(60px) brightness(0.4) saturate(120%);
        }

        .bg-album.active {
            opacity: 0.7;
        }

        /* é¡¶éƒ¨æœç´¢æ   */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: calc(8px + var(--safe-top)) 16px 8px;
            background: linear-gradient(to bottom, rgba(10, 10, 10, 0.95) 0%, rgba(10, 10, 10, 0.8) 70%, transparent 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
        }

        .search-box {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .search-input {
            width: 100%;
            height: 40px;
            padding: 0 40px 0 18px;
            /* Add padding on the right to make space for clear button */
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            background: var(--glass);
            color: var(--text);
            font-size: 15px;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            border-color: var(--primary);
            background: rgba(29, 185, 84, 0.1);
        }

        .search-input::placeholder {
            color: var(--text-secondary);
        }

        .search-input-container {
            position: relative;
            flex: 1;
            min-width: 120px;
            max-width: 300px;
        }

        .search-clear-btn {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        .search-clear-btn:hover {
            background: var(--glass-border);
            color: var(--text);
        }

        .btn {
            height: 40px;
            padding: 0 18px;
            border-radius: 20px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-icon {
            width: 40px;
            height: 40px;
            padding: 0;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text);
            font-size: 18px;
        }

        .btn-icon:hover {
            background: var(--glass-border);
        }

        /* å†…å®¹åŒº */
        .content {
            position: relative;
            z-index: 1;
            padding: calc(72px + var(--safe-top)) 16px calc(200px + var(--safe-bottom));
            min-height: 100vh;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
        }

        /* æ­Œæ›²å¡ç‰‡ */
        .song-card {
            background: var(--card);
            border-radius: 12px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            position: relative;
        }

        .song-options {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .song-card:hover .song-options {
            opacity: 1;
        }

        .song-card:hover {
            background: var(--card-hover);
            transform: translateY(-4px);
            border-color: var(--glass-border);
        }

        .song-card:active {
            transform: scale(0.98);
        }

        .song-card.playing {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(29, 185, 84, 0.3);
        }

        .song-cover {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 12px;
            object-fit: cover;
            background: #222;
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }

        .song-cover img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: transform 0.3s ease;
        }

        .song-card:hover .song-cover img {
            transform: scale(1.05);
        }

        .play-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .song-card:hover .play-overlay,
        .song-card.playing .play-overlay {
            opacity: 1;
        }

        .play-overlay-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--primary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            color: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .song-title {
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .song-artist {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* ä¸¤åˆ—ç»“æœå¸ƒå±€ */
        .results-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            width: 100%;
        }

        .results-column {
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .simple-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
            padding-left: 4px;
        }

        .empty-message {
            grid-column: 1/-1;
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .results-columns {
                gap: 12px;
                /* å‡å°ç§»åŠ¨ç«¯é—´è· */
            }

            /* ç§»åŠ¨ç«¯æ¯åˆ—å†…éƒ¨çš„ç½‘æ ¼è°ƒæ•´ */
            .results-column .grid {
                grid-template-columns: 1fr;
                /* ç§»åŠ¨ç«¯æ¯åˆ—å†…éƒ¨å•åˆ—æ˜¾ç¤º */
            }
        }

        /* åº•éƒ¨æ’­æ”¾å™¨ - å…¨æ–°è®¾è®¡ */
        .player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 100;
            padding: 0 16px calc(16px + var(--safe-bottom));
            background: linear-gradient(to top, rgba(10, 10, 10, 1) 0%, rgba(10, 10, 10, 0.95) 50%, transparent 100%);
            pointer-events: none;
        }

        .player-card {
            background: var(--card);
            border-radius: 24px;
            padding: 12px 16px 16px;
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(40px);
            -webkit-backdrop-filter: blur(40px);
            box-shadow: 0 -4px 30px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }

        /* é¡¶éƒ¨ä¿¡æ¯æ  */
        .player-info-bar {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 12px;
            padding: 8px 12px;
            background: var(--glass);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            /* Allow proper alignment of the wiki button */
        }

        .player-label {
            font-size: 12px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .player-text-wrapper {
            overflow: hidden;
            white-space: nowrap;
            flex-shrink: 1;
            min-width: 0;
            position: relative;
        }

        .title-wrapper {
            max-width: 200px;
        }

        .artist-wrapper {
            max-width: 150px;
        }

        .player-title-text {
            display: inline-block;
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
            transition: color 0.2s ease;
            white-space: nowrap;
        }

        .player-title-text:hover {
            color: var(--primary);
        }

        .player-separator {
            font-size: 12px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .player-artist-text {
            display: inline-block;
            font-size: 13px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: color 0.2s ease;
            white-space: nowrap;
        }

        .player-artist-text:hover {
            color: var(--primary);
        }

        /* å“åº”å¼è°ƒæ•´ */
        @media (max-width: 767px) {
            .title-wrapper {
                max-width: 120px;
            }

            .artist-wrapper {
                max-width: 100px;
            }
        }

        .player-wiki-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text-secondary);
            /* Default not highlighted */
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
            padding: 0;
            margin-left: auto;
            /* Push to the right */
        }

        .player-wiki-btn:hover {
            background: var(--primary);
            color: white;
            transform: scale(1.1);
        }

        /* æ»šåŠ¨åŠ¨ç”» */
        .scroll-text {
            animation: scroll-left var(--duration, 10s) linear infinite alternate;
        }

        @keyframes scroll-left {

            0%,
            10% {
                transform: translateX(0);
            }

            90%,
            100% {
                transform: translateX(var(--scroll-distance, -50%));
            }
        }

        /* ä¸»æ§åˆ¶åŒº */
        .player-main {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .player-cover {
            width: 56px;
            height: 56px;
            border-radius: 12px;
            object-fit: cover;
            background: #222;
            flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }

        .player-cover.spinning {
            animation: spin 8s linear infinite;
            border-radius: 50%;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(-360deg);
            }
        }

        .player-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-shrink: 0;
            margin-left: auto;
        }

        .ctrl-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background: transparent;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            opacity: 0.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ctrl-btn:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(29, 185, 84, 0.5);
        }

        .ctrl-btn:active {
            transform: scale(0.95);
        }

        .ctrl-btn.play {
            width: 56px;
            height: 56px;
            background: var(--primary);
            color: white;
            font-size: 24px;
            opacity: 0.9;
            box-shadow: 0 0 25px rgba(29, 185, 84, 0.3);
        }

        .ctrl-btn.play:hover {
            background: var(--primary-dark);
            opacity: 1;
            transform: scale(1.08);
            box-shadow: 0 0 30px rgba(29, 185, 84, 0.6);
        }

        .ctrl-btn.play:active {
            transform: scale(0.95);
        }

        /* è¿›åº¦æ¡ */
        .progress-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .time {
            font-size: 11px;
            color: var(--text-secondary);
            min-width: 36px;
            text-align: center;
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary);
            width: 0%;
            border-radius: 2px;
            transition: width 0.1s linear;
        }

        .progress-bar:hover .progress-fill {
            background: #1ed760;
        }

        /* æ­Œè¯è¯¦æƒ…é¡µ */
        .lyrics-modal {
            position: fixed;
            inset: 0;
            z-index: 200;
            background: var(--bg);
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            overflow-y: auto;
            padding: calc(60px + var(--safe-top)) 24px calc(24px + var(--safe-bottom));
        }

        .lyrics-modal.show {
            transform: translateY(0);
        }

        .lyrics-header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: calc(16px + var(--safe-top)) 24px 16px;
            background: linear-gradient(to bottom, var(--bg) 0%, transparent 100%);
            z-index: 10;
        }

        .lyrics-close {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--glass);
            border: none;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .lyrics-cover {
            width: 200px;
            height: 200px;
            border-radius: 20px;
            margin: 0 auto 24px;
            display: block;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.5);
        }

        .lyrics-title {
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            margin-bottom: 8px;
        }

        .lyrics-artist {
            font-size: 16px;
            color: var(--text-secondary);
            text-align: center;
            margin-bottom: 32px;
            display: inline-block;
        }

        .lyrics-artist-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 32px;
        }

        .lyrics-artist.clickable:hover {
            color: var(--primary);
        }

        .lyrics-wiki {
            background: var(--card);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 24px;
            border-left: 3px solid var(--primary);
            display: none;
        }

        .lyrics-wiki.show {
            display: block;
        }

        .lyrics-wiki-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 8px;
        }

        .lyrics-wiki-text {
            font-size: 14px;
            line-height: 1.6;
            color: var(--text-secondary);
        }

        .lyrics-text {
            font-size: 18px;
            line-height: 2;
            color: var(--text-secondary);
            text-align: center;
            white-space: pre-wrap;
        }

        /* å¼¹å¹• */
        .danmaku {
            position: fixed;
            top: calc(100px + var(--safe-top));
            left: 0;
            right: 0;
            height: 200px;
            z-index: 50;
            pointer-events: none;
            overflow: hidden;
            mask-image: linear-gradient(to bottom, transparent, black 15%, black 85%, transparent);
            display: none;
        }

        .danmaku.show {
            display: block;
        }

        .danmaku-item {
            position: absolute;
            left: 100%;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            white-space: nowrap;
            animation: danmaku-slide linear forwards;
        }

        .danmaku-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
        }

        .danmaku-name {
            color: var(--primary);
            font-weight: 600;
            font-size: 13px;
        }

        .danmaku-text {
            font-size: 13px;
            color: var(--text);
        }

        @keyframes danmaku-slide {
            from {
                transform: translateX(0);
            }

            to {
                transform: translateX(calc(-100% - 100vw));
            }
        }

        /* ç©ºçŠ¶æ€ */
        .empty-state {
            text-align: center;
            padding: 80px 20px;
            color: var(--text-secondary);
        }

        .empty-icon {
            font-size: 64px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text);
            margin-bottom: 8px;
        }

        .empty-desc {
            font-size: 14px;
            line-height: 1.6;
        }

        /* åŠ è½½çŠ¶æ€ */
        .loading {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--glass-border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: loading-spin 0.8s linear infinite;
            margin: 0 auto 16px;
        }

        @keyframes loading-spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* PWA å®‰è£…æç¤º */
        .install-prompt {
            position: fixed;
            bottom: calc(200px + var(--safe-bottom));
            left: 16px;
            right: 16px;
            z-index: 150;
            background: var(--card);
            border-radius: 16px;
            padding: 16px;
            display: flex;
            align-items: center;
            gap: 12px;
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            animation: slide-up 0.4s ease;
        }

        @keyframes slide-up {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
        }

        /* æ¨èæ ‡ç­¾æ ·å¼ */
        .recommendation-tag {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text);
            font-size: 12px;
            padding: 4px 10px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .recommendation-tag:hover {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
            transform: scale(1.05);
        }

        .install-icon {
            font-size: 32px;
        }

        .install-text {
            flex: 1;
        }

        .install-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .install-desc {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .install-btn {
            padding: 10px 20px;
            background: var(--primary);
            color: white;
            border: none;
            border-radius: 20px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
        }

        .install-close {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--glass);
            border: none;
            color: var(--text-secondary);
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* æ”¶è—æŒ‰é’®æ ·å¼ */
        .favorite-btn {
            font-size: 22px;
            transition: all 0.3s ease;
            border: none;
            box-shadow: none !important;
        }

        .ctrl-btn.favorite-btn:hover,
        .favorite-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            box-shadow: none !important;
            transform: scale(1.1);
        }

        .favorite-btn.favorited {
            color: #ff6b6b;
            animation: heartBeat 0.3s ease;
        }

        /* Ensure favorite button maintains consistent styling in all states */
        .ctrl-btn.favorite-btn {
            box-shadow: none !important;
        }

        /* More specific rules to override default hover behavior */
        .ctrl-btn.favorite-btn:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.1) !important;
            box-shadow: none !important;
        }

        .ctrl-btn.favorite-btn.favorited:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            border-color: rgba(255, 255, 255, 0.1) !important;
            box-shadow: none !important;
        }

        @keyframes heartBeat {

            0%,
            100% {
                transform: scale(1);
            }

            25% {
                transform: scale(1.3);
            }

            50% {
                transform: scale(1.1);
            }

            75% {
                transform: scale(1.2);
            }
        }

        /* æ”¶è—å’Œå†å²å¼¹çª— */
        .collection-modal {
            position: fixed;
            inset: 0;
            z-index: 200;
            background: var(--bg);
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .collection-modal.show {
            transform: translateY(0);
        }

        .collection-header {
            position: sticky;
            top: 0;
            padding: calc(20px + var(--safe-top)) 24px 20px;
            background: linear-gradient(to bottom, var(--bg) 0%, rgba(10, 10, 10, 0.95) 100%);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            z-index: 10;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--glass-border);
        }

        .collection-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--text);
        }

        .collection-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .btn-action {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text);
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .btn-action:hover {
            background: var(--glass-border);
            transform: scale(1.1);
        }

        .btn-action:active {
            transform: scale(0.95);
        }

        .collection-close {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--glass);
            border: none;
            color: var(--text);
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .collection-close:hover {
            background: var(--accent);
            color: white;
        }

        .collection-content {
            flex: 1;
            padding: 24px;
            padding-bottom: calc(24px + var(--safe-bottom));
        }

        .collection-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 16px;
        }

        .collection-item {
            background: var(--card);
            border-radius: 12px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            position: relative;
        }

        .collection-item:hover {
            background: var(--card-hover);
            transform: translateY(-4px);
            border-color: var(--glass-border);
        }

        .collection-item-cover {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 12px;
            object-fit: cover;
            background: #222;
            margin-bottom: 8px;
        }

        .collection-item-title {
            font-size: 13px;
            font-weight: 600;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 2px;
        }

        .collection-item-artist {
            font-size: 11px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .collection-item-time {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .collection-item-remove {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(255, 107, 107, 0.9);
            color: white;
            border: none;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .collection-item:hover .collection-item-remove {
            opacity: 1;
        }

        /* å“åº”å¼ */
        @media (max-width: 767px) {
            .grid {
                /* ä½¿ç”¨ minmax(0, 1fr) å¼ºåˆ¶ä¸¤åˆ—å¹³åˆ†ï¼Œé˜²æ­¢è¢«å†…å®¹æ’‘å¤§ */
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 10px;
            }

            .song-card {
                padding: 6px;
                /* ç¡®ä¿å¡ç‰‡ä¸ä¼šè¶…å‡ºç½‘æ ¼å•å…ƒ */
                width: 100%;
                min-width: 0;
            }

            /* ç¡®ä¿å†…å®¹åŒºå·¦å³è¾¹è·é€‚ä¸­ */
            .content {
                padding-left: 12px;
                padding-right: 12px;
            }
        }

        @media (min-width: 768px) {
            .grid {
                grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            }

            .player-card {
                max-width: 600px;
                margin: 0 auto;
            }
        }
    </style>
</head>

<body>
    <!-- èƒŒæ™¯ -->
    <div class="bg-gradient"></div>
    <div class="bg-album" id="bg-album"></div>

    <!-- é¡¶éƒ¨æœç´¢ -->
    <header class="header">
        <div class="search-box">
            <div class="search-input-container">
                <input type="text" class="search-input" id="search-input" placeholder="æ­Œæ‰‹/æ­Œæ›²...">
                <button class="search-clear-btn" id="search-clear-btn" title="æ¸…ç©ºæœç´¢" style="display: none;">âœ•</button>
            </div>
            <button class="btn btn-icon" onclick="searchMusic()" title="æœç´¢">ğŸ”</button>
            <button class="btn btn-icon" onclick="searchByWeather()" title="çœ‹å¤©å¬æ­Œ">ğŸŒ¤ï¸</button>
            <button class="btn btn-icon" onclick="smartRandomSearch()" title="æ™ºèƒ½æ¢ç´¢">ğŸ²</button>
            <button class="btn btn-icon" onclick="openHistory()" title="æ’­æ”¾å†å²">ğŸ“–</button>
            <button class="btn btn-icon" onclick="openFavorites()" title="æˆ‘çš„æ”¶è—">â¤ï¸</button>
        </div>
    </header>

    <!-- å†…å®¹åŒº -->
    <main class="content">
        <div class="grid" id="results">
            <div class="empty-state" style="grid-column: 1/-1;">
                <div class="empty-icon">ğŸ§</div>
                <div class="empty-title">å‘ç°éŸ³ä¹</div>
                <div class="empty-desc">ç‚¹å‡» ğŸ² éšæœºæ¢ç´¢ï¼Œæˆ–æœç´¢ä½ å–œæ¬¢çš„æ­Œæ›²</div>
            </div>
        </div>
    </main>

    <!-- å¼¹å¹• -->
    <div class="danmaku" id="danmaku"></div>

    <!-- åº•éƒ¨æ’­æ”¾å™¨ -->
    <div class="player">
        <div class="player-card">
            <!-- é¡¶éƒ¨æ­Œæ›²ä¿¡æ¯æ  -->
            <div class="player-info-bar">
                <span class="player-label">æ­£åœ¨æ’­æ”¾ï¼š</span>
                <div class="player-text-wrapper title-wrapper">
                    <span class="player-title-text" id="player-title-text">å¹¿å±±éŸ³ä¹</span>
                </div>
                <span class="player-separator">-</span>
                <div class="player-text-wrapper artist-wrapper">
                    <span class="player-artist-text" id="player-artist-text">ç­‰å¾…æ’­æ”¾</span>
                </div>
                <button class="player-wiki-btn" id="player-tag-btn" title="æŸ¥çœ‹æ­Œæ›²æ ‡ç­¾æ¨è"
                    style="display: none; margin-right: 8px;">ğŸ·ï¸</button>
                <button class="player-wiki-btn" id="player-wiki-btn" title="æŸ¥çœ‹è‰ºæœ¯å®¶ç»´åŸºç™¾ç§‘"
                    style="display: none;">ğŸ“–</button>
            </div>

            <!-- ä¸»æ§åˆ¶åŒº -->
            <div class="player-main">
                <img class="player-cover" id="player-cover"
                    src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%23222' width='100' height='100'/%3E%3Ccircle cx='50' cy='50' r='30' fill='none' stroke='%23333' stroke-width='2'/%3E%3Ccircle cx='50' cy='50' r='10' fill='%23333'/%3E%3C/svg%3E"
                    alt="Cover">
                <button class="ctrl-btn favorite-btn" id="favorite-btn" onclick="toggleFavorite()"
                    title="æ”¶è—">ğŸ¤</button>
                <div class="player-controls">
                    <button class="ctrl-btn" id="mode-btn" onclick="togglePlayMode()" title="åˆ—è¡¨å¾ªç¯">ğŸ”</button>
                    <button class="ctrl-btn" onclick="playPrevious()">â®</button>
                    <button class="ctrl-btn play" id="play-btn" onclick="togglePlay()">â–¶</button>
                    <button class="ctrl-btn" onclick="playNext()">â­</button>
                </div>
            </div>

            <!-- è¿›åº¦æ¡ -->
            <div class="progress-container">
                <span class="time" id="current-time">0:00</span>
                <div class="progress-bar" id="progress-bar" onclick="seek(event)">
                    <div class="progress-fill" id="progress-fill"></div>
                </div>
                <span class="time" id="total-time">0:30</span>
            </div>

            <!-- æ¨èæ ‡ç­¾åŒº -->
            <div class="recommendation-tags" id="recommendation-tags" style="margin-top: 12px; display: none;">
                <div class="player-label" style="margin-bottom: 6px;">ç›¸å…³æ¨èï¼š</div>
                <div class="recommendation-tags-container" id="recommendation-tags-container"
                    style="display: flex; flex-wrap: wrap; gap: 6px; max-height: 40px; overflow-y: auto;"></div>
                <div class="show-more-recommendations" id="show-more-recommendations"
                    style="margin-top: 6px; color: var(--primary); font-size: 12px; cursor: pointer; display: none;">
                    å±•å¼€æ›´å¤šæ¨è</div>
            </div>
        </div>
    </div>

    <!-- æ­Œè¯è¯¦æƒ… -->
    <div class="lyrics-modal" id="lyrics-modal">
        <div class="lyrics-header">
            <button class="lyrics-close" onclick="closeLyrics()">âœ•</button>
        </div>
        <img class="lyrics-cover" id="lyrics-cover" src="" alt="">
        <h2 class="lyrics-title" id="lyrics-title"></h2>
        <div class="lyrics-artist-container">
            <p class="lyrics-artist clickable" id="lyrics-artist" style="cursor: pointer; text-decoration: underline;"
                title="ç‚¹å‡»è®¿é—®ç»´åŸºç™¾ç§‘"></p>
        </div>
        <div class="lyrics-wiki" id="lyrics-wiki">
            <div class="lyrics-wiki-title" id="wiki-title"></div>
            <div class="lyrics-wiki-text" id="wiki-text"></div>
        </div>
        <div class="lyrics-text" id="lyrics-text">åŠ è½½ä¸­...</div>
    </div>

    <!-- å†å²è®°å½•å¼¹çª— -->
    <div class="collection-modal" id="history-modal">
        <div class="collection-header">
            <h2 class="collection-title">ğŸ“– æ’­æ”¾å†å²</h2>
            <div class="collection-actions">
                <button class="btn-action" onclick="exportHistory()" title="å¯¼å‡ºå†å²">ğŸ“¤</button>
                <button class="btn-action" onclick="importHistory()" title="å¯¼å…¥å†å²">ğŸ“¥</button>
                <button class="btn-action" onclick="clearHistory()" title="æ¸…ç©ºå†å²">ğŸ—‘ï¸</button>
                <button class="collection-close" onclick="closeHistory()">âœ•</button>
            </div>
        </div>
        <div class="collection-content" id="history-content">
            <div class="empty-state">
                <div class="empty-icon">ğŸ“–</div>
                <div class="empty-title">æš‚æ— æ’­æ”¾å†å²</div>
                <div class="empty-desc">å¼€å§‹æ’­æ”¾éŸ³ä¹åä¼šè‡ªåŠ¨è®°å½•</div>
            </div>
        </div>
    </div>

    <!-- æ”¶è—åˆ—è¡¨å¼¹çª— -->
    <div class="collection-modal" id="favorites-modal">
        <div class="collection-header">
            <h2 class="collection-title">â¤ï¸ æˆ‘çš„æ”¶è—</h2>
            <div class="collection-actions">
                <button class="btn-action" onclick="exportFavorites()" title="å¯¼å‡ºæ”¶è—">ğŸ“¤</button>
                <button class="btn-action" onclick="importFavorites()" title="å¯¼å…¥æ”¶è—">ğŸ“¥</button>
                <button class="btn-action" onclick="clearFavorites()" title="æ¸…ç©ºæ”¶è—">ğŸ—‘ï¸</button>
                <button class="collection-close" onclick="closeFavorites()">âœ•</button>
            </div>
        </div>
        <div class="collection-content" id="favorites-content">
            <div class="empty-state">
                <div class="empty-icon">â¤ï¸</div>
                <div class="empty-title">æš‚æ— æ”¶è—</div>
                <div class="empty-desc">ç‚¹å‡»æ’­æ”¾å™¨ä¸­çš„çˆ±å¿ƒæŒ‰é’®æ”¶è—æ­Œæ›²</div>
            </div>
        </div>
    </div>

    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥æ¡† -->
    <input type="file" id="import-file-input" accept=".json" style="display: none;">

    <audio id="audio" crossorigin="anonymous"></audio>

    <!-- YouTube Iframe API -->
    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        // çŠ¶æ€ç®¡ç†
        const state = {
            currentTrack: null,
            playlist: [],
            currentIndex: -1,
            isPlaying: false,
            playMode: 'sequence', // sequence, random, single
            danmakuInterval: null,
            danmakuCache: [],
            tracks: [false, false, false, false, false],
            displayedDanmaku: new Set(),  // Track currently displayed danmaku content to prevent duplicates
            youtubePlayer: null,  // YouTube player instance
            isYouTubePlaying: false,  // Track if YouTube player is currently playing
            youtubeProgressInterval: null,  // Interval for YouTube progress updates
            lastPosition: 0  // Store last playback position when app goes to background
        };

        // URLå‚æ•°è§£æå‡½æ•°
        function getUrlParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                apple: params.get('apple') === 'true',
                youtube: params.get('youtube') === 'true'
            };
        }

        // ç¼“å­˜ç³»ç»Ÿ
        const CacheManager = {
            // è·å–ç¼“å­˜çš„æ•°æ®
            get: (key) => {
                try {
                    const cached = localStorage.getItem(key);
                    if (!cached) return null;

                    const parsed = JSON.parse(cached);
                    const now = Date.now();

                    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
                    if (parsed.expiry && now > parsed.expiry) {
                        localStorage.removeItem(key);
                        return null;
                    }

                    return parsed.data;
                } catch (e) {
                    console.warn('Cache get error:', e);
                    return null;
                }
            },

            // è®¾ç½®ç¼“å­˜æ•°æ®
            set: (key, data, expiryHours = 24) => {
                try {
                    const expiry = Date.now() + (expiryHours * 60 * 60 * 1000);
                    const cacheObj = {
                        data: data,
                        expiry: expiry
                    };
                    localStorage.setItem(key, JSON.stringify(cacheObj));
                } catch (e) {
                    console.warn('Cache set error:', e);
                }
            },

            // åˆ é™¤ç¼“å­˜æ•°æ®
            remove: (key) => {
                try {
                    localStorage.removeItem(key);
                } catch (e) {
                    console.warn('Cache remove error:', e);
                }
            }
        };

        // æ”¶è—ç®¡ç†å™¨
        const FavoritesManager = {
            STORAGE_KEY: 'music_favorites',

            // è·å–æ‰€æœ‰æ”¶è—
            getAll: () => {
                try {
                    const data = localStorage.getItem(FavoritesManager.STORAGE_KEY);
                    return data ? JSON.parse(data) : [];
                } catch (e) {
                    console.error('Failed to get favorites:', e);
                    return [];
                }
            },

            // ä¿å­˜æ”¶è—
            save: (favorites) => {
                try {
                    localStorage.setItem(FavoritesManager.STORAGE_KEY, JSON.stringify(favorites));
                } catch (e) {
                    console.error('Failed to save favorites:', e);
                }
            },

            // æ·»åŠ æ”¶è—
            add: (song) => {
                const favorites = FavoritesManager.getAll();
                const exists = favorites.some(f => f.trackId === song.trackId);
                if (!exists) {
                    favorites.unshift({
                        ...song,
                        favoritedAt: Date.now()
                    });
                    FavoritesManager.save(favorites);
                    return true;
                }
                return false;
            },

            // ç§»é™¤æ”¶è—
            remove: (trackId) => {
                const favorites = FavoritesManager.getAll();
                const filtered = favorites.filter(f => f.trackId !== trackId);
                FavoritesManager.save(filtered);
            },

            // æ£€æŸ¥æ˜¯å¦å·²æ”¶è—
            isFavorited: (trackId) => {
                const favorites = FavoritesManager.getAll();
                return favorites.some(f => f.trackId === trackId);
            },

            // æ¸…ç©ºæ”¶è—
            clear: () => {
                FavoritesManager.save([]);
            },

            // å¯¼å‡ºæ”¶è—
            export: () => {
                const favorites = FavoritesManager.getAll();
                const dataStr = JSON.stringify(favorites, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `music-favorites-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },

            // å¯¼å…¥æ”¶è—
            import: (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (Array.isArray(data)) {
                                FavoritesManager.save(data);
                                resolve(data.length);
                            } else {
                                reject(new Error('Invalid format'));
                            }
                        } catch (err) {
                            reject(err);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
        };

        // å†å²è®°å½•ç®¡ç†å™¨
        const HistoryManager = {
            STORAGE_KEY: 'music_history',
            MAX_ITEMS: 100,

            // è·å–æ‰€æœ‰å†å²
            getAll: () => {
                try {
                    const data = localStorage.getItem(HistoryManager.STORAGE_KEY);
                    return data ? JSON.parse(data) : [];
                } catch (e) {
                    console.error('Failed to get history:', e);
                    return [];
                }
            },

            // ä¿å­˜å†å²
            save: (history) => {
                try {
                    localStorage.setItem(HistoryManager.STORAGE_KEY, JSON.stringify(history));
                } catch (e) {
                    console.error('Failed to save history:', e);
                }
            },

            // æ·»åŠ å†å²è®°å½•
            add: (song) => {
                let history = HistoryManager.getAll();
                // ç§»é™¤é‡å¤é¡¹
                history = history.filter(h => h.trackId !== song.trackId);
                // æ·»åŠ åˆ°å¼€å¤´
                history.unshift({
                    ...song,
                    playedAt: Date.now()
                });
                // é™åˆ¶æ•°é‡
                if (history.length > HistoryManager.MAX_ITEMS) {
                    history = history.slice(0, HistoryManager.MAX_ITEMS);
                }
                HistoryManager.save(history);
            },

            // ç§»é™¤å†å²è®°å½•
            remove: (trackId) => {
                const history = HistoryManager.getAll();
                const filtered = history.filter(h => h.trackId !== trackId);
                HistoryManager.save(filtered);
            },

            // æ¸…ç©ºå†å²
            clear: () => {
                HistoryManager.save([]);
            },

            // å¯¼å‡ºå†å²
            export: () => {
                const history = HistoryManager.getAll();
                const dataStr = JSON.stringify(history, null, 2);
                const blob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `music-history-${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },

            // å¯¼å…¥å†å²
            import: (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (Array.isArray(data)) {
                                HistoryManager.save(data);
                                resolve(data.length);
                            } else {
                                reject(new Error('Invalid format'));
                            }
                        } catch (err) {
                            reject(err);
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }
        };

        // ç”Ÿæˆç¼“å­˜é”®
        const generateCacheKey = (artist, title) => {
            return `song_${encodeURIComponent(artist)}_${encodeURIComponent(title)}`;
        };

        // DOM å…ƒç´ 
        const $ = id => document.getElementById(id);
        const audio = $('audio');

        // å±‚æ¬¡åŒ–éŸ³ä¹æ ‡ç­¾ç³»ç»Ÿ
        const musicTags = {
            // ä¸€çº§åˆ†ç±»ï¼šéŸ³ä¹å±æ€§
            attributes: {
                // äºŒçº§åˆ†ç±»ï¼šæƒ…ç»ªä¸æ°›å›´ (Vibes & Moods)
                moods: {
                    positive: ["Happy", "Joy", "Cheerful", "Uplifting", "Energetic", "Upbeat", "Euphoria", "Peaceful", "Calm", "Serene", "Chill", "Relax", "Cozy", "Mellow", "Groovy", "Cool", "Fresh"],
                    romantic: ["Love", "Romantic", "Heart", "Kiss", "Miss", "Baby", "Intimate", "Affection", "Passion", "Sensual", "Sexy"],
                    melancholy: ["Sad", "Melancholy", "Nostalgia", "Sentimental", "Blue", "Tears", "Lonely", "Gloomy", "Melancholic", "Heartbreak"],
                    intense: ["Drama", "Intense", "Power", "Epic", "Cinematic", "Dark", "Mystery", "Mysterious", "Heavy", "Spooky", "Creepy", "Mysterious", "Supernatural"],
                    spiritual: ["Faith", "Believe", "Angels", "Heaven", "Paradise", "Divine", "Sacred", "Spiritual", "Transcendent", "Soulful"]
                },
                // äºŒçº§åˆ†ç±»ï¼šéŸ³ä¹é£æ ¼ (Stylistic Elements)
                styles: {
                    sonic: ["Acoustic", "Electric", "Instrumental", "Acapella", "Live", "Studio", "Remix", "Cover", "Original"],
                    aesthetic: ["Vintage", "Retro", "Classic", "Modern", "Futuristic", "Cyberpunk", "Aesthetic", "Pastel", "Neon", "Funky"]
                }
            },
            // ä¸€çº§åˆ†ç±»ï¼šéŸ³ä¹ç±»å‹
            genres: {
                // äºŒçº§åˆ†ç±»ï¼šä¸»è¦æµæ´¾ (Main Genres)
                main: {
                    pop: ["Pop", "Mandopop", "Cantopop", "K-Pop", "J-Pop", "Jazz", "Soul", "R&B"],
                    rock: ["Rock", "Alternative", "Indie", "Punk", "Grunge", "Emo", "Metal", "Heavy Metal"],
                    electronic: ["EDM", "House", "Techno", "Trance", "Dubstep", "Drum and Bass", "Garage", "Ambient"],
                    hip_hop: ["Hip Hop", "Rap", "Trap", "R&B"],
                    traditional: ["Country", "Folk", "Classical", "Opera", "Blues"],
                    world: ["Latin", "Reggae", "Dancehall", "Salsa", "Bachata", "Reggaeton", "Anime", "Ghibli"]
                },
                // ä¸‰çº§åˆ†ç±»ï¼šè¡ç”Ÿæµæ´¾ (Sub-Genres)
                sub_genres: {
                    pop_sub: ["Synthpop", "Electropop", "Dance-pop", "Indie Pop", "Art Pop"],
                    rock_sub: ["Glam Rock", "Progressive Rock", "Punk Rock", "Hard Rock", "Grunge Rock", "Alternative Rock"],
                    electronic_sub: ["Lo-Fi", "Lofi Hip Hop", "Synthwave", "Vaporwave", "Retrowave", "Deep House", "Future Bass"],
                    hip_hop_sub: ["Old School Hip Hop", "Trap", "Drill", "Conscious Rap", "Mumble Rap"],
                    traditional_sub: ["Bluegrass", "Folk Rock", "Baroque", "Chamber Music", "Contemporary Classical"]
                }
            },
            // ä¸€çº§åˆ†ç±»ï¼šåœºæ™¯æ´»åŠ¨
            scenarios: {
                // äºŒçº§åˆ†ç±»ï¼šæ—¶é—´åœºæ™¯ (Time-based)
                time_based: {
                    daily_routine: ["Morning", "Wake Up", "Afternoon", "Evening", "Late Night", "Midnight", "Sunrise", "Sunset"],
                    weekly: ["Weekend", "Friday", "Sunday", "Monday", "Workday"],
                    seasonal: ["Spring", "Summer", "Autumn", "Winter", "Holiday", "New Year", "Valentine", "Christmas", "Halloween"],
                    special_occasions: ["Birthday", "Wedding", "Graduation", "Travel", "Vacation", "Beach", "Camping", "Festival"]
                },
                // äºŒçº§åˆ†ç±»ï¼šæ´»åŠ¨åœºæ™¯ (Activity-based)
                activity_based: {
                    exercise: ["Workout", "Gym", "Running", "Jogging", "Yoga", "Meditation", "Stretching"],
                    work_study: ["Study", "Coding", "Reading", "Focus", "Background", "Concentration", "Deep Work"],
                    travel: ["Driving", "Road Trip", "Car Music", "Commuting", "Long Drive"],
                    social: ["Party", "Club", "Bar", "Lounge", "Dinner", "Cooking", "Cleaning"],
                    relaxation: ["Sleep", "Meditation", "Spa", "Shower", "Bath", "Coffee Shop", "Cafe"]
                }
            },
            // ä¸€çº§åˆ†ç±»ï¼šæ–‡åŒ–å…ƒç´ 
            culture: {
                // äºŒçº§åˆ†ç±»ï¼šåœ°åŸŸæ–‡åŒ– (Regional Culture)
                regional: {
                    western: ["American", "British", "European", "African", "Caribbean"],
                    asian: ["Chinese", "Korean", "Japanese", "Taiwanese", "Hong Kong", "Southeast Asian"],
                    latin: ["Latin America", "Brazil", "Mexico", "Caribbean"]
                },
                // äºŒçº§åˆ†ç±»ï¼šè‰ºæœ¯å®¶ä¸ä½œå“ (Artists & Works)
                artists: {
                    western_mainstream: [
                        "Taylor Swift", "Ed Sheeran", "Ariana Grande", "Justin Bieber", "The Weeknd", "Dua Lipa",
                        "Billie Eilish", "Harry Styles", "Bruno Mars", "Adele", "Rihanna", "Beyonce", "Lady Gaga",
                        "Katy Perry", "Miley Cyrus", "Post Malone", "Coldplay", "Imagine Dragons", "OneRepublic",
                        "Drake", "Kendrick Lamar", "Eminem", "Jay-Z", "Travis Scott", "Kanye West", "J. Cole",
                        "Beatles", "Queen", "Pink Floyd", "Led Zeppelin", "AC/DC", "Red Hot Chili Peppers",
                        "Linkin Park", "Arctic Monkeys", "Tame Impala", "Oasis", "David Bowie", "Prince",
                        "Elton John", "Bob Dylan", "BeyoncÃ©", "Alicia Keys", "John Legend"
                    ],
                    korean: ["BTS", "Blackpink", "Twice", "EXO", "Big Bang", "NewJeans", "Stray Kids", "IU", "SEVENTEEN"],
                    chinese: ["å‘¨æ°ä¼¦", "æ—ä¿Šæ°", "é™ˆå¥•è¿…", "ç‹åŠ›å®", "é™¶å–†", "è”¡ä¾æ—", "å­™ç‡•å§¿", "æ¢é™èŒ¹", "äº”æœˆå¤©",
                        "Beyond", "é‚“ä¸½å›", "å¼ å›½è£", "ç‹è²", "å¼ å­¦å‹", "åˆ˜å¾·å", "é»æ˜", "éƒ­å¯ŒåŸ", "ç½—å¤§ä½‘",
                        "æå®—ç››", "å´”å¥", "çª¦å”¯", "ä¼ä½°", "å¼ é›¨ç”Ÿ", "é‚“ç´«æ£‹", "æè£æµ©", "è–›ä¹‹è°¦", "å‘¨æ·±",
                        "æ¯›ä¸æ˜“", "åæ™¨å®‡", "å¼ æ°", "è®¸åµ©", "å‘Šäº”äºº", "ç—›ä»°", "é™ˆç²’", "èµµé›·"],
                    japanese: ["å®‰å®¤å¥ˆç¾æµ", "å®‡å¤šç”°ãƒ’ã‚«ãƒ«", "ç±³æ´¥ç„å¸«", "RADWIMPS", "YOASOBI"],
                    instrumental: ["Hans Zimmer", "John Williams", "Joe Hisaishi", "Ennio Morricone", "Ludwig GÃ¶ransson"]
                },
                // äºŒçº§åˆ†ç±»ï¼šå½±è§†æ–‡åŒ– (Media Culture)
                media: {
                    franchises: ["Marvel", "DC", "Star Wars", "Harry Potter", "Lord of the Rings", "Game of the Thrones"],
                    shows: ["Stranger Things", "Friends", "Simpsons", "Breaking Bad", "The Office"],
                    games: ["Cyberpunk 2077", "GTA", "FIFA", "Mario", "Zelda", "Pokemon", "Fortnite"],
                    other: ["Disney", "Musical", "Broadway", "Anime OST", "Video Game Music"]
                }
            },
            // ä¸€çº§åˆ†ç±»ï¼šè‡ªç„¶ä¸æŠ½è±¡
            nature_abstract: {
                // äºŒçº§åˆ†ç±»ï¼šè‡ªç„¶å…ƒç´  (Natural Elements)
                nature: {
                    weather: ["Rain", "Storm", "Thunder", "Snow", "Wind", "Sun", "Moon", "Stars"],
                    landscapes: ["Ocean", "Sea", "River", "Forest", "Jungle", "Mountain", "Desert"],
                    locations: ["California", "New York", "London", "Paris", "Tokyo", "Seoul", "Hong Kong", "Shanghai", "Miami", "Ibiza", "Hawaii", "Space", "Galaxy", "Universe", "City", "Street", "Highway"]
                },
                // äºŒçº§åˆ†ç±»ï¼šæŠ½è±¡æ¦‚å¿µ (Abstract Concepts)
                abstract: {
                    transcendental: ["Dream", "Night", "Fire", "Gold", "Wild", "Free", "Magic", "Legend", "Hero", "Angel", "Devil", "King", "Queen", "Life", "Time", "Eternity"],
                    emotions: ["Hope", "Smile", "Believe", "Together", "Alone", "Lost", "Forever", "Secret", "Promise"]
                }
            }
        };

        // ä»å±‚æ¬¡åŒ–æ ‡ç­¾ç³»ç»Ÿä¸­æå–æ‰€æœ‰æ ‡ç­¾è¯ï¼Œç”¨äºéšæœºæœç´¢
        function getAllKeywords() {
            const keywords = [];

            function collectKeywords(obj) {
                for (const key in obj) {
                    if (Array.isArray(obj[key])) {
                        // å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºæ•°ç»„
                        obj[key].forEach(item => keywords.push(item));
                    } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                        // å†æ£€æŸ¥æ˜¯å¦ä¸ºå¯¹è±¡ï¼ˆæ’é™¤nullï¼‰
                        collectKeywords(obj[key]);
                    }
                }
            }

            collectKeywords(musicTags);
            return keywords;
        }

        // è·å–æ ‡ç­¾æ¨è
        function getRecommendationsByTag(tag, limit = 20) {
            const recommendations = [];

            function findRelatedTags(obj, currentPath = []) {
                for (const key in obj) {
                    if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                        findRelatedTags(obj[key], [...currentPath, key]);
                    } else if (Array.isArray(obj[key])) {
                        // æ£€æŸ¥å½“å‰æ ‡ç­¾æ˜¯å¦åœ¨æ•°ç»„ä¸­
                        if (obj[key].includes(tag)) {
                            // æ·»åŠ åŒçº§çš„å…¶ä»–æ ‡ç­¾
                            obj[key].forEach(item => {
                                if (item !== tag && !recommendations.includes(item)) {
                                    recommendations.push(item);
                                }
                            });

                            // æ·»åŠ åŒç»„çš„å…¶ä»–æ ‡ç­¾ï¼ˆå¦‚æœæœ‰ï¼‰
                            if (currentPath.length > 0) {
                                const parentPath = currentPath.slice(0, -1);
                                const parentObj = getParentObject(musicTags, parentPath);

                                for (const parentKey in parentObj) {
                                    if (Array.isArray(parentObj[parentKey]) && parentObj[parentKey] !== obj[key]) {
                                        parentObj[parentKey].forEach(item => {
                                            if (!recommendations.includes(item)) {
                                                recommendations.push(item);
                                            }
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }

            function getParentObject(obj, path) {
                let current = obj;
                for (const key of path) {
                    current = current[key];
                }
                return current;
            }

            findRelatedTags(musicTags);

            // åªè¿”å›æŒ‡å®šæ•°é‡çš„æ¨è
            return recommendations.slice(0, limit);
        }

        // è·å–æ ‡ç­¾çš„å±‚æ¬¡ä¿¡æ¯
        function getTagHierarchy(tag) {
            const hierarchy = [];

            function findTag(obj, currentPath = []) {
                for (const key in obj) {
                    if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
                        if (findTag(obj[key], [...currentPath, key])) {
                            return true;
                        }
                    } else if (Array.isArray(obj[key])) {
                        if (obj[key].includes(tag)) {
                            hierarchy.push(...currentPath, key);
                            return true;
                        }
                    }
                }
                return false;
            }

            findTag(musicTags);
            return hierarchy;
        }

        // è·å–å½“å‰æ’­æ”¾æ­Œæ›²çš„ç›¸å…³æ ‡ç­¾æ¨è
        function getSongRecommendations(song) {
            // æ£€æŸ¥æ­Œæ›²å¯¹è±¡æ˜¯å¦æœ‰æ•ˆ
            if (!song || !song.artistName || !song.trackName) {
                return [];
            }

            // ç¡®ä¿å­—ç¬¦ä¸²å±æ€§å­˜åœ¨ä¸”ä¸ä¸ºç©º
            const artistName = song.artistName || '';
            const trackName = song.trackName || '';

            // åŸºäºè‰ºæœ¯å®¶çš„æ¨è
            const artistRecommendations = [];
            for (const category in musicTags.culture.artists) {
                if (musicTags.culture.artists[category].includes(artistName)) {
                    // æ·»åŠ åŒç±»å‹è‰ºæœ¯å®¶
                    musicTags.culture.artists[category].forEach(artist => {
                        if (artist !== artistName && !artistRecommendations.includes(artist)) {
                            artistRecommendations.push(artist);
                        }
                    });
                }
            }

            // åŸºäºæµæ´¾çš„æ¨è
            const genreRecommendations = [];
            for (const category in musicTags.genres.main) {
                if (musicTags.genres.main[category].some(genre =>
                    trackName.toLowerCase().includes(genre.toLowerCase()) ||
                    artistName.toLowerCase().includes(genre.toLowerCase()))) {
                    // æ·»åŠ åŒç±»æµæ´¾
                    musicTags.genres.main[category].forEach(genre => {
                        if (!genreRecommendations.includes(genre) &&
                            !artistRecommendations.includes(genre)) {
                            genreRecommendations.push(genre);
                        }
                    });

                    // æ·»åŠ å­æµæ´¾
                    if (musicTags.genres.sub_genres[`${category}_sub`]) {
                        musicTags.genres.sub_genres[`${category}_sub`].forEach(subGenre => {
                            if (!genreRecommendations.includes(subGenre)) {
                                genreRecommendations.push(subGenre);
                            }
                        });
                    }
                }
            }

            // åˆå¹¶æ‰€æœ‰æ¨èå¹¶é™åˆ¶æ•°é‡
            const allRecommendations = [...artistRecommendations, ...genreRecommendations];
            return [...new Set(allRecommendations)].slice(0, 10);
        }

        // ä»å±‚æ¬¡åŒ–æ ‡ç­¾ä¸­è·å–æ‰€æœ‰å…³é”®è¯
        const keywords = getAllKeywords();

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            randomSearch();
            const searchInput = $('search-input');
            const searchClearBtn = $('search-clear-btn');
            let searchTimeout;

            searchInput.addEventListener('keypress', e => {
                if (e.key === 'Enter') {
                    clearTimeout(searchTimeout);
                    searchMusic();
                }
            });

            // Show/hide clear button based on input value and debounce search
            searchInput.addEventListener('input', () => {
                searchClearBtn.style.display = searchInput.value ? 'flex' : 'none';

                // é˜²æŠ–æœç´¢
                clearTimeout(searchTimeout);
                if (searchInput.value.trim()) {
                    searchTimeout = setTimeout(() => {
                        searchMusic();
                    }, 800);
                }
            });

            // Show clear button if search input already has value on load
            searchClearBtn.style.display = searchInput.value ? 'flex' : 'none';

            // Clear search input when clear button is clicked
            searchClearBtn.addEventListener('click', () => {
                clearTimeout(searchTimeout);
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                searchInput.focus();
            });

            // åŒå‡»å°é¢æ‰“å¼€æ­Œè¯
            $('player-cover').addEventListener('dblclick', openLyrics);
        });

        // æœç´¢è‰ºæœ¯å®¶
        function searchByArtist(artistName) {
            const cleanArtist = artistName.split(/&|,|feat\.|ft\./i)[0].trim();
            $('search-input').value = cleanArtist;
            searchMusic();
        }

        // æœç´¢æ­Œæ›²
        function searchBySong(songName) {
            // Remove parentheses and brackets with their contents from song name
            let cleanSongName = songName.replace(/\([^)]*\)|\[[^\]]*\]/g, '').trim();
            $('search-input').value = cleanSongName;
            searchMusic();
        }

        // éšæœºæœç´¢
        function randomSearch() {
            $('search-input').value = keywords[Math.floor(Math.random() * keywords.length)];
            searchMusic();
        }

        // æ™ºèƒ½éšæœºæœç´¢ - åŸºäºæ ‡ç­¾å±‚æ¬¡ç»“æ„
        function smartRandomSearch() {
            // ä»æ ‡ç­¾çš„é¡¶å±‚ç±»åˆ«ä¸­éšæœºé€‰æ‹©ä¸€ä¸ª
            const topLevelCategories = Object.keys(musicTags);
            if (topLevelCategories.length === 0) {
                randomSearch(); // å›é€€åˆ°æ™®é€šéšæœºæœç´¢
                return;
            }
            const randomCategory = topLevelCategories[Math.floor(Math.random() * topLevelCategories.length)];

            // ä»è¯¥ç±»åˆ«ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªå­ç±»åˆ«
            const subCategories = Object.keys(musicTags[randomCategory]);
            if (subCategories.length === 0) {
                randomSearch(); // å›é€€åˆ°æ™®é€šéšæœºæœç´¢
                return;
            }
            const randomSubCategory = subCategories[Math.floor(Math.random() * subCategories.length)];

            // ä»å­ç±»åˆ«ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªæ ‡ç­¾
            const tagsInSubCategory = musicTags[randomCategory][randomSubCategory];
            if (Array.isArray(tagsInSubCategory) && tagsInSubCategory.length > 0) {
                const randomTag = tagsInSubCategory[Math.floor(Math.random() * tagsInSubCategory.length)];
                if (randomTag) {  // ç¡®ä¿æ ‡ç­¾ä¸ä¸ºundefinedæˆ–null
                    $('search-input').value = randomTag;
                    searchMusic();
                    showToast(`æ™ºèƒ½æ¨èï¼š${randomTag} (${randomCategory} > ${randomSubCategory})`);
                } else {
                    randomSearch(); // å›é€€åˆ°æ™®é€šéšæœºæœç´¢
                }
            } else {
                // å¦‚æœå­ç±»åˆ«ä¸æ˜¯æ•°ç»„è€Œæ˜¯æ›´æ·±å±‚ç»“æ„ï¼Œåˆ™ç»§ç»­æ·±å…¥
                const deeperCategories = Object.keys(musicTags[randomCategory][randomSubCategory]);
                if (deeperCategories && deeperCategories.length > 0) {
                    const randomDeeperCategory = deeperCategories[Math.floor(Math.random() * deeperCategories.length)];
                    const tagsInDeeperCategory = musicTags[randomCategory][randomSubCategory][randomDeeperCategory];
                    if (Array.isArray(tagsInDeeperCategory) && tagsInDeeperCategory.length > 0) {
                        const randomTag = tagsInDeeperCategory[Math.floor(Math.random() * tagsInDeeperCategory.length)];
                        if (randomTag) {  // ç¡®ä¿æ ‡ç­¾ä¸ä¸ºundefinedæˆ–null
                            $('search-input').value = randomTag;
                            searchMusic();
                            showToast(`æ™ºèƒ½æ¨èï¼š${randomTag} (${randomCategory} > ${randomSubCategory} > ${randomDeeperCategory})`);
                        } else {
                            randomSearch(); // å›é€€åˆ°æ™®é€šéšæœºæœç´¢
                        }
                    } else {
                        // å›é€€åˆ°æ™®é€šéšæœºæœç´¢
                        randomSearch();
                    }
                } else {
                    // å›é€€åˆ°æ™®é€šéšæœºæœç´¢
                    randomSearch();
                }
            }
        }

        // æœç´¢éŸ³ä¹
        async function searchMusic() {
            const query = $('search-input').value?.trim();
            if (!query) return;

            // è§£æURLå‚æ•°
            const urlParams = getUrlParams();
            const isAppleOnly = urlParams.apple && !urlParams.youtube;
            const isYouTubeOnly = urlParams.youtube && !urlParams.apple;
            const isBoth = !isAppleOnly && !isYouTubeOnly; // é»˜è®¤æƒ…å†µï¼Œæ˜¾ç¤ºä¸¤ä¸ªæ¥æº

            // å°è¯•ä»ç¼“å­˜è·å–æœç´¢ç»“æœ
            const cacheKey = `search_${query}`;
            let cachedResults = CacheManager.get(cacheKey);

            if (cachedResults) {
                console.log('Using cached search results for:', query);
                state.playlist = cachedResults;
                renderResults(cachedResults);
                return;
            }

            $('results').innerHTML = `
                <div class="loading" style="grid-column: 1/-1;">
                    <div class="loading-spinner"></div>
                    <div>æ­£åœ¨æœç´¢...</div>
                </div>
            `;

            let iTunesResults = [];
            let youTubeResults = [];

            // æ ¹æ®URLå‚æ•°å†³å®šæœç´¢å“ªä¸ªæ¥æº
            if (!isYouTubeOnly) {
                // æœç´¢ iTunes API (å¦‚æœæœªæŒ‡å®šåªç”¨YouTube)
                try {
                    const res = await fetch(`https://itunes.apple.com/search?term=${encodeURIComponent(query)}&entity=song&limit=48&country=cn`);
                    if (res.ok) {
                        const iTunesData = await res.json();
                        iTunesResults = iTunesData.results || [];
                    } else {
                        console.error('iTunes API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç :', res.status);
                        iTunesResults = [];
                    }
                } catch (e) {
                    console.error('iTunes API æœç´¢å¤±è´¥:', e);
                    iTunesResults = [];
                }
            }

            if (!isAppleOnly) {
                // æœç´¢ YouTube (å¦‚æœæœªæŒ‡å®šåªç”¨iTunes)
                try {
                    const youTubeRes = await fetch(`https://api.yuangs.cc/youtubeapi/search/song?q=${encodeURIComponent(query)}&limit=48`);
                    if (youTubeRes.ok) {
                        const youTubeJson = await youTubeRes.json();
                        // console.log('YouTube API å“åº”:', youTubeJson); // Debug log

                        // Check if response has the expected structure
                        if (youTubeJson && youTubeJson.data) {
                            // If the API returns data in the expected format
                            youTubeResults = youTubeJson.data.map(item => ({
                                // å°† YouTube æ•°æ®è½¬æ¢ä¸º iTunes æ ¼å¼
                                trackId: item.video_id || item.id,
                                trackName: item.title || item.name,
                                artistName: Array.isArray(item.artists) ? item.artists.join(', ') : (item.artist || item.author || 'Unknown Artist'),
                                collectionName: item.album || 'YouTube Music',
                                artworkUrl100: item.thumbnail || item.thumbnails?.[1]?.url || item.image || 'https://i.ytimg.com/img/no_thumbnail.jpg',
                                previewUrl: `https://www.youtube.com/watch?v=${item.video_id || item.id}`,
                                kind: 'youtube',  // æ ‡è®°ä¸º YouTube æ¥æº
                                genre: item.category || item.genre || 'YouTube',
                                releaseDate: item.publish_date || item.publishedAt || new Date().toISOString(),
                                duration: item.duration || 'Unknown Duration'  // æ·»åŠ æ—¶é•¿ä¿¡æ¯
                            }));
                        } else {
                            console.warn('YouTube API å“åº”æ ¼å¼ä¸æ­£ç¡®:', youTubeJson);
                        }
                    } else {
                        console.error('YouTube API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç :', youTubeRes.status);
                    }
                } catch (e) {
                    console.error('YouTube API æœç´¢å¤±è´¥:', e);
                    // å¯èƒ½æ˜¯ CORS æˆ–ç½‘ç»œé—®é¢˜ï¼Œä¸ä¸­æ–­æ•´ä¸ªæœç´¢æµç¨‹
                }
            }

            // æ ¹æ®URLå‚æ•°å†³å®šæœ€ç»ˆå±•ç¤ºçš„æ­Œæ›²æ•°é‡ï¼ˆæ€»å…±48é¦–ï¼‰
            if (isAppleOnly) {
                // åªå±•ç¤ºiTunesæ¥æºï¼Œå–å‰48é¦–
                iTunesResults = iTunesResults.slice(0, 48);
                youTubeResults = [];
            } else if (isYouTubeOnly) {
                // åªå±•ç¤ºYouTubeæ¥æºï¼Œå–å‰48é¦–
                youTubeResults = youTubeResults.slice(0, 48);
                iTunesResults = [];
            } else {
                // é»˜è®¤æƒ…å†µï¼Œæ¯ä¸ªæ¥æºå±•ç¤º24é¦–ï¼ˆæ€»å…±48é¦–ï¼‰
                iTunesResults = iTunesResults.slice(0, 24);
                youTubeResults = youTubeResults.slice(0, 24);
            }

            // ç¼“å­˜æœç´¢ç»“æœï¼ˆæœ‰æ•ˆæœŸ1å°æ—¶ï¼‰
            CacheManager.set(cacheKey, { itunes: iTunesResults, youtube: youTubeResults }, 1);

            // ä¿å­˜åˆ° stateï¼Œç”¨äºæ’­æ”¾
            state.playlist = [...iTunesResults, ...youTubeResults];

            // æ¸²æŸ“ä¸¤åˆ—ç»“æœ
            renderSeparateResults(iTunesResults, youTubeResults);

            // åŒæ—¶ç¼“å­˜æ¯ä¸ªæ­Œæ›²çš„å…ƒæ•°æ®
            [...iTunesResults, ...youTubeResults].forEach(song => {
                const songCacheKey = generateCacheKey(song.artistName, song.trackName);
                CacheManager.set(songCacheKey, {
                    trackName: song.trackName,
                    artistName: song.artistName,
                    artworkUrl: song.artworkUrl100,
                    previewUrl: song.previewUrl,
                    collectionName: song.collectionName,
                    kind: song.kind  // ä¿å­˜æ¥æºç±»å‹
                }, 24); // 24å°æ—¶æœ‰æ•ˆæœŸ
            });
        }

        // æ¸²æŸ“åˆ†ç¦»çš„ç»“æœï¼ˆiTunes å’Œ YouTube åˆ†åˆ—æ˜¾ç¤ºï¼‰
        function renderSeparateResults(iTunesSongs, youTubeSongs) {
            if (iTunesSongs.length === 0 && youTubeSongs.length === 0) {
                $('results').innerHTML = `
                    <div class="empty-state" style="grid-column: 1/-1;">
                        <div class="empty-icon">ğŸ”</div>
                        <div class="empty-title">æœªæ‰¾åˆ°ç»“æœ</div>
                        <div class="empty-desc">æ¢ä¸ªå…³é”®è¯è¯•è¯•</div>
                    </div>
                `;
                return;
            }

            // è§£æURLå‚æ•°æ¥ç¡®å®šæ˜¾ç¤ºæ¨¡å¼
            const urlParams = getUrlParams();
            const isAppleOnly = urlParams.apple && !urlParams.youtube;
            const isYouTubeOnly = urlParams.youtube && !urlParams.apple;

            const renderSongList = (songs, startIndex) => {
                return songs.map((song, index) => {
                    const actualIndex = startIndex + index;
                    const songCacheKey = generateCacheKey(song.artistName, song.trackName);
                    const cachedSong = CacheManager.get(songCacheKey);
                    const coverUrl = (cachedSong?.artworkUrl || song.artworkUrl100).replace('100x100bb', '300x300bb');
                    const isYouTube = song.kind === 'youtube' || song.previewUrl?.includes('youtube.com');

                    return `
                        <div class="song-card" data-index="${actualIndex}" onclick="playSong(${actualIndex})">
                            <div class="song-cover">
                                <img src="${coverUrl}" loading="lazy" alt="">
                                <div class="play-overlay">
                                    <div class="play-overlay-btn">â–¶</div>
                                </div>
                                ${song.trackId ? `<div class="song-options" onclick="event.stopPropagation(); toggleOptionsMenu(event, '${song.trackId}', '${escapeHtml(song.trackName)}', '${escapeHtml(song.artistName)}', '${coverUrl}', ${isYouTube})">â‹¯</div>` : ''}
                            </div>
                            <div class="song-title">${isYouTube ? '<span style="color: #ff6b6b;">â–¶</span> ' : ''}${escapeHtml(song.trackName)}</div>
                            <div class="song-artist">${escapeHtml(song.artistName)}</div>
                        </div>
                    `;
                }).join('');
            };

            // æ ¹æ®URLå‚æ•°å†³å®šæ¸²æŸ“æ¨¡å¼
            if (isAppleOnly || isYouTubeOnly) {
                // åªæ˜¾ç¤ºä¸€ä¸ªæ¥æºï¼Œä½†è®©ç½‘æ ¼å¸ƒå±€ä»ç„¶æ˜¾ç¤ºæ­Œæ›²ä¸ºå¤šåˆ—
                const sourceName = isAppleOnly ? 'Apple Music' : 'YouTube Music';
                const songsToDisplay = isAppleOnly ? iTunesSongs : youTubeSongs;

                $('results').innerHTML = `
                    <div class="results-columns" style="grid-column: 1 / -1;">
                        <div class="results-column" style="grid-column: 1 / -1;"> <!-- Use full width -->
                            <div class="simple-header">${sourceName}</div>
                            <div class="grid">
                                ${songsToDisplay.length > 0 ? renderSongList(songsToDisplay, 0) : '<div class="empty-message">æš‚æ— ç»“æœ</div>'}
                            </div>
                        </div>
                    </div>
                `;
            } else {
                // é»˜è®¤æ˜¾ç¤ºä¸¤ä¸ªæ¥æº
                $('results').innerHTML = `
                    <div class="results-columns" style="grid-column: 1 / -1;">
                        <div class="results-column">
                            <div class="simple-header">iTunes</div>
                            <div class="grid">
                                ${iTunesSongs.length > 0 ? renderSongList(iTunesSongs, 0) : '<div class="empty-message">æš‚æ— ç»“æœ</div>'}
                            </div>
                        </div>
                        <div class="results-column">
                            <div class="simple-header">YouTube</div>
                            <div class="grid">
                                ${youTubeSongs.length > 0 ? renderSongList(youTubeSongs, iTunesSongs.length) : '<div class="empty-message">æš‚æ— ç»“æœ</div>'}
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        // æ¸²æŸ“ç»“æœ
        function renderResults(songs) {
            if (songs.length === 0) {
                $('results').innerHTML = `
                    <div class="empty-state" style="grid-column: 1/-1;">
                        <div class="empty-icon">ğŸ”</div>
                        <div class="empty-title">æœªæ‰¾åˆ°ç»“æœ</div>
                        <div class="empty-desc">æ¢ä¸ªå…³é”®è¯è¯•è¯•</div>
                    </div>
                `;
                return;
            }

            $('results').innerHTML = songs.map((song, index) => {
                // æ£€æŸ¥æ˜¯å¦æœ‰ç¼“å­˜çš„å…ƒæ•°æ®
                const songCacheKey = generateCacheKey(song.artistName, song.trackName);
                const cachedSong = CacheManager.get(songCacheKey);

                // ä½¿ç”¨ç¼“å­˜çš„æˆ–åŸå§‹çš„å°é¢URL
                const coverUrl = (cachedSong?.artworkUrl || song.artworkUrl100).replace('100x100bb', '300x300bb');

                // æ£€æŸ¥æ˜¯å¦æ˜¯ YouTube æ¥æº
                const isYouTube = song.kind === 'youtube' || song.previewUrl?.includes('youtube.com');

                return `
                    <div class="song-card" data-index="${index}" onclick="playSong(${index})">
                        <div class="song-cover">
                            <img src="${coverUrl}" loading="lazy" alt="">
                            <div class="play-overlay">
                                <div class="play-overlay-btn">â–¶</div>
                            </div>
                            ${song.trackId ? `<div class="song-options" onclick="event.stopPropagation(); toggleOptionsMenu(event, '${song.trackId}', '${escapeHtml(song.trackName)}', '${escapeHtml(song.artistName)}', '${coverUrl}', ${isYouTube})">â‹¯</div>` : ''}
                        </div>
                        <div class="song-title">${isYouTube ? '<span style="color: #ff6b6b;">â–¶</span> ' : ''}${escapeHtml(song.trackName)}</div>
                        <div class="song-artist">${escapeHtml(song.artistName)}</div>
                    </div>
                `;
            }).join('');
        }

        // HTML è½¬ä¹‰
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // æ’­æ”¾æ­Œæ›²
        function playSong(index) {
            const song = state.playlist[index];
            if (!song) return;

            // æ£€æŸ¥æ˜¯å¦æ˜¯ YouTube æ¥æºçš„æ­Œæ›²
            const isYouTube = song.kind === 'youtube' || song.previewUrl?.includes('youtube.com');

            if (isYouTube) {
                // å¦‚æœæ˜¯ YouTube æ­Œæ›²ï¼Œä½¿ç”¨ YouTube æ’­æ”¾å‡½æ•°
                playYouTubeSong(
                    song.trackId,
                    song.trackName || 'æœªçŸ¥æ­Œæ›²',
                    song.artistName || 'æœªçŸ¥è‰ºæœ¯å®¶',
                    song.artworkUrl100 || song.thumbnails?.[1]?.url || 'https://i.ytimg.com/img/no_thumbnail.jpg'
                );
                return;
            }

            state.currentTrack = song;
            state.currentIndex = index;

            // ä»ç¼“å­˜è·å–å®Œæ•´æ•°æ®ï¼Œå¦‚æœæœ‰çš„è¯
            const songCacheKey = generateCacheKey(song.artistName, song.trackName);
            const cachedSong = CacheManager.get(songCacheKey);

            // ä½¿ç”¨ç¼“å­˜æ•°æ®æˆ–åŸå§‹æ•°æ®
            const trackName = cachedSong?.trackName || song.trackName;
            const artistName = cachedSong?.artistName || song.artistName;
            const artworkUrl = cachedSong?.artworkUrl || song.artworkUrl100;
            const previewUrl = cachedSong?.previewUrl || song.previewUrl;
            const collectionName = cachedSong?.collectionName || song.collectionName || song.collectionName;

            const cover = artworkUrl.replace('100x100bb', '600x600bb');

            // æ›´æ–°é¡¶éƒ¨ä¿¡æ¯æ 
            const titleTextEl = $('player-title-text');
            const artistTextEl = $('player-artist-text');
            const wikiBtn = $('player-wiki-btn');

            titleTextEl.textContent = trackName;
            artistTextEl.textContent = artistName;
            $('player-cover').src = cover;

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶åˆ°æ ‡é¢˜ï¼ˆæœç´¢æ­Œæ›²åï¼‰
            titleTextEl.onclick = () => {
                searchBySong(trackName);
            };
            titleTextEl.title = 'ç‚¹å‡»æœç´¢è¯¥æ­Œæ›²';

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶åˆ°è‰ºæœ¯å®¶åç§°ï¼ˆæœç´¢è‰ºæœ¯å®¶ï¼‰
            artistTextEl.onclick = () => {
                searchByArtist(artistName);
            };
            artistTextEl.title = 'ç‚¹å‡»æœç´¢è¯¥è‰ºæœ¯å®¶çš„æ­Œæ›²';

            // è®¾ç½®ç»´åŸºç™¾ç§‘æŒ‰é’®
            const cleanArtistName = artistName.split(/&|,|feat\.|ft\./i)[0].trim();
            wikiBtn.style.display = 'flex';
            wikiBtn.onclick = () => {
                const wikiUrl = `https://zh.wikipedia.org/wiki/${encodeURIComponent(cleanArtistName)}`;
                window.open(wikiUrl, '_blank');
            };
            wikiBtn.title = `æŸ¥çœ‹ ${cleanArtistName} çš„ç»´åŸºç™¾ç§‘`;

            // è®¾ç½®æ ‡ç­¾æ¨èæŒ‰é’®
            const tagBtn = $('player-tag-btn');
            tagBtn.style.display = 'flex';
            tagBtn.onclick = () => {
                showCurrentSongTags();
            };
            tagBtn.title = 'æŸ¥çœ‹æ­Œæ›²æ ‡ç­¾æ¨è';

            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ»šåŠ¨
            const checkScroll = (el) => {
                // å…ˆé‡ç½®ï¼Œä»¥ä¾¿å‡†ç¡®æµ‹é‡
                el.classList.remove('scroll-text');
                el.style.transform = 'none';

                // æ¯”è¾ƒå†…éƒ¨æ–‡æœ¬å®½åº¦å’Œå¤–éƒ¨å®¹å™¨å®½åº¦
                const containerWidth = el.parentElement.clientWidth;
                const textWidth = el.scrollWidth;

                if (textWidth > containerWidth) {
                    const distance = containerWidth - textWidth; // è´Ÿå€¼ï¼Œå‘å·¦ç§»åŠ¨
                    const duration = Math.abs(distance) / 30 + 2; // é€Ÿåº¦æ§åˆ¶ï¼šæ¯ç§’30pxï¼ŒåŸºç¡€2s

                    el.style.setProperty('--scroll-distance', `${distance}px`);
                    el.style.setProperty('--duration', `${duration}s`);
                    el.classList.add('scroll-text');
                }
            };

            // ç¨å¾®å»¶æ—¶ä¸€ç‚¹ï¼Œç¡®ä¿ DOM æ¸²æŸ“å®Œæˆ
            setTimeout(() => {
                checkScroll(titleTextEl);
                checkScroll(artistTextEl);
            }, 50);

            // èƒŒæ™¯
            $('bg-album').style.backgroundImage = `url(${cover})`;
            $('bg-album').classList.add('active');

            // æ ‡è®°å½“å‰æ’­æ”¾
            document.querySelectorAll('.song-card').forEach((card, i) => {
                card.classList.toggle('playing', i === index);
            });

            // æ’­æ”¾
            audio.src = previewUrl;
            audio.play()
                .then(() => updatePlayState(true))
                .catch(() => updatePlayState(false));

            // å¼¹å¹•
            startDanmaku();

            // é¢„åŠ è½½æ­Œè¯
            $('lyrics-title').textContent = trackName;
            $('lyrics-artist').textContent = artistName;
            // Set up Wikipedia link for artist name
            setupWikipediaLink(artistName);
            $('lyrics-cover').src = cover;
            $('lyrics-text').textContent = 'åŠ è½½ä¸­...';
            $('lyrics-wiki').classList.remove('show');

            fetchLyrics(artistName, trackName);
            fetchArtistWiki(artistName);

            // Add click event to artist name to search for artist's songs (left click)
            // and open Wikipedia (Ctrl/Cmd+click)
            $('lyrics-artist').onclick = function (event) {
                if (event.ctrlKey || event.metaKey) {
                    // Ctrl/Cmd + click: open Wikipedia
                    const wikiUrl = $('lyrics-artist').dataset.wikiUrl || `https://zh.wikipedia.org/wiki/${encodeURIComponent(artistName.split(/&|,|feat\.|ft\./i)[0].trim())}`;
                    window.open(wikiUrl, '_blank');
                } else {
                    // Regular click: search for artist's songs
                    searchByArtist(artistName);
                }
            };
            $('lyrics-artist').style.cursor = 'pointer';
            $('lyrics-artist').title = 'ç‚¹å‡»æœç´¢è¯¥è‰ºæœ¯å®¶çš„æ­Œæ›² (Ctrl/Cmd+ç‚¹å‡»è®¿é—®ç»´åŸºç™¾ç§‘)';

            // æ·»åŠ åˆ°å†å²è®°å½•
            HistoryManager.add(song);

            // æ›´æ–°ç³»ç»Ÿåª’ä½“ä¸­å¿ƒæ§åˆ¶ (Media Session API)
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: trackName,
                    artist: artistName,
                    album: collectionName || 'å¹¿å±±éŸ³ä¹',
                    artwork: [
                        { src: artworkUrl.replace('100x100bb', '96x96bb'), sizes: '96x96', type: 'image/jpeg' },
                        { src: artworkUrl.replace('100x100bb', '128x128bb'), sizes: '128x128', type: 'image/jpeg' },
                        { src: artworkUrl.replace('100x100bb', '192x192bb'), sizes: '192x192', type: 'image/jpeg' },
                        { src: artworkUrl.replace('100x100bb', '256x256bb'), sizes: '256x256', type: 'image/jpeg' },
                        { src: cover, sizes: '512x512', type: 'image/jpeg' }
                    ]
                });

                navigator.mediaSession.setActionHandler('play', togglePlay);
                navigator.mediaSession.setActionHandler('pause', togglePlay);
                navigator.mediaSession.setActionHandler('previoustrack', playPrevious);
                navigator.mediaSession.setActionHandler('nexttrack', () => playNext(false));
            }

            // æ›´æ–°æ”¶è—æŒ‰é’®çŠ¶æ€
            updateFavoriteButton();

            // æ›´æ–°æ¨èæ ‡ç­¾
            updateRecommendationTags(song);
        }

        // æ›´æ–°æ¨èæ ‡ç­¾
        function updateRecommendationTags(song) {
            const recommendations = getSongRecommendations(song);
            const container = $('recommendation-tags-container');
            const tagsElement = $('recommendation-tags');
            const showMoreBtn = $('show-more-recommendations');

            if (!recommendations || recommendations.length === 0) {
                tagsElement.style.display = 'none';
                return;
            }

            // è¿‡æ»¤æ‰æ— æ•ˆçš„æ¨èæ ‡ç­¾
            const validRecommendations = recommendations.filter(tag => tag && typeof tag === 'string');

            if (validRecommendations.length === 0) {
                tagsElement.style.display = 'none';
                return;
            }

            // åªæ˜¾ç¤ºå‰5ä¸ªæ¨è
            const displayRecommendations = validRecommendations.slice(0, 5);

            // æ¸²æŸ“æ¨èæ ‡ç­¾
            container.innerHTML = displayRecommendations.map(tag => `
                <span class="recommendation-tag" onclick="searchByTag('${tag}')">${escapeHtml(tag)}</span>
            `).join('');

            // å¦‚æœè¿˜æœ‰æ›´å¤šæ¨èï¼Œæ˜¾ç¤º"å±•å¼€æ›´å¤š"æŒ‰é’®
            if (validRecommendations.length > 5) {
                showMoreBtn.style.display = 'block';
                showMoreBtn.onclick = () => {
                    // æ˜¾ç¤ºæ‰€æœ‰æ¨è
                    container.innerHTML = validRecommendations.map(tag => `
                        <span class="recommendation-tag" onclick="searchByTag('${tag}')">${escapeHtml(tag)}</span>
                    `).join('');
                    showMoreBtn.style.display = 'none';
                };
            } else {
                showMoreBtn.style.display = 'none';
            }

            // æ˜¾ç¤ºæ¨èåŒºåŸŸ
            tagsElement.style.display = 'block';
        }

        // YouTube éŸ³ä¹ API æœç´¢å‡½æ•°
        async function searchYouTubeMusic(query) {
            try {
                const response = await fetch(`https://api.yuangs.cc/youtubeapi/search/song?q=${encodeURIComponent(query)}&limit=10`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('YouTube search API å“åº”:', data); // Debug log

                    if (data && data.data && data.data.length > 0) {
                        // ç¡®ä¿è¿”å›çš„æ•°æ®æ ¼å¼ä¸€è‡´
                        return data.data.map(item => ({
                            ...item,
                            // ç¡®ä¿è‰ºæœ¯å®¶å­—æ®µæ­£ç¡®æ˜ å°„
                            artist: Array.isArray(item.artists) ? item.artists.join(', ') : item.artist,
                            // å¦‚æœéœ€è¦ iTunes å…¼å®¹æ ¼å¼
                            artistName: Array.isArray(item.artists) ? item.artists.join(', ') : (item.artist || item.author || 'Unknown Artist'),
                            trackName: item.title || item.name
                        }));
                    }
                } else {
                    console.error('YouTube API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç :', response.status);
                }
                return [];
            } catch (error) {
                console.error('YouTube API æœç´¢å¤±è´¥:', error);
                return [];
            }
        }

        // æ’­æ”¾ YouTube å®Œæ•´æ­Œæ›²
        async function playYouTubeSong(videoId, title, artist, coverUrl = '') {
            if (!videoId) return;

            // åˆ›å»º YouTube éŸ³é¢‘æµ URL
            const audioUrl = `https://www.youtube.com/watch?v=${videoId}`;

            // æ›´æ–°æ’­æ”¾çŠ¶æ€
            state.currentTrack = {
                trackId: videoId,
                trackName: title,
                artistName: artist,
                artworkUrl100: coverUrl || 'https://i.ytimg.com/img/no_thumbnail.jpg',
                previewUrl: audioUrl
            };

            // æ›´æ–°æ’­æ”¾å™¨ UI
            const cover = coverUrl || 'https://i.ytimg.com/img/no_thumbnail.jpg';
            $('player-cover').src = cover;

            const titleTextEl = $('player-title-text');
            const artistTextEl = $('player-artist-text');

            titleTextEl.textContent = title;
            artistTextEl.textContent = artist;

            // æ›´æ–°é¡¶éƒ¨ä¿¡æ¯æ 
            $('player-cover').src = cover;
            $('bg-album').style.backgroundImage = `url(${cover})`;
            $('bg-album').classList.add('active');

            // è®¾ç½®ç»´åŸºç™¾ç§‘æŒ‰é’®
            const wikiBtn = $('player-wiki-btn');
            const cleanArtistName = artist.split(/&|,|feat\.|ft\./i)[0].trim();
            wikiBtn.style.display = 'flex';
            wikiBtn.onclick = () => {
                const wikiUrl = `https://zh.wikipedia.org/wiki/${encodeURIComponent(cleanArtistName)}`;
                window.open(wikiUrl, '_blank');
            };
            wikiBtn.title = `æŸ¥çœ‹ ${cleanArtistName} çš„ç»´åŸºç™¾ç§‘`;

            // è®¾ç½®æ ‡ç­¾æ¨èæŒ‰é’®
            const tagBtn = $('player-tag-btn');
            tagBtn.style.display = 'flex';
            tagBtn.onclick = () => {
                showCurrentSongTags();
            };
            tagBtn.title = 'æŸ¥çœ‹æ­Œæ›²æ ‡ç­¾æ¨è';

            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ»šåŠ¨
            const checkScroll = (el) => {
                el.classList.remove('scroll-text');
                el.style.transform = 'none';

                const containerWidth = el.parentElement.clientWidth;
                const textWidth = el.scrollWidth;

                if (textWidth > containerWidth) {
                    const distance = containerWidth - textWidth;
                    const duration = Math.abs(distance) / 30 + 2;

                    el.style.setProperty('--scroll-distance', `${distance}px`);
                    el.style.setProperty('--duration', `${duration}s`);
                    el.classList.add('scroll-text');
                }
            };

            setTimeout(() => {
                checkScroll(titleTextEl);
                checkScroll(artistTextEl);
            }, 50);

            // æ’­æ”¾éŸ³é¢‘
            audio.src = audioUrl;
            audio.load(); // åŠ è½½æ–°éŸ³é¢‘æº
            audio.play()
                .then(() => updatePlayState(true))
                .catch(error => {
                    console.error('æ’­æ”¾å¤±è´¥:', error);
                    updatePlayState(false);

                    // å°è¯•ä½¿ç”¨ YouTube URL as fallback
                    const fallbackAudioUrl = `https://www.youtube.com/watch?v=${videoId}`;
                    audio.src = fallbackAudioUrl;
                    audio.load();
                    audio.play()
                        .then(() => updatePlayState(true))
                        .catch(err => {
                            console.error('YouTube æ’­æ”¾ä¹Ÿå¤±è´¥:', err);
                            showToast('å³å°†å‡†å¤‡å°±ç»ªï¼Œåˆ«ç€æ€¥');
                        });
                });

            // å¼¹å¹•
            startDanmaku();

            // é¢„åŠ è½½æ­Œè¯
            $('lyrics-title').textContent = title;
            $('lyrics-artist').textContent = artist;
            setupWikipediaLink(artist);
            $('lyrics-cover').src = cover;
            $('lyrics-text').textContent = 'åŠ è½½ä¸­...';
            $('lyrics-wiki').classList.remove('show');

            fetchLyrics(artist, title);
            fetchArtistWiki(artist);

            // æ·»åŠ åˆ°å†å²è®°å½•
            HistoryManager.add({
                trackId: videoId,
                trackName: title,
                artistName: artist,
                artworkUrl100: cover
            });

            // æ›´æ–°ç³»ç»Ÿåª’ä½“ä¸­å¿ƒæ§åˆ¶ (Media Session API)
            if ('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: title,
                    artist: artist,
                    album: 'YouTube Music',
                    artwork: [
                        { src: cover, sizes: '96x96', type: 'image/jpeg' },
                        { src: cover, sizes: '128x128', type: 'image/jpeg' },
                        { src: cover, sizes: '192x192', type: 'image/jpeg' },
                        { src: cover, sizes: '256x256', type: 'image/jpeg' },
                        { src: cover, sizes: '512x512', type: 'image/jpeg' }
                    ]
                });

                navigator.mediaSession.setActionHandler('play', togglePlay);
                navigator.mediaSession.setActionHandler('pause', togglePlay);
                navigator.mediaSession.setActionHandler('previoustrack', playPrevious);
                navigator.mediaSession.setActionHandler('nexttrack', () => playNext(false));
            }

            // æ›´æ–°æ”¶è—æŒ‰é’®çŠ¶æ€
            updateFavoriteButton();

            // æ›´æ–°æ¨èæ ‡ç­¾
            updateRecommendationTags(state.currentTrack);
        }

        // ä» YouTube æœç´¢å¹¶æ’­æ”¾æ­Œæ›²
        async function searchAndPlayYouTubeSong(query) {
            const results = await searchYouTubeMusic(query);
            if (results && results.length > 0) {
                const song = results[0]; // ä½¿ç”¨ç¬¬ä¸€ä¸ªç»“æœ
                playYouTubeSong(
                    song.video_id,
                    song.title || 'æœªçŸ¥æ­Œæ›²',
                    song.artist || 'æœªçŸ¥è‰ºæœ¯å®¶',
                    song.thumbnail || song.thumbnails?.[1]?.url || ''
                );
                return true;
            }
            return false;
        }

        // æŒ‰æ ‡ç­¾æœç´¢
        function searchByTag(tag) {
            if (!tag) {
                return;
            }
            $('search-input').value = tag;
            searchMusic();
        }

        // æ˜¾ç¤ºå½“å‰æ’­æ”¾æ­Œæ›²çš„æ ‡ç­¾å±‚æ¬¡ç»“æ„
        function showCurrentSongTags() {
            if (!state.currentTrack) {
                showToast('è¯·å…ˆæ’­æ”¾ä¸€é¦–æ­Œæ›²');
                return;
            }

            const song = state.currentTrack;
            const recommendations = getSongRecommendations(song);

            if (!recommendations || recommendations.length === 0) {
                showToast('æœªæ‰¾åˆ°ç›¸å…³æ ‡ç­¾');
                return;
            }

            // è¿‡æ»¤æ‰æ— æ•ˆçš„æ¨èæ ‡ç­¾
            const validRecommendations = recommendations.filter(tag => tag && typeof tag === 'string');

            if (validRecommendations.length === 0) {
                showToast('æœªæ‰¾åˆ°æœ‰æ•ˆæ ‡ç­¾');
                return;
            }

            // åˆ›å»ºæ ‡ç­¾è¯¦æƒ…å¼¹çª—
            const modal = document.createElement('div');
            modal.className = 'tag-details-modal';
            modal.innerHTML = `
                <div class="modal-overlay" onclick="this.parentElement.remove()">
                    <div class="modal-content" onclick="event.stopPropagation()">
                        <h3>ç›¸å…³æ ‡ç­¾æ¨è</h3>
                        <div class="tags-list">
                            ${validRecommendations.map(tag => `
                                <div class="tag-item" onclick="searchByTag('${tag}')">
                                    <span class="tag-name">${escapeHtml(tag)}</span>
                                    <span class="tag-search-btn">ğŸ”</span>
                                </div>
                            `).join('')}
                        </div>
                        <button class="modal-close-btn" onclick="this.parentElement.parentElement.remove()">å…³é—­</button>
                    </div>
                </div>
            `;

            // æ·»åŠ æ ·å¼
            if (!document.querySelector('#tag-details-modal-styles')) {
                const styles = document.createElement('style');
                styles.id = 'tag-details-modal-styles';
                styles.textContent = `
                    .tag-details-modal .modal-overlay {
                        position: fixed;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(0,0,0,0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        z-index: 10000;
                    }
                    .tag-details-modal .modal-content {
                        background: var(--card);
                        border-radius: 16px;
                        padding: 24px;
                        max-width: 400px;
                        width: 90%;
                        max-height: 80vh;
                        overflow-y: auto;
                        border: 1px solid var(--glass-border);
                        backdrop-filter: blur(20px);
                    }
                    .tag-details-modal h3 {
                        margin: 0 0 16px;
                        color: var(--text);
                        text-align: center;
                    }
                    .tags-list {
                        display: flex;
                        flex-direction: column;
                        gap: 8px;
                        margin-bottom: 16px;
                    }
                    .tag-item {
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                        padding: 10px 12px;
                        background: var(--glass);
                        border-radius: 8px;
                        cursor: pointer;
                        transition: all 0.2s ease;
                    }
                    .tag-item:hover {
                        background: var(--primary);
                        color: white;
                    }
                    .tag-search-btn {
                        opacity: 0.7;
                        transition: opacity 0.2s ease;
                    }
                    .tag-item:hover .tag-search-btn {
                        opacity: 1;
                    }
                    .modal-close-btn {
                        width: 100%;
                        padding: 12px;
                        background: var(--glass);
                        border: 1px solid var(--glass-border);
                        color: var(--text);
                        border-radius: 8px;
                        cursor: pointer;
                        font-weight: 500;
                    }
                    .modal-close-btn:hover {
                        background: var(--card-hover);
                    }
                `;
                document.head.appendChild(styles);
            }

            document.body.appendChild(modal);
        }

        // æ›´æ–°æ’­æ”¾çŠ¶æ€
        function updatePlayState(playing) {
            state.isPlaying = playing;
            const btn = $('play-btn');
            btn.textContent = playing ? 'â¸' : 'â–¶';
            btn.setAttribute('data-playing', playing); // ç”¨äº CSS æ ·å¼ä¿®æ­£
            $('player-cover').classList.toggle('spinning', playing);
        }

        // éšè—æ’­æ”¾å™¨æŒ‰é’®
        function hidePlayerButtons() {
            const wikiBtn = $('player-wiki-btn');
            const tagBtn = $('player-tag-btn');
            if (wikiBtn) wikiBtn.style.display = 'none';
            if (tagBtn) tagBtn.style.display = 'none';
        }

        // æ’­æ”¾/æš‚åœ
        function togglePlay() {
            if (!state.currentTrack && state.playlist.length > 0) {
                // å¦‚æœæ²¡æœ‰å½“å‰æ’­æ”¾çš„æ­Œæ›²ä½†æœ‰æ’­æ”¾åˆ—è¡¨ï¼Œåˆ™æ’­æ”¾ç¬¬ä¸€é¦–
                playSong(0);
            } else if (state.currentTrack) {
                // æ£€æŸ¥æ˜¯å¦æ˜¯ YouTube æ¥æºçš„æ­Œæ›²
                const isYouTube = state.currentTrack.kind === 'youtube' ||
                    (state.currentTrack.previewUrl && state.currentTrack.previewUrl.includes('youtube.com'));

                if (isYouTube) {
                    toggleYouTubePlay();
                } else {
                    // å¯¹äº iTunes æ­Œæ›²ï¼Œç»§ç»­ä½¿ç”¨æ ‡å‡†éŸ³é¢‘å…ƒç´ 
                    if (audio.src) {
                        if (audio.paused) {
                            audio.play()
                                .then(() => updatePlayState(true))
                                .catch(error => {
                                    console.error('æ— æ³•æ’­æ”¾éŸ³é¢‘:', error);
                                    // If standard audio fails, try to initialize YouTube player if it's a YouTube source
                                    if (isYouTube) {
                                        toggleYouTubePlay();
                                    }
                                });
                        } else {
                            audio.pause();
                            updatePlayState(false);
                        }
                    }
                }
            }
        }

        // åœ¨ YouTube æ’­æ”¾å™¨ä¸­æ’­æ”¾ä¸‹ä¸€é¦–
        function playNextForYouTube() {
            if (state.playMode === 'single') {
                // å•æ›²å¾ªç¯ï¼Œé‡æ–°æ’­æ”¾å½“å‰æ­Œæ›²
                if (state.youtubePlayer) {
                    state.youtubePlayer.seekTo(0);
                    state.youtubePlayer.playVideo();
                }
                return;
            }

            if (state.playlist.length === 0) return;

            let newIndex;
            if (state.playMode === 'random') {
                newIndex = Math.floor(Math.random() * state.playlist.length);
                // å°½é‡é¿å…éšæœºåˆ°åŒä¸€é¦–ï¼ˆé™¤éåªæœ‰ä¸€é¦–ï¼‰
                if (state.playlist.length > 1 && newIndex === state.currentIndex) {
                    newIndex = (newIndex + 1) % state.playlist.length;
                }
            } else {
                newIndex = (state.currentIndex + 1) % state.playlist.length;
            }
            playSong(newIndex);
        }

        // åˆ‡æ¢æ’­æ”¾æ¨¡å¼
        function togglePlayMode() {
            const modes = ['sequence', 'random', 'single'];
            const currentIdx = modes.indexOf(state.playMode);
            const nextIdx = (currentIdx + 1) % modes.length;
            state.playMode = modes[nextIdx];

            const btn = $('mode-btn');
            switch (state.playMode) {
                case 'sequence':
                    btn.textContent = 'ğŸ”';
                    btn.title = 'åˆ—è¡¨å¾ªç¯';
                    showToast('åˆ—è¡¨å¾ªç¯');
                    break;
                case 'random':
                    btn.textContent = 'ğŸ”€';
                    btn.title = 'éšæœºæ’­æ”¾';
                    showToast('éšæœºæ’­æ”¾');
                    break;
                case 'single':
                    btn.textContent = 'ğŸ”‚';
                    btn.title = 'å•æ›²å¾ªç¯';
                    showToast('å•æ›²å¾ªç¯');
                    break;
            }
        }

        // ä¸Šä¸€é¦–/ä¸‹ä¸€é¦–
        function playPrevious() {
            if (state.playlist.length === 0) return;

            let newIndex;
            if (state.playMode === 'random') {
                newIndex = Math.floor(Math.random() * state.playlist.length);
            } else {
                newIndex = (state.currentIndex - 1 + state.playlist.length) % state.playlist.length;
            }
            playSong(newIndex);
        }

        function playNext(auto = false) {
            if (state.playlist.length === 0) return;

            // å¦‚æœæ˜¯è‡ªåŠ¨æ’­æ”¾ï¼ˆæ’­æ”¾ç»“æŸè§¦å‘ï¼‰ä¸”æ˜¯å•æ›²å¾ªç¯
            if (auto && state.playMode === 'single') {
                audio.currentTime = 0;
                audio.play();
                return;
            }

            let newIndex;
            if (state.playMode === 'random') {
                newIndex = Math.floor(Math.random() * state.playlist.length);
                // å°½é‡é¿å…éšæœºåˆ°åŒä¸€é¦–ï¼ˆé™¤éåªæœ‰ä¸€é¦–ï¼‰
                if (state.playlist.length > 1 && newIndex === state.currentIndex) {
                    newIndex = (newIndex + 1) % state.playlist.length;
                }
            } else {
                newIndex = (state.currentIndex + 1) % state.playlist.length;
            }
            playSong(newIndex);
        }

        // è¿›åº¦æ¡
        audio.ontimeupdate = () => {
            // Only update progress bar for non-YouTube sources (iTunes previews)
            if (!state.currentTrack || !(state.currentTrack.kind === 'youtube' ||
                (state.currentTrack.previewUrl && state.currentTrack.previewUrl.includes('youtube.com')))) {
                if (isNaN(audio.duration)) return;
                const pct = (audio.currentTime / audio.duration) * 100;
                $('progress-fill').style.width = pct + '%';
                $('current-time').textContent = formatTime(audio.currentTime);
            }
        };

        audio.onloadedmetadata = () => {
            // Only update duration for non-YouTube sources
            if (!state.currentTrack || !(state.currentTrack.kind === 'youtube' ||
                (state.currentTrack.previewUrl && state.currentTrack.previewUrl.includes('youtube.com')))) {
                $('total-time').textContent = formatTime(audio.duration);
            }
        };

        audio.onended = () => {
            // For YouTube, we rely on the YouTube player's onStateChange event
            if (!state.currentTrack || !(state.currentTrack.kind === 'youtube' ||
                (state.currentTrack.previewUrl && state.currentTrack.previewUrl.includes('youtube.com')))) {
                updatePlayState(false);
                playNext(true); // ä¼ å…¥ true è¡¨ç¤ºè‡ªåŠ¨æ’­æ”¾
            }
        };

        // ä¸º YouTube æ’­æ”¾å™¨åˆ›å»ºå®šæ—¶å™¨æ¥æ›´æ–°è¿›åº¦ - ä½¿ç”¨æ›´é¢‘ç¹çš„æ›´æ–°
        // Using a more robust interval that can continue in background
        let youtubeProgressInterval = setInterval(() => {
            if (state.youtubePlayer && state.isYouTubePlaying) {
                try {
                    const currentTime = state.youtubePlayer.getCurrentTime();
                    const duration = state.youtubePlayer.getDuration();

                    if (!isNaN(duration) && !isNaN(currentTime) && duration > 0) {
                        const pct = (currentTime / duration) * 100;
                        $('progress-fill').style.width = pct + '%';
                        $('current-time').textContent = formatTime(currentTime);
                        $('total-time').textContent = formatTime(duration);

                        // Update media session position state for background playback controls
                        if ('setPositionState' in navigator.mediaSession) {
                            navigator.mediaSession.setPositionState({
                                duration: duration,
                                playbackRate: 1.0,
                                position: currentTime
                            });
                        }
                    }
                } catch (e) {
                    // å¦‚æœ YouTube æ’­æ”¾å™¨è¿˜æ²¡å‡†å¤‡å¥½ï¼Œå¿½ç•¥é”™è¯¯
                }
            }
        }, 500); // æ¯0.5ç§’æ›´æ–°ä¸€æ¬¡è¿›åº¦ï¼Œä½¿æ—¶é—´è½´æ›´æµç•…

        // Store the interval ID so we can clear it if needed
        state.youtubeProgressInterval = youtubeProgressInterval;

        // Additional progress update function specifically for PWA compatibility
        let pwaProgressInterval = null;

        function startPWAProgressUpdates() {
            if (pwaProgressInterval) {
                clearInterval(pwaProgressInterval);
            }

            pwaProgressInterval = setInterval(() => {
                if (state.youtubePlayer && state.isYouTubePlaying) {
                    updateYouTubeProgress();
                }
            }, 800); // Slightly longer than the main interval to avoid conflicts
        }

        function stopPWAProgressUpdates() {
            if (pwaProgressInterval) {
                clearInterval(pwaProgressInterval);
                pwaProgressInterval = null;
            }
        }

        function updateYouTubeProgress() {
            if (state.youtubePlayer) {
                try {
                    const currentTime = state.youtubePlayer.getCurrentTime();
                    const duration = state.youtubePlayer.getDuration();

                    if (!isNaN(duration) && !isNaN(currentTime) && duration > 0) {
                        const pct = (currentTime / duration) * 100;
                        $('progress-fill').style.width = pct + '%';
                        $('current-time').textContent = formatTime(currentTime);
                        $('total-time').textContent = formatTime(duration);

                        // Update media session position state for background playback controls
                        if ('setPositionState' in navigator.mediaSession) {
                            navigator.mediaSession.setPositionState({
                                duration: duration,
                                playbackRate: 1.0,
                                position: currentTime
                            });
                        }
                    }
                } catch (e) {
                    // å¦‚æœ YouTube æ’­æ”¾å™¨è¿˜æ²¡å‡†å¤‡å¥½ï¼Œå¿½ç•¥é”™è¯¯
                }
            }
        }

        // åœæ­¢å¼¹å¹•ç³»ç»Ÿ
        function stopDanmaku() {
            if (state.danmakuInterval) {
                clearInterval(state.danmakuInterval);
                state.danmakuInterval = null;
            }
            $('danmaku').classList.remove('show');
            $('danmaku').innerHTML = '';
            // Clear the displayed danmaku set
            state.displayedDanmaku.clear();
            // Clear recent danmaku indices
            if (state.recentDanmakuIndices) {
                state.recentDanmakuIndices = [];
            }
            // Reset tracks
            state.tracks = [false, false, false, false, false];
            // åœæ­¢å®šæœŸåˆ·æ–°å¼¹å¹•æ•°æ®
            DanmakuManager.stopRefresh();
        }

        function seek(e) {
            if (!audio.src) return;
            const rect = $('progress-bar').getBoundingClientRect();
            const pct = (e.clientX - rect.left) / rect.width;
            audio.currentTime = pct * audio.duration;
        }

        function formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // æ’­æ”¾å®Œæ•´æ­Œæ›²ï¼ˆåœ¨Apple Musicä¸­ï¼‰
        function playFullSong(trackId, trackName, artistName) {
            const song = state.playlist.find(s => s.trackId == trackId);
            const albumId = song?.collectionId || trackId;

            const musicAppUrl = `music://music.apple.com/cn/album/${albumId}?i=${trackId}`;
            const webUrl = `https://music.apple.com/cn/album/${albumId}?i=${trackId}`;

            // æ£€æµ‹è®¾å¤‡ç±»å‹
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isMac = /Macintosh/.test(navigator.userAgent);
            const isAppleDevice = isIOS || isMac;

            if (isAppleDevice) {
                // Apple è®¾å¤‡ï¼šå°è¯•æ‰“å¼€ App
                const startTime = Date.now();

                // ä½¿ç”¨ visibilitychange æ£€æµ‹æ˜¯å¦æˆåŠŸè·³è½¬åˆ° App 
                const handleVisibilityChange = () => {
                    if (document.hidden) {
                        // é¡µé¢è¢«éšè—ï¼Œè¯´æ˜æˆåŠŸæ‰“å¼€äº† App
                        clearTimeout(fallbackTimer);
                        document.removeEventListener('visibilitychange', handleVisibilityChange);
                    }
                };
                document.addEventListener('visibilitychange', handleVisibilityChange);

                // å°è¯•æ‰“å¼€ App
                window.location.href = musicAppUrl;

                // è®¾ç½®é™çº§å®šæ—¶å™¨
                const fallbackTimer = setTimeout(() => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);

                    // å¦‚æœé¡µé¢è¿˜å¯è§ä¸”æ—¶é—´å¾ˆçŸ­ï¼Œè¯´æ˜ App æ²¡æ‰“å¼€
                    if (!document.hidden && Date.now() - startTime < 2000) {
                        showFallbackOptions(trackName, artistName, webUrl);
                    }
                }, 1500);

            } else {
                // é Apple è®¾å¤‡ï¼šç›´æ¥æ‰“å¼€ç½‘é¡µç‰ˆ
                window.open(webUrl, '_blank');
                showToast(`æ­£åœ¨æ‰“å¼€ "${trackName}" - ${artistName}`);
            }
        }

        // æ’­æ”¾ YouTube å®Œæ•´æ­Œæ›²ï¼ˆé€‰é¡¹èœå•è°ƒç”¨ï¼‰
        function playYouTubeFullSong(videoId, trackName, artistName, coverUrl) {
            playYouTubeSong(videoId, trackName, artistName, coverUrl);
        }

        // æ‰“å¼€ iTunes æ­Œæ›²åœ¨ Apple Music åº”ç”¨æˆ–ç½‘é¡µä¸­
        function openAppleMusic(trackId, trackName, artistName) {
            const song = state.playlist.find(s => s.trackId == trackId);
            const albumId = song?.collectionId || trackId;

            const musicAppUrl = `music://music.apple.com/cn/album/${albumId}?i=${trackId}`;
            const webUrl = `https://music.apple.com/cn/album/${albumId}?i=${trackId}`;

            // æ£€æµ‹è®¾å¤‡ç±»å‹
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isMac = /Macintosh/.test(navigator.userAgent);
            const isAppleDevice = isIOS || isMac;

            if (isAppleDevice) {
                // Apple è®¾å¤‡ï¼šå°è¯•æ‰“å¼€ App
                const startTime = Date.now();

                // ä½¿ç”¨ visibilitychange æ£€æµ‹æ˜¯å¦æˆåŠŸè·³è½¬åˆ° App
                const handleVisibilityChange = () => {
                    if (document.hidden) {
                        // é¡µé¢è¢«éšè—ï¼Œè¯´æ˜æˆåŠŸæ‰“å¼€äº† App
                        clearTimeout(fallbackTimer);
                        document.removeEventListener('visibilitychange', handleVisibilityChange);
                    }
                };
                document.addEventListener('visibilitychange', handleVisibilityChange);

                // å°è¯•æ‰“å¼€ App
                window.location.href = musicAppUrl;

                // è®¾ç½®é™çº§å®šæ—¶å™¨
                const fallbackTimer = setTimeout(() => {
                    document.removeEventListener('visibilitychange', handleVisibilityChange);

                    // å¦‚æœé¡µé¢è¿˜å¯è§ä¸”æ—¶é—´å¾ˆçŸ­ï¼Œè¯´æ˜ App æ²¡æ‰“å¼€
                    if (!document.hidden && Date.now() - startTime < 2000) {
                        showFallbackOptions(trackName, artistName, webUrl);
                    }
                }, 1500);

            } else {
                // é Apple è®¾å¤‡ï¼šç›´æ¥æ‰“å¼€ç½‘é¡µç‰ˆ
                window.open(webUrl, '_blank');
                showToast(`æ­£åœ¨æ‰“å¼€ "${trackName}" - ${artistName}`);
            }
        }

            // æ‰“å¼€ YouTube æ­Œæ›²åœ¨ YouTube åº”ç”¨æˆ–ç½‘é¡µä¸­
            function openYouTubeApp(videoId, trackName, artistName) {
                const webUrl = `https://www.youtube.com/watch?v=${videoId}`;
        // Android Intent (Chrome æ¨èæ–¹å¼)
        // S.browser_fallback_url æŒ‡å®šäº†å¦‚æœæ²¡å®‰è£… App è·³è½¬çš„åœ°å€
        const androidIntent = `intent://www.youtube.com/watch?v=${videoId}#Intent;package=com.google.android.youtube;scheme=https;S.browser_fallback_url=${encodeURIComponent(webUrl)};end`;
        // iOS Scheme (ä¸æ¨èï¼Œæ¨èç›´æ¥ç”¨ webUrlï¼Œä½†åœ¨æŸäº›åœºæ™¯å¯ç”¨)
        const iosScheme = `youtube://watch?v=${videoId}`;

        // 1. æ›´ç²¾å‡†çš„è®¾å¤‡æ£€æµ‹
        const u = navigator.userAgent;
        const isAndroid = u.indexOf('Android') > -1 || u.indexOf('Adr') > -1;
        // å…¼å®¹ iPad Desktop Mode çš„æ£€æµ‹
        const isIOS = !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

        showToast(`æ­£åœ¨æ‰“å¼€ "${trackName}" - ${artistName}`);

        if (isAndroid) {
            // Android æœ€ä½³å®è·µ: ä½¿ç”¨ Intent
            // å¦‚æœå·²å®‰è£… Appï¼Œç³»ç»Ÿç›´æ¥æ‰“å¼€ï¼›æ²¡å®‰è£…ï¼ŒChrome ä¼šè‡ªåŠ¨å¤„ç† fallback åˆ°ç½‘é¡µ
            window.location.href = androidIntent;
        } else if (isIOS) {
            // iOS æœ€ä½³å®è·µ: ç›´æ¥è®¿é—® Universal Link (HTTPS)
            // iOS ç³»ç»Ÿä¼šè‡ªåŠ¨æ‹¦æˆªè¿™ä¸ªé“¾æ¥å¹¶è¯¢é—®æ˜¯å¦åœ¨ App ä¸­æ‰“å¼€
            // å¼ºè¡Œç”¨ Scheme å¾€å¾€ä½“éªŒä¸å¥½ï¼Œä¸”å¾ˆéš¾å‡†ç¡®åˆ¤æ–­æ˜¯å¦å®‰è£…
            window.location.href = webUrl;
            
            // --- å¦‚æœä½ éè¦å¼ºè¡Œå°è¯• Scheme (ä¸æ¨è) ---
            // window.location.href = iosScheme; 
            // setTimeout(() => {
            //    // iOS ä¸Šä¸èƒ½åœ¨ timeout é‡Œ window.openï¼Œåªèƒ½æ”¹å˜ location
            //    window.location.href = webUrl; 
            // }, 2000);
            // ----------------------------------------
        } else {
            // æ¡Œé¢ç«¯
            window.open(webUrl, '_blank');
        }
    }
        // æ‰“å¼€ YouTube æ­Œæ›²åœ¨ YouTube Music åº”ç”¨æˆ–ç½‘é¡µä¸­
        function openYouTubeMusic(videoId, trackName, artistName) {
            const webUrl = `https://music.youtube.com/watch?v=${videoId}`;
            const ytmusicUrl = `https://www.youtube.com/watch?v=${videoId}`; // YouTube Music app scheme
            const youtubemusicUrl = `https://www.youtube.com/watch?v=${videoId}`; // Alternative scheme

            // æ£€æµ‹è®¾å¤‡ç±»å‹
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
            const isAndroid = /Android/.test(navigator.userAgent);
            const isMobile = isIOS || isAndroid;

            if (isMobile) {
                // ç§»åŠ¨è®¾å¤‡ï¼šå°è¯•æ‰“å¼€ YouTube Music App with multiple fallbacks
                const startTime = Date.now();

                // Try YouTube Music specific schemes first
                const schemesToTry = [ytmusicUrl, youtubemusicUrl];

                let schemeIndex = 0;
                const tryNextScheme = () => {
                    if (schemeIndex < schemesToTry.length) {
                        const schemeUrl = schemesToTry[schemeIndex];
                        schemeIndex++;

                        // ä½¿ç”¨ iframe æ–¹å¼å°è¯•æ‰“å¼€ï¼Œè¿™æ ·ä¸ä¼šè¢«æ‹¦æˆª
                        const iframe = document.createElement('iframe');
                        iframe.style.display = 'none';
                        iframe.src = schemeUrl;
                        document.body.appendChild(iframe);

                        // Remove the iframe after a short time
                        setTimeout(() => {
                            if (iframe.parentNode) {
                                document.body.removeChild(iframe);
                            }

                            // Check if app opened by measuring elapsed time
                            if (Date.now() - startTime < 2000 && schemeIndex < schemesToTry.length) {
                                // If still on page, try next scheme
                                tryNextScheme();
                            } else if (Date.now() - startTime < 2000) {
                                // If still on page and all schemes tried, fallback to web
                                window.open(webUrl, '_blank');
                                showToast(`æ­£åœ¨æ‰“å¼€ "${trackName}" - ${artistName}`);
                            }
                        }, 800); // Reduced timeout to try schemes faster
                    } else {
                        // All schemes tried, fallback to web
                        if (Date.now() - startTime < 2000) {
                            window.open(webUrl, '_blank');
                            showToast(`æ­£åœ¨æ‰“å¼€ "${trackName}" - ${artistName}`);
                        }
                    }
                };

                tryNextScheme();

            } else {
                // æ¡Œé¢è®¾å¤‡ï¼šç›´æ¥æ‰“å¼€ç½‘é¡µç‰ˆ
                window.open(webUrl, '_blank');
                showToast(`æ­£åœ¨æ‰“å¼€ "${trackName}" - ${artistName}`);
            }
        }

        // æ˜¾ç¤ºæ­Œæ›²é€‰é¡¹èœå•
        function toggleOptionsMenu(event, trackId, trackName, artistName, coverUrl, isYouTube) {
            event.stopPropagation();

            // ç§»é™¤å·²å­˜åœ¨çš„é€‰é¡¹èœå•
            const existingMenu = document.querySelector('.song-options-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            // åˆ›å»ºé€‰é¡¹èœå•
            const menu = document.createElement('div');
            menu.className = 'song-options-menu';
            menu.style.cssText = `
                position: absolute;
                top: 32px;
                right: 8px;
                background: var(--card);
                border: 1px solid var(--glass-border);
                border-radius: 12px;
                padding: 8px 0;
                box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                z-index: 100;
                min-width: 160px;
            `;

            // æ ¹æ®æ¥æºæ„å»ºèœå•é¡¹
            if (isYouTube) {
                menu.innerHTML = `
                    <div class="option-item" onclick="playYouTubeSong('${trackId}', '${trackName}', '${artistName}', '${coverUrl}'); this.closest('.song-options-menu').remove();">
                        <span>ğŸµ åœ¨æ­¤æ’­æ”¾</span>
                    </div>
                    <div class="option-item" onclick="openYouTubeApp('${trackId}', '${trackName}', '${artistName}'); this.closest('.song-options-menu').remove();">
                        <span>â–¶ï¸ æ‰“å¼€ YouTube åº”ç”¨</span>
                    </div>
                `;
            } else {
                menu.innerHTML = `
                    <div class="option-item" onclick="playFullSong('${trackId}', '${trackName}', '${artistName}'); this.closest('.song-options-menu').remove();">
                        <span>ğŸµ åœ¨æ­¤æ’­æ”¾</span>
                    </div>
                    <div class="option-item" onclick="openAppleMusic('${trackId}', '${trackName}', '${artistName}'); this.closest('.song-options-menu').remove();">
                        <span>ğŸ“± æ‰“å¼€ Apple Music</span>
                    </div>
                `;
            }

            // æ·»åŠ é€‰é¡¹é¡¹çš„æ ·å¼
            if (!document.querySelector('#song-options-menu-styles')) {
                const styles = document.createElement('style');
                styles.id = 'song-options-menu-styles';
                styles.textContent = `
                    .option-item {
                        padding: 10px 16px;
                        cursor: pointer;
                        transition: background 0.2s ease;
                        font-size: 14px;
                        color: var(--text);
                    }
                    .option-item:hover {
                        background: var(--glass-border);
                    }
                    .song-options-menu {
                        position: absolute;
                        top: 32px;
                        right: 8px;
                        background: var(--card);
                        border: 1px solid var(--glass-border);
                        border-radius: 12px;
                        padding: 8px 0;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
                        z-index: 100;
                        min-width: 160px;
                    }
                `;
                document.head.appendChild(styles);
            }

            // æ·»åŠ èœå•åˆ°é¡µé¢
            document.body.appendChild(menu);

            // å®šä½èœå•ï¼ˆç›¸å¯¹äºç‚¹å‡»çš„ç›®æ ‡å…ƒç´ ï¼‰
            const targetRect = event.target.getBoundingClientRect();
            menu.style.top = `${targetRect.bottom + window.scrollY - 8}px`;
            menu.style.right = `${window.innerWidth - targetRect.right - 16}px`;

            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            setTimeout(() => {
                const closeMenu = (e) => {
                    if (!menu.contains(e.target) && e.target !== event.target) {
                        menu.remove();
                        document.removeEventListener('click', closeMenu);
                    }
                };
                document.addEventListener('click', closeMenu);
            }, 10);
        }

        // æ˜¾ç¤ºé™çº§é€‰é¡¹
        function showFallbackOptions(trackName, artistName, webUrl) {
            // åˆ›å»ºä¸€ä¸ªæ›´å‹å¥½çš„æç¤ºæ¡†
            const modal = document.createElement('div');
            modal.className = 'apple-music-modal';
            modal.innerHTML = `
        <div class="modal-overlay" onclick="this.parentElement.remove()">
            <div class="modal-content" onclick="event.stopPropagation()">
                <div class="modal-icon">ğŸµ</div>
                <h3>æ‰“å¼€ Apple Music</h3>
                <p>å³å°†æ’­æ”¾ "${trackName}"<br><span class="artist">${artistName}</span></p>
                <div class="modal-buttons">
                    <a href="${webUrl}" target="_blank" class="btn-primary" onclick="this.closest('.apple-music-modal').remove()">
                        åœ¨ç½‘é¡µä¸­æ‰“å¼€
                    </a>
                    <button class="btn-secondary" onclick="this.closest('.apple-music-modal').remove()">
                        å–æ¶ˆ
                    </button>
                </div>
                <p class="hint">æç¤ºï¼šå®‰è£… Apple Music åº”ç”¨å¯è·å¾—æ›´å¥½ä½“éªŒ</p>
            </div>
        </div>
    `;

            // æ·»åŠ æ ·å¼
            if (!document.querySelector('#apple-music-modal-styles')) {
                const styles = document.createElement('style');
                styles.id = 'apple-music-modal-styles';
                styles.textContent = `
            .apple-music-modal .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.6);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.2s ease;
            }
            .apple-music-modal .modal-content {
                background: white;
                border-radius: 16px;
                padding: 24px;
                max-width: 320px;
                width: 90%;
                text-align: center;
                animation: slideUp 0.3s ease;
            }
            .apple-music-modal .modal-icon {
                font-size: 48px;
                margin-bottom: 12px;
            }
            .apple-music-modal h3 {
                margin: 0 0 8px;
                font-size: 18px;
                color: #1a1a1a;
            }
            .apple-music-modal p {
                margin: 0 0 16px;
                color: #666;
                font-size: 14px;
                line-height: 1.5;
            }
            .apple-music-modal .artist {
                color: #999;
            }
            .apple-music-modal .modal-buttons {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            .apple-music-modal .btn-primary {
                background: linear-gradient(135deg, #fc3c44, #d93a41);
                color: white;
                border: none;
                padding: 12px 24px;
                border-radius: 10px;
                font-size: 16px;
                font-weight: 500;
                cursor: pointer;
                text-decoration: none;
                display: block;
            }
            .apple-music-modal .btn-secondary {
                background: #f0f0f0;
                color: #333;
                border: none;
                padding: 12px 24px;
                border-radius: 10px;
                font-size: 16px;
                cursor: pointer;
            }
            .apple-music-modal .hint {
                font-size: 12px;
                color: #999;
                margin-top: 16px;
                margin-bottom: 0;
            }
            @keyframes fadeIn {
                from { opacity: 0; }
                to { opacity: 1; }
            }
            @keyframes slideUp {
                from { transform: translateY(20px); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }
        `;
                document.head.appendChild(styles);
            }

            document.body.appendChild(modal);
        }

        // YouTube Player functions
        function onYouTubeIframeAPIReady() {
            console.log('YouTube Iframe API ready');
        }

        // Initialize YouTube player with better error handling and fallback
        function initYouTubePlayer(videoId) {
            return new Promise((resolve, reject) => {
                // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

                // åœ¨ç§»åŠ¨ç«¯ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
                if (isMobile) {
                    showToast('æ­£åœ¨åˆå§‹åŒ–æ’­æ”¾å™¨...');
                }

                // Initialize background audio context before creating player
                aggressiveAudioContextInit();

                // Create container for YouTube player if it doesn't exist
                let playerContainer = document.getElementById('youtube-player-container');
                if (!playerContainer) {
                    playerContainer = document.createElement('div');
                    playerContainer.id = 'youtube-player-container';
                    playerContainer.style.display = 'none';
                    document.body.appendChild(playerContainer);
                }

                // Prepare player parameters with better audio settings
                const playerVars = {
                    'playsinline': 1,
                    'controls': 0,  // Hide controls to play audio only
                    'disablekb': 1, // Disable keyboard controls
                    'fs': 0,       // Disable fullscreen
                    'iv_load_policy': 3, // Disable annotations
                    'modestbranding': 1, // Reduce YouTube branding
                    'rel': 0, // Don't show related videos at the end
                    'autoplay': 1, // å¯ç”¨è‡ªåŠ¨æ’­æ”¾ï¼Œåœ¨ç”¨æˆ·äº¤äº’ä¸Šä¸‹æ–‡ä¸­åˆå§‹åŒ–æ—¶ä¼šè‡ªåŠ¨æ’­æ”¾
                    'mute': 0, // Don't mute initially
                    'enablejsapi': 1, // Enable API
                    'origin': window.location.origin, // Important for security policy
                    'widgetid': 'youtube-player'
                };

                try {
                    // Create the YouTube player
                    const player = new YT.Player('youtube-player-container', {
                        videoId: videoId,
                        playerVars: playerVars,
                        events: {
                            'onReady': function (event) {
                                console.log('YouTube player ready');
                                // åœ¨ç§»åŠ¨ç«¯ï¼Œæ’­æ”¾å™¨å‡†å¤‡å°±ç»ªæ—¶æ›´æ–°æç¤º
                                if (isMobile) {
                                    showToast('æ’­æ”¾å™¨å·²å°±ç»ª...');
                                }

                                // Ensure audio context is running when player is ready
                                if (backgroundAudioContext) {
                                    if (backgroundAudioContext.state === 'suspended') {
                                        backgroundAudioContext.resume().catch(err => {
                                            console.warn('Could not resume audio context:', err);
                                        });
                                    }
                                }

                                // Set initial position state with duration for MediaSession API
                                // This ensures duration displays correctly in UI and lock screen
                                try {
                                    // åœ¨ç§»åŠ¨ç«¯å¢åŠ ç­‰å¾…æ—¶é—´ä»¥ç¡®ä¿è·å–åˆ°æ—¶é•¿
                                    const durationCheckDelay = isMobile ? 1000 : 500;
                                    // Wait a bit to ensure duration is available
                                    setTimeout(() => {
                                        const duration = event.target.getDuration();
                                        if (!isNaN(duration) && duration > 0) {
                                            $('total-time').textContent = formatTime(duration);

                                            if ('setPositionState' in navigator.mediaSession) {
                                                navigator.mediaSession.setPositionState({
                                                    duration: duration,
                                                    playbackRate: 1.0,
                                                    position: 0
                                                });
                                            }
                                        } else {
                                            // å¦‚æœç§»åŠ¨è®¾å¤‡ä¸Šæ²¡æœ‰ç«‹å³è·å–åˆ°æ—¶é•¿ï¼Œå†ç­‰ä¸€æ¬¡
                                            if (isMobile) {
                                                setTimeout(() => {
                                                    const duration = event.target.getDuration();
                                                    if (!isNaN(duration) && duration > 0) {
                                                        $('total-time').textContent = formatTime(duration);
                                                        if ('setPositionState' in navigator.mediaSession) {
                                                            navigator.mediaSession.setPositionState({
                                                                duration: duration,
                                                                playbackRate: 1.0,
                                                                position: 0
                                                            });
                                                        }
                                                    }
                                                }, 800);
                                            }
                                        }
                                    }, durationCheckDelay); // å»¶è¿Ÿä»¥ç¡®ä¿æ—¶é•¿åŠ è½½å®Œæˆ
                                } catch (e) {
                                    console.log('Could not get duration on ready:', e);
                                }

                                // ç”±äºå·²å¯ç”¨ autoplay: 1ï¼Œæ’­æ”¾å™¨ä¼šè‡ªåŠ¨æ’­æ”¾
                                // æˆ‘ä»¬åªéœ€è¦åœ¨è¿™é‡Œæ›´æ–°çŠ¶æ€
                                if (state.shouldAutoplayYouTube) {
                                    // æ ‡è®°ä¸ºæ­£åœ¨æ’­æ”¾
                                    state.isYouTubePlaying = true;
                                    updatePlayState(true);
                                    state.shouldAutoplayYouTube = false;
                                    console.log('YouTube æ’­æ”¾å™¨å·²è‡ªåŠ¨æ’­æ”¾');
                                }

                                resolve(event.target);
                            },
                            'onStateChange': function (event) {
                                console.log('YouTube player state:', event.data);
                                // Update our state based on YouTube player state
                                if (event.data === YT.PlayerState.PLAYING) {
                                    state.isYouTubePlaying = true;
                                    updatePlayState(true);
                                    // Ensure audio context is running
                                    if (backgroundAudioContext && backgroundAudioContext.state === 'suspended') {
                                        backgroundAudioContext.resume().catch(err => {
                                            console.warn('Could not resume audio context in PLAYING state:', err);
                                        });
                                    }
                                    // Start PWA progress updates when playing
                                    startPWAProgressUpdates();
                                    // Update progress immediately when playing starts
                                    setTimeout(updateYouTubeProgress, 100);
                                } else if (event.data === YT.PlayerState.PAUSED) {
                                    state.isYouTubePlaying = false;
                                    updatePlayState(false);
                                    // Stop PWA-specific updates when paused
                                    stopPWAProgressUpdates();
                                } else if (event.data === YT.PlayerState.ENDED) {
                                    // å½“ YouTube æ­Œæ›²æ’­æ”¾ç»“æŸæ—¶
                                    state.isYouTubePlaying = false;
                                    updatePlayState(false);
                                    // Stop PWA-specific updates when ended
                                    stopPWAProgressUpdates();
                                    // å»¶è¿Ÿä¸€ç‚¹æ—¶é—´å†æ’­æ”¾ä¸‹ä¸€é¦–ï¼Œç¡®ä¿çŠ¶æ€æ›´æ–°å®Œæˆ
                                    setTimeout(() => {
                                        playNextForYouTube();
                                    }, 300);
                                } else if (event.data === YT.PlayerState.BUFFERING) {
                                    // Ensure audio context remains active during buffering
                                    if (backgroundAudioContext && backgroundAudioContext.state === 'suspended') {
                                        backgroundAudioContext.resume().catch(err => {
                                            console.warn('Could not resume audio context in BUFFERING state:', err);
                                        });
                                    }
                                } else if (event.data === YT.PlayerState.CUED) {
                                    // Video is cued and ready to play - try to play if autoplay was requested
                                    if (state.shouldAutoplayYouTube) {
                                        requestAudioPlayback().then(() => {
                                            try {
                                                event.target.playVideo();
                                                state.isYouTubePlaying = true;
                                                updatePlayState(true);
                                                // Start PWA progress updates
                                                startPWAProgressUpdates();
                                            } catch (e) {
                                                console.warn('Could not play from cued state:', e);
                                            }
                                            state.shouldAutoplayYouTube = false;
                                        });
                                    }
                                }
                            },
                            'onError': function (error) {
                                console.error('YouTube player error:', error);

                                // Try alternative video ID format or fallback
                                if (error.data === 100 || error.data === 101 || error.data === 150) {
                                    // Video not found or not allowed to play - try alternative approach
                                    console.log('YouTube video issue, attempting fallback...');

                                    // Create a backup method using direct YouTube URL for audio
                                    const fallbackAudio = $('audio');
                                    const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

                                    // Try to load this URL (this might work in some browsers)
                                    // Note: This is a fallback and may not work due to CORS restrictions

                                    // Return error for now, but keep trying to resolve with available player
                                    reject(error);
                                } else {
                                    // å…¶ä»–é”™è¯¯ - å¯èƒ½å¯ä»¥æ¢å¤
                                    console.log('YouTube player error, but continuing:', error);
                                    // ä¸è¦å› ä¸ºå…¶ä»–é”™è¯¯è€Œæ‹’ç»ï¼Œå› ä¸ºæ’­æ”¾å™¨å¯èƒ½ä»ç„¶å¯ä»¥å·¥ä½œ
                                    // æ— è®ºå¦‚ä½•éƒ½è¦ç”¨æ’­æ”¾å™¨å®ä¾‹è¿›è¡Œè§£æ
                                    resolve(event.target);
                                }
                            }
                        }
                    });
                } catch (creationError) {
                    console.error('Error creating YouTube player:', creationError);
                    // Try fallback approach
                    reject(creationError);
                }
            });
        }

        // Update the playYouTubeSong function to use YouTube player
        async function playYouTubeSong(videoId, title, artist, coverUrl = '') {
            if (!videoId) return;

            try {
                // Update state and UI first
                state.currentTrack = {
                    trackId: videoId,
                    trackName: title,
                    artistName: artist,
                    artworkUrl100: coverUrl || 'https://i.ytimg.com/img/no_thumbnail.jpg',
                    kind: 'youtube'
                };

                // Update player UI
                const cover = coverUrl || 'https://i.ytimg.com/img/no_thumbnail.jpg';
                $('player-cover').src = cover;

                const titleTextEl = $('player-title-text');
                const artistTextEl = $('player-artist-text');

                titleTextEl.textContent = title;
                artistTextEl.textContent = artist;

                // Update top info bar
                $('player-cover').src = cover;
                $('bg-album').style.backgroundImage = `url(${cover})`;
                $('bg-album').classList.add('active');

                // Setup Wikipedia button
                const wikiBtn = $('player-wiki-btn');
                const cleanArtistName = artist.split(/&|,|feat\.|ft\./i)[0].trim();
                wikiBtn.style.display = 'flex';
                wikiBtn.onclick = () => {
                    const wikiUrl = `https://zh.wikipedia.org/wiki/${encodeURIComponent(cleanArtistName)}`;
                    window.open(wikiUrl, '_blank');
                };
                wikiBtn.title = `æŸ¥çœ‹ ${cleanArtistName} çš„ç»´åŸºç™¾ç§‘`;

                // Setup tag recommendation button
                const tagBtn = $('player-tag-btn');
                tagBtn.style.display = 'flex';
                tagBtn.onclick = () => {
                    showCurrentSongTags();
                };
                tagBtn.title = 'æŸ¥çœ‹æ­Œæ›²æ ‡ç­¾æ¨è';

                // Check if text needs scrolling
                const checkScroll = (el) => {
                    el.classList.remove('scroll-text');
                    el.style.transform = 'none';

                    const containerWidth = el.parentElement.clientWidth;
                    const textWidth = el.scrollWidth;

                    if (textWidth > containerWidth) {
                        const distance = containerWidth - textWidth;
                        const duration = Math.abs(distance) / 30 + 2;

                        el.style.setProperty('--scroll-distance', `${distance}px`);
                        el.style.setProperty('--duration', `${duration}s`);
                        el.classList.add('scroll-text');
                    }
                };

                setTimeout(() => {
                    checkScroll(titleTextEl);
                    checkScroll(artistTextEl);
                }, 50);


                // Danmaku
                startDanmaku();

                // Preload lyrics
                $('lyrics-title').textContent = title;
                $('lyrics-artist').textContent = artist;
                setupWikipediaLink(artist);
                $('lyrics-cover').src = cover;
                $('lyrics-text').textContent = 'åŠ è½½ä¸­...';
                $('lyrics-wiki').classList.remove('show');

                fetchLyrics(artist, title);
                fetchArtistWiki(artist);

                // Add to history
                HistoryManager.add({
                    trackId: videoId,
                    trackName: title,
                    artistName: artist,
                    artworkUrl100: cover,
                    kind: 'youtube'
                });

                // Update media session (with updated metadata)
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: title,
                        artist: artist,
                        album: 'YouTube Music',
                        artwork: [
                            { src: cover, sizes: '96x96', type: 'image/jpeg' },
                            { src: cover, sizes: '128x128', type: 'image/jpeg' },
                            { src: cover, sizes: '192x192', type: 'image/jpeg' },
                            { src: cover, sizes: '256x256', type: 'image/jpeg' },
                            { src: cover, sizes: '512x512', type: 'image/jpeg' }
                        ]
                    });

                    navigator.mediaSession.setActionHandler('play', toggleYouTubePlay);
                    navigator.mediaSession.setActionHandler('pause', toggleYouTubePlay);
                    navigator.mediaSession.setActionHandler('previoustrack', playPrevious);
                    navigator.mediaSession.setActionHandler('nexttrack', () => playNext(false));
                }

                // Update favorite button state
                updateFavoriteButton();

                // Update recommendation tags
                updateRecommendationTags(state.currentTrack);

                // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
                const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

                // Initialize or update YouTube player
                if (!state.youtubePlayer) {
                    // Set flag to autoplay when ready
                    state.shouldAutoplayYouTube = true;

                    // åœ¨ç§»åŠ¨ç«¯ï¼Œæ˜¾ç¤ºæç¤ºè®©ç”¨æˆ·çŸ¥é“æ­£åœ¨åŠ è½½
                    if (isMobile) {
                        showToast('æ­£åœ¨åŠ è½½...');
                    }

                    try {
                        state.youtubePlayer = await initYouTubePlayer(videoId);

                        // åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šç­‰å¾…æ›´é•¿æ—¶é—´ä»¥ç¡®ä¿æ’­æ”¾å™¨å®Œå…¨åŠ è½½
                        if (isMobile) {
                            // ç­‰å¾…ä¸€æ®µæ—¶é—´ä»¥ç¡®ä¿æ’­æ”¾å™¨å®Œå…¨åŠ è½½
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }

                        // æ’­æ”¾å™¨åˆå§‹åŒ–æˆåŠŸåï¼Œç«‹å³å°è¯•æ’­æ”¾
                        // è¿™é‡Œä»åœ¨ç”¨æˆ·äº¤äº’çš„"ä¿¡ä»»é“¾"ä¸­
                        if (state.youtubePlayer && state.shouldAutoplayYouTube) {
                            try {
                                // å…ˆæ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡
                                await requestAudioPlayback();
                                // ç„¶åæ’­æ”¾
                                state.youtubePlayer.playVideo();
                                state.isYouTubePlaying = true;
                                updatePlayState(true);
                                state.shouldAutoplayYouTube = false;

                                if (isMobile) {
                                    showToast('å¼€å§‹æ’­æ”¾');
                                }
                            } catch (playError) {
                                console.warn('è‡ªåŠ¨æ’­æ”¾å¤±è´¥:', playError);
                                // ç§»åŠ¨ç«¯è‡ªåŠ¨æ’­æ”¾å¤±è´¥æ—¶ï¼Œæ˜¾ç¤ºæ˜ç¡®æç¤º
                                if (isMobile) {
                                    showToast('æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...');
                                    // ç­‰å¾…æ›´å¤šæ—¶é—´ç„¶åå°è¯•æ’­æ”¾
                                    setTimeout(() => {
                                        try {
                                            state.youtubePlayer.playVideo();
                                            state.isYouTubePlaying = true;
                                            updatePlayState(true);
                                            showToast('å¼€å§‹æ’­æ”¾');
                                        } catch (e) {
                                            console.warn('å»¶è¿Ÿæ’­æ”¾ä¹Ÿå¤±è´¥:', e);
                                            showToast('è¯·ç¨åç‚¹å‡»æ’­æ”¾æŒ‰é’®');
                                            updatePlayState(false);
                                        }
                                    }, 1000);
                                } else {
                                    updatePlayState(false);
                                }
                            }
                        }
                    } catch (error) {
                        console.error('YouTube player initialization failed:', error);
                        showToast('YouTube æ’­æ”¾å™¨åˆå§‹åŒ–å¤±è´¥');
                        state.shouldAutoplayYouTube = false;
                    }
                } else {
                    // æ’­æ”¾å™¨å·²å­˜åœ¨ï¼ŒåŠ è½½æ–°è§†é¢‘
                    state.youtubePlayer.loadVideoById(videoId);

                    // åœ¨ç§»åŠ¨ç«¯æ·»åŠ é¢å¤–çš„ç­‰å¾…æ—¶é—´ï¼Œä»¥ç¡®ä¿è§†é¢‘å®Œå…¨åŠ è½½
                    const loadDelay = isMobile ? 2000 : 500; // ç§»åŠ¨ç«¯ç­‰å¾…æ›´é•¿æ—¶é—´

                    // ç­‰å¾…è§†é¢‘åŠ è½½åç«‹å³æ’­æ”¾
                    setTimeout(async () => {
                        if (state.youtubePlayer) {
                            try {
                                // æ£€æŸ¥æ’­æ”¾å™¨çŠ¶æ€ï¼Œç¡®ä¿å·²å‡†å¤‡å¥½
                                let attempts = 0;
                                const maxAttempts = 10; // æœ€å¤šé‡è¯•10æ¬¡

                                while (attempts < maxAttempts) {
                                    const playerState = state.youtubePlayer.getPlayerState();

                                    // å¦‚æœæ’­æ”¾å™¨å·²å‡†å¤‡å¥½æˆ–å·²ç¼“å†²ï¼Œåˆ™å°è¯•æ’­æ”¾
                                    if (playerState === YT.PlayerState.CUED || playerState === YT.PlayerState.BUFFERING || playerState === YT.PlayerState.UNSTARTED) {
                                        // ç­‰å¾…ä¸€å°æ®µæ—¶é—´å†å°è¯•æ’­æ”¾
                                        await new Promise(resolve => setTimeout(resolve, 500));

                                        // å°è¯•ç«‹å³æ’­æ”¾
                                        await requestAudioPlayback();
                                        state.youtubePlayer.playVideo();
                                        state.isYouTubePlaying = true;
                                        updatePlayState(true);

                                        if (isMobile) {
                                            showToast('å¼€å§‹æ’­æ”¾');
                                        }
                                        break; // æˆåŠŸæ’­æ”¾åé€€å‡ºå¾ªç¯
                                    } else if (playerState === YT.PlayerState.PLAYING) {
                                        // å¦‚æœå·²ç»åœ¨æ’­æ”¾ï¼Œæ›´æ–°çŠ¶æ€
                                        state.isYouTubePlaying = true;
                                        updatePlayState(true);
                                        break;
                                    }

                                    attempts++;
                                    await new Promise(resolve => setTimeout(resolve, 300)); // ç­‰å¾…300mså†æ£€æŸ¥
                                }

                                // å¦‚æœæ‰€æœ‰å°è¯•éƒ½å¤±è´¥äº†
                                if (attempts >= maxAttempts && !state.isYouTubePlaying) {
                                    if (isMobile) {
                                        showToast('æ­£åœ¨å‡†å¤‡æ’­æ”¾ï¼Œè¯·ç¨å...');
                                        // å†æ¬¡å°è¯•æ’­æ”¾
                                        setTimeout(() => {
                                            try {
                                                state.youtubePlayer.playVideo();
                                                state.isYouTubePlaying = true;
                                                updatePlayState(true);
                                                showToast('å¼€å§‹æ’­æ”¾');
                                            } catch (e) {
                                                console.warn('å¤šæ¬¡å°è¯•æ’­æ”¾å¤±è´¥:', e);
                                                showToast('è¯·ç¨åç‚¹å‡»æ’­æ”¾æŒ‰é’®');
                                            }
                                        }, 1000);
                                    } else {
                                        showToast('æ’­æ”¾å¤±è´¥ï¼Œè¯·é‡è¯•');
                                    }
                                }
                            } catch (e) {
                                console.warn('æ’­æ”¾å¤±è´¥:', e);
                                if (isMobile) {
                                    showToast('æ­£åœ¨åŠ è½½ä¸­ï¼Œè¯·ç¨å€™...');
                                    // å°è¯•å†æ¬¡æ’­æ”¾
                                    setTimeout(() => {
                                        try {
                                            state.youtubePlayer.playVideo();
                                            state.isYouTubePlaying = true;
                                            updatePlayState(true);
                                            showToast('å¼€å§‹æ’­æ”¾');
                                        } catch (retryError) {
                                            console.warn('é‡è¯•æ’­æ”¾å¤±è´¥:', retryError);
                                            showToast('è¯·ç¨åç‚¹å‡»æ’­æ”¾æŒ‰é’®');
                                        }
                                    }, 1500);
                                } else {
                                    showToast('æ’­æ”¾å¤±è´¥ï¼Œè¯·é‡è¯•');
                                }
                            }
                        }
                    }, loadDelay); // ä½¿ç”¨æ ¹æ®è®¾å¤‡ç±»å‹è°ƒæ•´çš„å»¶è¿Ÿæ—¶é—´
                }

                // For immediate playback after user interaction (in case user clicked to play)
                if (state.youtubePlayer && state.youtubePlayer.getVideoUrl && state.youtubePlayer.getVideoUrl().includes(videoId)) {
                    // If player is already ready and loaded with the right video, try to play now
                    try {
                        // Try to play immediately if available
                        if (state.youtubePlayer && state.youtubePlayer.getPlayerState &&
                            state.youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                            requestAudioPlayback().then(() => {
                                state.youtubePlayer.playVideo();
                                state.isYouTubePlaying = true;
                                updatePlayState(true);
                            }).catch(() => {
                                state.youtubePlayer.playVideo();
                                state.isYouTubePlaying = true;
                                updatePlayState(true);
                            });
                        }
                    } catch (e) {
                        console.log("Could not play immediately:", e);
                    }
                }

            } catch (error) {
                console.error('Error initializing YouTube player:', error);
                showToast('YouTube æ’­æ”¾å™¨åˆå§‹åŒ–å¤±è´¥...');

                // Fallback: use the audio element with YouTube video URL (may not work in all browsers)
                const audioUrl = `https://www.youtube.com/watch?v=${videoId}`;
                audio.src = audioUrl;
                audio.load();
                audio.play()
                    .then(() => {
                        updatePlayState(true);
                        state.isYouTubePlaying = true;
                    })
                    .catch(err => {
                        console.error('Fallback also failed:', err);
                        showToast('å³å°†å‡†å¤‡å°±ç»ªï¼Œåˆ«ç€æ€¥');
                        updatePlayState(false);
                        state.isYouTubePlaying = false;
                    });
            }
        }

        // Toggle play/pause for YouTube player
        function toggleYouTubePlay() {
            if (state.youtubePlayer) {
                if (state.isYouTubePlaying) {
                    state.youtubePlayer.pauseVideo();
                    state.isYouTubePlaying = false;
                    // Stop PWA-specific progress updates when paused
                    stopPWAProgressUpdates();
                } else {
                    // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡
                    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

                    if (isMobile) {
                        showToast('æ­£åœ¨å‡†å¤‡æ’­æ”¾ï¼Œè¯·ç¨å€™...');
                    }

                    // Request user interaction to enable audio in background
                    requestAudioPlayback().then(() => {
                        // æ£€æŸ¥æ’­æ”¾å™¨çŠ¶æ€ï¼Œå¦‚æœæ­£åœ¨ç¼“å†²ï¼Œç­‰å¾…ä¸€ä¸‹å†æ’­æ”¾
                        let attempts = 0;
                        const maxAttempts = 5;

                        const attemptPlay = () => {
                            const playerState = state.youtubePlayer.getPlayerState();

                            if (playerState === YT.PlayerState.BUFFERING || playerState === YT.PlayerState.UNSTARTED || playerState === YT.PlayerState.CUED) {
                                if (attempts < maxAttempts) {
                                    attempts++;
                                    setTimeout(attemptPlay, 500); // ç­‰å¾…500msåé‡è¯•
                                } else {
                                    // å¤šæ¬¡å°è¯•åä»ç„¶å¤±è´¥ï¼Œç›´æ¥å°è¯•æ’­æ”¾
                                    state.youtubePlayer.playVideo();
                                    state.isYouTubePlaying = true;
                                    // Start PWA progress updates when playing
                                    startPWAProgressUpdates();
                                    updatePlayState(true);
                                    if (isMobile) {
                                        showToast('å¼€å§‹æ’­æ”¾');
                                    }
                                }
                            } else {
                                // æ’­æ”¾å™¨çŠ¶æ€æ­£å¸¸ï¼Œç›´æ¥æ’­æ”¾
                                state.youtubePlayer.playVideo();
                                state.isYouTubePlaying = true;
                                // Start PWA progress updates when playing
                                startPWAProgressUpdates();
                                updatePlayState(true);
                                if (isMobile) {
                                    showToast('å¼€å§‹æ’­æ”¾');
                                }
                            }
                        };

                        attemptPlay();
                    }).catch(() => {
                        try {
                            // æ£€æŸ¥æ’­æ”¾å™¨çŠ¶æ€ï¼Œå¦‚æœæ­£åœ¨ç¼“å†²ï¼Œç­‰å¾…ä¸€ä¸‹å†æ’­æ”¾
                            let attempts = 0;
                            const maxAttempts = 5;

                            const attemptPlay = () => {
                                const playerState = state.youtubePlayer.getPlayerState();

                                if (playerState === YT.PlayerState.BUFFERING || playerState === YT.PlayerState.UNSTARTED || playerState === YT.PlayerState.CUED) {
                                    if (attempts < maxAttempts) {
                                        attempts++;
                                        setTimeout(attemptPlay, 500); // ç­‰å¾…500msåé‡è¯•
                                    } else {
                                        // å¤šæ¬¡å°è¯•åä»ç„¶å¤±è´¥ï¼Œç›´æ¥å°è¯•æ’­æ”¾
                                        state.youtubePlayer.playVideo();
                                        state.isYouTubePlaying = true;
                                        // Start PWA progress updates when playing
                                        startPWAProgressUpdates();
                                        updatePlayState(true);
                                        if (isMobile) {
                                            showToast('å¼€å§‹æ’­æ”¾');
                                        }
                                    }
                                } else {
                                    // æ’­æ”¾å™¨çŠ¶æ€æ­£å¸¸ï¼Œç›´æ¥æ’­æ”¾
                                    state.youtubePlayer.playVideo();
                                    state.isYouTubePlaying = true;
                                    // Start PWA progress updates when playing
                                    startPWAProgressUpdates();
                                    updatePlayState(true);
                                    if (isMobile) {
                                        showToast('å¼€å§‹æ’­æ”¾');
                                    }
                                }
                            };

                            attemptPlay();
                        } catch (error) {
                            console.error('Failed to play YouTube video:', error);

                            // æ£€æµ‹æ˜¯å¦ä¸ºç§»åŠ¨è®¾å¤‡å¹¶æä¾›æ›´å…·ä½“çš„æç¤º
                            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

                            if (isMobile) {
                                // å¯¹äºç§»åŠ¨è®¾å¤‡ï¼Œæä¾›æ›´å¤šçš„ç­‰å¾…æ—¶é—´
                                setTimeout(() => {
                                    try {
                                        state.youtubePlayer.playVideo();
                                        state.isYouTubePlaying = true;
                                        // Start PWA progress updates when playing
                                        startPWAProgressUpdates();
                                        updatePlayState(true);
                                        showToast('å¼€å§‹æ’­æ”¾');
                                    } catch (retryError) {
                                        console.error('é‡è¯•æ’­æ”¾å¤±è´¥:', retryError);
                                        // Show more helpful message about browser autoplay restrictions
                                        showToast('é¦–æ¬¡æ’­æ”¾å¯èƒ½éœ€è¦ç”¨æˆ·äº¤äº’ï¼Œè¯·ç‚¹å‡»æ’­æ”¾æŒ‰é’®é‡è¯•');
                                        updatePlayState(false);
                                    }
                                }, 1500);
                            } else {
                                // Show more helpful message about browser autoplay restrictions
                                showToast('é¦–æ¬¡æ’­æ”¾å¯èƒ½éœ€è¦ç”¨æˆ·äº¤äº’ï¼Œè¯·ç‚¹å‡»æ’­æ”¾æŒ‰é’®é‡è¯•');
                                updatePlayState(false);
                            }
                        }
                    });
                }
                updatePlayState(state.isYouTubePlaying);
            }
        }

        // Audio context for maintaining background audio across browsers
        let backgroundAudioContext = null;

        // Initialize audio context for background playback with better approach
        function initializeBackgroundAudio() {
            if (backgroundAudioContext) return;

            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                backgroundAudioContext = new (AudioContext || webkitAudioContext)();

                // Create a very low-volume oscillator to keep context active without audible output
                const oscillator = backgroundAudioContext.createOscillator();
                const gainNode = backgroundAudioContext.createGain();

                // Set gain to extremely low value (nearly silent but keeps context active)
                gainNode.gain.value = 0.00001;

                oscillator.connect(gainNode);
                gainNode.connect(backgroundAudioContext.destination);
                oscillator.start(0);

                // Stop after a brief moment to avoid continuous processing
                if (backgroundAudioContext.currentTime) {
                    oscillator.stop(backgroundAudioContext.currentTime + 0.01);
                }

                // Resume if suspended
                if (backgroundAudioContext.state === 'suspended') {
                    backgroundAudioContext.resume();
                }
            }
        }

        // More aggressive audio context initialization on user interaction
        function aggressiveAudioContextInit() {
            if (typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined') {
                if (!backgroundAudioContext) {
                    backgroundAudioContext = new (AudioContext || webkitAudioContext)();
                }

                // Try to resume if suspended, regardless of whether we've created it before
                if (backgroundAudioContext.state === 'suspended') {
                    backgroundAudioContext.resume().catch(err => {
                        console.warn('Audio context resume failed:', err);
                    });
                }

                // Create and start a very brief audio source to fully activate context
                try {
                    const source = backgroundAudioContext.createBufferSource();
                    const silentBuffer = backgroundAudioContext.createBuffer(1, 1, 22050);
                    source.buffer = silentBuffer;
                    source.connect(backgroundAudioContext.destination);
                    source.start(0);
                    if (backgroundAudioContext.currentTime) {
                        source.stop(backgroundAudioContext.currentTime + 0.001);
                    }
                } catch (e) {
                    console.warn('Could not create silent buffer:', e);
                }
            }
        }

        // Request audio playback permission on mobile devices
        function requestAudioPlayback() {
            return new Promise((resolve, reject) => {
                // Initialize background audio context
                initializeBackgroundAudio();

                // Try to resume in all possible ways
                const resumePromises = [];

                if (backgroundAudioContext && backgroundAudioContext.state === 'suspended') {
                    resumePromises.push(backgroundAudioContext.resume());
                }

                if (resumePromises.length > 0) {
                    Promise.all(resumePromises)
                        .then(() => resolve())
                        .catch(() => {
                            // Even if resume fails, we proceed - the YouTube player might still work
                            // due to being called from user interaction
                            resolve();
                        });
                } else {
                    resolve();
                }
            });
        }

        // Initialize audio context immediately on any user interaction
        function initAudioOnInteraction() {
            // Initialize audio context aggressively on first user interaction
            aggressiveAudioContextInit();

            // Remove the event listener after first interaction to avoid repeated initialization
            ['click', 'touchstart', 'keydown', 'mousedown'].forEach(eventType => {
                document.removeEventListener(eventType, initAudioOnInteraction, { passive: true });
            });
        }

        // Add event listeners for immediate audio context initialization
        ['click', 'touchstart', 'keydown', 'mousedown'].forEach(eventType => {
            document.addEventListener(eventType, initAudioOnInteraction, { passive: true });
        });

        // Handle visibility changes for mobile background audio
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                // When returning to foreground, ensure audio is properly resumed
                if (state.youtubePlayer && state.isYouTubePlaying) {
                    // Small delay to ensure YouTube player is ready
                    setTimeout(() => {
                        if (state.youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                            toggleYouTubePlay();
                        } else {
                            // If already playing, make sure PWA updates are running
                            startPWAProgressUpdates();
                        }
                    }, 100);
                }
            } else {
                // When going to background, ensure PWA updates continue if needed
                if (state.youtubePlayer && state.isYouTubePlaying) {
                    // PWA updates should continue in background, so no need to stop them here
                }
            }
        });

        // Additional mobile-specific handling
        if ('mediaSession' in navigator) {
            navigator.mediaSession.setActionHandler('play', toggleYouTubePlay);
            navigator.mediaSession.setActionHandler('pause', toggleYouTubePlay);

            // Handle seek actions to maintain audio session
            try {
                navigator.mediaSession.setActionHandler('seekbackward', () => {
                    if (state.youtubePlayer) {
                        const currentTime = state.youtubePlayer.getCurrentTime();
                        state.youtubePlayer.seekTo(Math.max(0, currentTime - 10), true);
                    }
                });

                navigator.mediaSession.setActionHandler('seekforward', () => {
                    if (state.youtubePlayer) {
                        const currentTime = state.youtubePlayer.getCurrentTime();
                        const duration = state.youtubePlayer.getDuration();
                        state.youtubePlayer.seekTo(Math.min(duration, currentTime + 10), true);
                    }
                });
            } catch (error) {
                console.log('Seek actions not supported:', error);
            }
        }

        // Additional event listeners to handle app lifecycle and backgrounding
        window.addEventListener('pagehide', function () {
            // Try to maintain audio when page is hidden (e.g., switching apps)
            if (state.youtubePlayer && state.isYouTubePlaying) {
                // Store the current time to resume from when returning
                state.lastPosition = state.youtubePlayer.getCurrentTime();
            }
        });

        // Handle page visibility changes more comprehensively
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible') {
                // When returning to foreground, resume audio if needed
                if (state.youtubePlayer && state.isYouTubePlaying) {
                    // Small delay to ensure YouTube player is ready after page becomes visible
                    setTimeout(() => {
                        const playerState = state.youtubePlayer.getPlayerState();
                        if (playerState !== YT.PlayerState.PLAYING) {
                            // Try to resume playback
                            state.youtubePlayer.playVideo();
                            startPWAProgressUpdates(); // Ensure PWA updates start when resuming
                        } else {
                            // If already playing, make sure PWA updates are running
                            startPWAProgressUpdates();
                        }
                    }, 500);
                }
            } else {
                // When going to background, ensure PWA updates continue if playing
                if (state.youtubePlayer && state.isYouTubePlaying) {
                    // Ensure PWA updates are running when going to background
                    startPWAProgressUpdates();
                }
            }
        });

        // Handle focus/blur events which can affect audio on mobile
        window.addEventListener('focus', function () {
            // On iOS Safari especially, audio may need to be resumed when window regains focus
            if (state.youtubePlayer && state.isYouTubePlaying && state.youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                setTimeout(() => {
                    state.youtubePlayer.playVideo();
                }, 100);
            }
        });

        window.addEventListener('blur', function () {
            // Store position when leaving the page
            if (state.youtubePlayer && state.isYouTubePlaying) {
                state.lastPosition = state.youtubePlayer.getCurrentTime();
            }
        });

        // Toast æç¤º
        function showToast(message) {
            const toast = document.createElement('div');
            toast.style.cssText = `
        position: fixed;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        font-size: 14px;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
    `;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease forwards';
                setTimeout(() => toast.remove(), 300);
            }, 500);
        }

        // æ­Œè¯
        async function fetchLyrics(artist, title) {
            // ç”Ÿæˆç¼“å­˜é”®
            const cacheKey = `lyrics_${encodeURIComponent(artist)}_${encodeURIComponent(title)}`;
            const cachedLyrics = CacheManager.get(cacheKey);

            if (cachedLyrics) {
                console.log('Using cached lyrics for:', artist, title);
                $('lyrics-text').textContent = cachedLyrics;
                return;
            }

            try {
                const cleanTitle = title.split('(')[0].split('-')[0].trim();
                const cleanArtist = artist.split('&')[0].split(',')[0].trim();

                // å°è¯•ä½¿ç”¨ YouTube API è·å–æ­Œè¯ï¼ˆå¦‚æœå½“å‰æ’­æ”¾çš„æ˜¯ YouTube æ­Œæ›²ï¼‰
                if (state.currentTrack && state.currentTrack.trackId &&
                    (state.currentTrack.kind === 'youtube' || state.currentTrack.previewUrl?.includes('youtube.com'))) {
                    try {
                        const youTubeLyricsRes = await fetch(`https://api.yuangs.cc/youtubeapi/lyrics/${state.currentTrack.trackId}`);
                        if (youTubeLyricsRes.ok) {
                            const youTubeLyricsData = await youTubeLyricsRes.json();

                            if (youTubeLyricsData.success && youTubeLyricsData.data && youTubeLyricsData.data.lyrics) {
                                $('lyrics-text').textContent = youTubeLyricsData.data.lyrics;
                                // ç¼“å­˜æ­Œè¯ï¼ˆæœ‰æ•ˆæœŸ24å°æ—¶ï¼‰
                                CacheManager.set(cacheKey, youTubeLyricsData.data.lyrics, 24);
                                return;
                            }
                        } else {
                            console.error('YouTube lyrics API è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç :', youTubeLyricsRes.status);
                        }
                    } catch (e) {
                        console.error('YouTube lyrics API failed:', e);
                        // å¦‚æœ YouTube API å¤±è´¥ï¼Œç»§ç»­å°è¯•å…¶ä»– API
                    }
                }

                // å°è¯•ä½¿ç”¨åŸç‰ˆ API
                const res = await fetch(`https://api.lyrics.ovh/v1/${encodeURIComponent(cleanArtist)}/${encodeURIComponent(cleanTitle)}`);

                if (res.ok) {
                    const data = await res.json();
                    if (data.lyrics) {
                        $('lyrics-text').textContent = data.lyrics;
                        // ç¼“å­˜æ­Œè¯ï¼ˆæœ‰æ•ˆæœŸ24å°æ—¶ï¼‰
                        CacheManager.set(cacheKey, data.lyrics, 24);
                        return;
                    }
                }
                showCatFallback();
            } catch {
                showCatFallback();
            }
        }

        async function showCatFallback() {
            try {
                const res = await fetch('https://api.thecatapi.com/v1/images/search');
                const data = await res.json();
                if (data?.[0]?.url) {
                    $('lyrics-text').innerHTML = `
                        <div style="margin-bottom: 20px; color: var(--text-secondary);">æš‚æ— æ­Œè¯ï¼Œé€ä½ ä¸€åªçŒ« ğŸ±</div>
                        <img src="${data[0].url}" style="max-width: 280px; border-radius: 16px; box-shadow: 0 8px 32px rgba(0,0,0,0.4);">
                    `;
                    return;
                }
            } catch { }
            $('lyrics-text').textContent = 'æš‚æ— æ­Œè¯';
        }

        // è®¾ç½®ç»´åŸºç™¾ç§‘é“¾æ¥
        function setupWikipediaLink(artistName) {
            const cleanName = artistName.split(/&|,|feat\.|ft\./i)[0].trim();
            const encodedName = encodeURIComponent(cleanName);

            // å­˜å‚¨é“¾æ¥åˆ°è‰ºæœ¯å®¶å…ƒç´ çš„æ•°æ®å±æ€§ as fallback
            $('lyrics-artist').dataset.wikiUrl = `https://zh.wikipedia.org/wiki/${encodedName}`;

            // éªŒè¯é“¾æ¥æ˜¯å¦å­˜åœ¨ï¼ˆå¼‚æ­¥æ£€æŸ¥ï¼‰
            verifyWikipediaPageExists(cleanName);
        }

        // éªŒè¯ç»´åŸºç™¾ç§‘é¡µé¢æ˜¯å¦å­˜åœ¨
        async function verifyWikipediaPageExists(artistName) {
            const cleanName = artistName.split(/&|,|feat\.|ft\./i)[0].trim();
            const encodedName = encodeURIComponent(cleanName);

            // é¦–å…ˆå°è¯•ä¸­æ–‡ç»´åŸºç™¾ç§‘
            try {
                const res = await fetch(`https://zh.wikipedia.org/api/rest_v1/page/summary/${encodedName}`);

                if (res.ok) {
                    const data = await res.json();
                    if (data.title) {
                        // ä¸­æ–‡ç»´åŸºç™¾ç§‘å­˜åœ¨ï¼Œä½¿ç”¨ä¸­æ–‡é“¾æ¥
                        $('lyrics-artist').dataset.wikiUrl = `https://zh.wikipedia.org/wiki/${encodedName}`;
                        return;
                    }
                }
            } catch { }

            // å¦‚æœä¸­æ–‡ä¸å­˜åœ¨ï¼Œå°è¯•è‹±æ–‡ç»´åŸºç™¾ç§‘
            try {
                const res = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodedName}`);

                if (res.ok) {
                    const data = await res.json();
                    if (data.title) {
                        // è‹±æ–‡ç»´åŸºç™¾ç§‘å­˜åœ¨ï¼Œä½¿ç”¨è‹±æ–‡é“¾æ¥
                        $('lyrics-artist').dataset.wikiUrl = `https://en.wikipedia.org/wiki/${encodedName}`;
                        return;
                    }
                }
            } catch { }

            // å¦‚æœéƒ½ä¸å­˜åœ¨ï¼Œè®¾ç½®ä¸ºæœç´¢é¡µé¢
            $('lyrics-artist').dataset.wikiUrl = `https://zh.wikipedia.org/wiki/Special:Search?search=${encodedName}`;
        }

        // æ­Œæ‰‹ç™¾ç§‘
        async function fetchArtistWiki(artistName) {
            const cleanName = artistName.split(/&|,|feat\.|ft\./i)[0].trim();
            const cacheKey = `wiki_${encodeURIComponent(cleanName)}`;
            const cachedWiki = CacheManager.get(cacheKey);

            if (cachedWiki) {
                console.log('Using cached wiki for:', cleanName);
                $('wiki-title').textContent = `å…³äº ${cachedWiki.title}`;
                $('wiki-text').textContent = cachedWiki.extract;
                $('lyrics-wiki').classList.add('show');
                return;
            }

            try {
                let res = await fetch(`https://zh.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(cleanName)}`);
                if (!res.ok) {
                    res = await fetch(`https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(cleanName)}`);
                }

                if (res.ok) {
                    const data = await res.json();
                    if (data.extract) {
                        $('wiki-title').textContent = `å…³äº ${data.title}`;
                        $('wiki-text').textContent = data.extract;
                        $('lyrics-wiki').classList.add('show');
                        // ç¼“å­˜ç»´åŸºç™¾ç§‘æ•°æ®ï¼ˆæœ‰æ•ˆæœŸ12å°æ—¶ï¼‰
                        CacheManager.set(cacheKey, {
                            title: data.title,
                            extract: data.extract
                        }, 12);
                    } else {
                        // If no wiki summary found, hide the wiki section
                        $('lyrics-wiki').classList.remove('show');
                    }
                }
            } catch { }
        }

        // æ­Œè¯é¡µé¢
        function openLyrics() {
            if (!state.currentTrack) return;
            $('lyrics-modal').classList.add('show');
        }

        function closeLyrics() {
            $('lyrics-modal').classList.remove('show');
        }

        // å¤©æ°”æœç´¢ - éšæœºå…³é”®è¯å¢å¼ºç‰ˆ
        async function searchByWeather() {
            try {
                // 1. è·å–åœ°ç†ä½ç½®
                const geoRes = await fetch('https://get.geojs.io/v1/ip/geo.json');
                const geo = await geoRes.json();

                // 2. è·å–å¤©æ°”æ•°æ®
                const weatherRes = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${geo.latitude}&longitude=${geo.longitude}&current_weather=true`);
                const weatherData = await weatherRes.json();
                const code = weatherData.current_weather.weathercode;

                // 3. å®šä¹‰å˜é‡
                let keywordOptions = []; // å€™é€‰å…³é”®è¯åˆ—è¡¨
                let weatherLabel = 'æœªçŸ¥'; // å¤©æ°”ä¸­æ–‡å

                // 4. æ ¹æ®å¤©æ°”ä»£ç åˆ†é…å…³é”®è¯åº“ï¼Œå¹¶ä¸æ ‡ç­¾ç³»ç»Ÿå…³è”
                if (code <= 3) {
                    // æ™´æœ— (0-3)
                    weatherLabel = 'æ™´æœ—';
                    // ä»æƒ…ç»ªæ ‡ç­¾ä¸­çš„ç§¯ææƒ…ç»ªä¸­é€‰æ‹©
                    keywordOptions = [...musicTags.attributes.moods.positive, ...musicTags.scenarios.activity_based.exercise, ...musicTags.scenarios.activity_based.social];
                }
                else if (code >= 45 && code <= 48) {
                    // é›¾å¤© (45, 48)
                    weatherLabel = 'é›¾å¤©';
                    // ä»æ°›å›´æ ‡ç­¾ä¸­é€‰æ‹©ç¥ç§˜ã€æ¢¦å¹»çš„æ ‡ç­¾
                    keywordOptions = [...musicTags.attributes.moods.intense, ...musicTags.attributes.moods.melancholy, ...musicTags.attributes.styles.aesthetic];
                }
                else if (code >= 51 && code <= 67) {
                    // ä¸‹é›¨ (51-67)
                    weatherLabel = 'ä¸‹é›¨';
                    // é€‰æ‹©å®‰é™ã€èˆ’é€‚çš„éŸ³ä¹ç±»å‹
                    keywordOptions = [...musicTags.attributes.moods.melancholy, ...musicTags.scenarios.activity_based.relaxation, ...musicTags.genres.main.traditional];
                }
                else if (code >= 71 && code <= 86) {
                    // ä¸‹é›ª (71-86)
                    weatherLabel = 'ä¸‹é›ª';
                    // é€‰æ‹©æ¸©æš–ã€èŠ‚æ—¥çš„éŸ³ä¹ç±»å‹
                    keywordOptions = [...musicTags.scenarios.special_occasions, ...musicTags.genres.main.traditional, ...musicTags.nature_abstract.nature.weather];
                }
                else if (code >= 95) {
                    // é›·æš´ (95+)
                    weatherLabel = 'é›·æš´';
                    // é€‰æ‹©å¼ºçƒˆã€æœ‰å†²å‡»åŠ›çš„éŸ³ä¹ç±»å‹
                    keywordOptions = [...musicTags.attributes.moods.intense, ...musicTags.genres.main.rock, ...musicTags.genres.main.electronic];
                }
                else {
                    // å¤šäº‘/é˜´å¤© (å…¶ä»–æƒ…å†µ)
                    weatherLabel = 'å¤šäº‘';
                    // é€‰æ‹©æ¸©å’Œã€æ—¥å¸¸çš„éŸ³ä¹ç±»å‹
                    keywordOptions = [...musicTags.attributes.moods.mellow, ...musicTags.scenarios.time_based.daily_routine, ...musicTags.genres.main.pop];
                }

                // 5. æ ¸å¿ƒï¼šä»æ•°ç»„ä¸­éšæœºé€‰æ‹©ä¸€ä¸ªå…³é”®è¯
                const randomKeyword = keywordOptions[Math.floor(Math.random() * keywordOptions.length)];
                if (!randomKeyword) {
                    // å¦‚æœæ ‡ç­¾åº“ä¸­æ²¡æœ‰å¯¹åº”ç±»åˆ«ï¼Œä½¿ç”¨é»˜è®¤å¤©æ°”ç›¸å…³çš„å…³é”®è¯
                    const defaultKeywords = [
                        'Sunny Day', 'Rainy Day', 'Snow Winter', 'Cloudy Sky',
                        'Foggy Mood', 'Thunder Storm', 'Summer Vibes', 'Winter Mood'
                    ];
                    const randomKeyword = defaultKeywords[Math.floor(Math.random() * defaultKeywords.length)];
                    $('search-input').value = randomKeyword;
                } else {
                    $('search-input').value = randomKeyword;
                }

                // 6. æ‰§è¡Œæœç´¢ä¸æç¤º
                searchMusic();
                alert(`ğŸ“ ${geo.city || 'æœªçŸ¥'}\nğŸŒ¤ï¸ ${weatherLabel}\nğŸ² æ™ºèƒ½æ¨è: ${$('search-input').value}`);

            } catch (e) {
                console.error(e);
                alert('è·å–å¤©æ°”å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
            }
        }

        // å¼¹å¹•ç³»ç»Ÿ
        function startDanmaku() {
            $('danmaku').classList.add('show');
            $('danmaku').innerHTML = '';
            // Clear the displayed danmaku set when starting
            state.displayedDanmaku.clear();
            // Clear recent danmaku indices to allow more variety
            if (state.recentDanmakuIndices) {
                state.recentDanmakuIndices = [];
            }
            // Reset tracks
            state.tracks = [false, false, false, false, false];

            if (state.danmakuInterval) clearInterval(state.danmakuInterval);

            // åˆå§‹åŒ–å¼¹å¹•æ•°æ®
            DanmakuManager.fetchAndFill().then(() => {
                // ç«‹å³ç”Ÿæˆå‡ æ¡å¼¹å¹•ä»¥å¢åŠ å¤šæ ·æ€§
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        spawnDanmaku();
                    }, i * 800); // é”™å¼€æ—¶é—´æ˜¾ç¤ºï¼Œé¿å…åŒæ—¶å‡ºç°
                }

                // è®¾ç½®å®šæ—¶å™¨æŒç»­ç”Ÿæˆå¼¹å¹•
                state.danmakuInterval = setInterval(spawnDanmaku, 2000); // å‡å°‘é—´éš”ä»¥å¢åŠ é¢‘ç‡
                // å¼€å§‹å®šæœŸåˆ·æ–°å¼¹å¹•æ•°æ®
                DanmakuManager.startRefresh();
            });
        }

        async function spawnDanmaku() {
            // ä»å…¨å±€å¼¹å¹•å­˜å‚¨ä¸­è·å–éšæœºå¼¹å¹•
            const danmaku = DanmakuManager.getRandom();

            if (danmaku) {
                renderDanmaku(danmaku);
            } else {
                // å¦‚æœæ²¡æœ‰å¯ç”¨å¼¹å¹•ï¼Œè·å–æ–°æ•°æ®
                await DanmakuManager.fillNewRecords(5);
                const newDanmaku = DanmakuManager.getRandom();
                if (newDanmaku) {
                    renderDanmaku(newDanmaku);
                }
            }
        }

        function renderDanmaku(data) {
            // Create a unique content identifier to prevent duplicates
            const content = `${data.name}:${data.text}`;
            const fullContent = `${data.name}:${data.text}:${Date.now()}`; // Add timestamp to make it always unique for display

            // Check if this content is already displayed in the current view
            // Only check for recent duplicates (last 20 items) to avoid the issue of no fresh content
            if (state.displayedDanmaku.size > 20) {
                // Clear the set if it gets too large to avoid memory issues and allow refresh
                const recent = Array.from(state.displayedDanmaku).slice(-10); // Keep last 10 items as recent
                state.displayedDanmaku.clear();
                recent.forEach(item => state.displayedDanmaku.add(item));
            }

            if (state.displayedDanmaku.has(content)) {
                // If this exact content is already displayed recently, try to get another one
                setTimeout(async () => {
                    const alternativeDanmaku = DanmakuManager.getRandom();
                    if (alternativeDanmaku) {
                        renderDanmaku(alternativeDanmaku);
                    } else {
                        // If no alternative, try to fill with new records
                        await DanmakuManager.fillNewRecords(3);
                        const newDanmaku = DanmakuManager.getRandom();
                        if (newDanmaku) {
                            renderDanmaku(newDanmaku);
                        }
                    }
                }, 100); // Small delay to avoid blocking
                return;
            }

            let track = state.tracks.findIndex(t => !t);
            if (track === -1) {
                // If all tracks are busy, try to find the one that will finish earliest or just pick randomly
                track = Math.floor(Math.random() * 5);
            }

            state.tracks[track] = true;

            const item = document.createElement('div');
            item.className = 'danmaku-item';
            item.style.top = (track * 40 + 10) + 'px';
            item.style.animationDuration = (12 + Math.random() * 5) + 's';

            item.innerHTML = `
                <img class="danmaku-avatar" src="${data.avatar}" alt="">
                <span class="danmaku-name">${escapeHtml(data.name)}:</span>
                <span class="danmaku-text">${escapeHtml(data.text)}</span>
            `;

            // Add content to the displayed set
            state.displayedDanmaku.add(content);

            item.onanimationend = () => {
                // Remove content from the displayed set when animation ends
                state.displayedDanmaku.delete(content);
                item.remove();
                state.tracks[track] = false;
            };

            // Also handle manual removal if element is removed for other reasons
            const originalRemove = item.remove;
            item.remove = function () {
                state.displayedDanmaku.delete(content);
                state.tracks[track] = false;
                originalRemove.call(this);
            };

            $('danmaku').appendChild(item);
        }

        // å¼¹å¹•ç®¡ç†å™¨
        const DanmakuManager = {
            STORAGE_KEY: 'danmaku_records',
            MAX_RECORDS: 100,
            EXPIRY_TIME: 12 * 60 * 60 * 1000, // 12 hours in milliseconds
            REFRESH_INTERVAL: null, // å®šæ—¶åˆ·æ–°å®šæ—¶å™¨

            // è·å–æ‰€æœ‰å¼¹å¹•è®°å½•
            getAll: () => {
                try {
                    const data = localStorage.getItem(DanmakuManager.STORAGE_KEY);
                    if (!data) return [];

                    const records = JSON.parse(data);
                    const now = Date.now();

                    // è¿‡æ»¤æ‰è¿‡æœŸçš„è®°å½•
                    const validRecords = records.filter(record => now - record.timestamp < DanmakuManager.EXPIRY_TIME);

                    // å¦‚æœæœ‰è¿‡æœŸè®°å½•ï¼Œæ›´æ–°å­˜å‚¨
                    if (records.length !== validRecords.length) {
                        localStorage.setItem(DanmakuManager.STORAGE_KEY, JSON.stringify(validRecords));
                    }

                    return validRecords;
                } catch (e) {
                    console.error('Failed to get danmaku records:', e);
                    return [];
                }
            },

            // ä¿å­˜å¼¹å¹•è®°å½•ï¼ˆæœ€å¤š100æ¡ï¼Œè¶…å‡ºåˆ™ç§»é™¤æœ€æ—§çš„ï¼‰
            save: (records) => {
                try {
                    // ç¡®ä¿ä¸è¶…è¿‡æœ€å¤§æ•°é‡
                    if (records.length > DanmakuManager.MAX_RECORDS) {
                        records = records.slice(-DanmakuManager.MAX_RECORDS);
                    }

                    localStorage.setItem(DanmakuManager.STORAGE_KEY, JSON.stringify(records));
                } catch (e) {
                    console.error('Failed to save danmaku records:', e);
                }
            },

            // æ·»åŠ æ–°å¼¹å¹•è®°å½•
            add: (danmaku) => {
                let records = DanmakuManager.getAll();
                records.push({
                    ...danmaku,
                    timestamp: Date.now()
                });

                // ä¿å­˜æ—¶è‡ªåŠ¨æ¸…ç†è¿‡æœŸè®°å½•å¹¶é™åˆ¶æ•°é‡
                DanmakuManager.save(records);
            },

            // éšæœºè·å–ä¸€æ¡å¼¹å¹•è®°å½•ï¼Œé¿å…çŸ­æ—¶é—´å†…é‡å¤
            getRandom: () => {
                const records = DanmakuManager.getAll();
                if (records.length === 0) return null;

                // å¦‚æœè®°å½•æ•°é‡å¤§äº5ï¼Œå°è¯•é¿å…è¿”å›æœ€è¿‘è¿”å›è¿‡çš„å¼¹å¹•
                if (records.length > 5) {
                    // ä¿å­˜æœ€è¿‘è¿”å›çš„å¼¹å¹•ç´¢å¼•ï¼Œé¿å…é‡å¤
                    if (!state.recentDanmakuIndices) {
                        state.recentDanmakuIndices = [];
                    }

                    // æ¸…é™¤è¿‡æœŸçš„ç´¢å¼•è®°å½•ï¼ˆè¶…è¿‡10ä¸ªå°±ä¿ç•™æœ€æ–°çš„5ä¸ªï¼‰
                    if (state.recentDanmakuIndices.length > 10) {
                        state.recentDanmakuIndices = state.recentDanmakuIndices.slice(-5);
                    }

                    // å°è¯•æ‰¾åˆ°ä¸€ä¸ªä¸åœ¨æœ€è¿‘åˆ—è¡¨ä¸­çš„å¼¹å¹•
                    let validIndices = [];
                    for (let i = 0; i < records.length; i++) {
                        if (!state.recentDanmakuIndices.includes(i)) {
                            validIndices.push(i);
                        }
                    }

                    // å¦‚æœæ‰€æœ‰å¼¹å¹•éƒ½åœ¨æœ€è¿‘åˆ—è¡¨ä¸­ï¼Œæˆ–è€…æœ‰æ•ˆé€‰é¡¹å¤ªå°‘ï¼Œåˆ™ä½¿ç”¨æ‰€æœ‰è®°å½•
                    if (validIndices.length < 3) {
                        validIndices = Array.from({ length: records.length }, (_, i) => i);
                    }

                    const randomIndex = validIndices[Math.floor(Math.random() * validIndices.length)];
                    state.recentDanmakuIndices.push(randomIndex);

                    return records[randomIndex];
                }

                // å¦‚æœè®°å½•æ•°é‡å°‘äºç­‰äº5ï¼Œç›´æ¥éšæœºè¿”å›
                return records[Math.floor(Math.random() * records.length)];
            },

            // è·å–å¹¶å¡«å……æ–°å¼¹å¹•æ•°æ®ï¼ˆå¦‚æœè®°å½•ä¸ºç©ºæˆ–è¿‡æœŸï¼‰
            fetchAndFill: async () => {
                const records = DanmakuManager.getAll();
                const now = Date.now();

                // å¦‚æœè®°å½•å°‘äº15æ¡ï¼Œè¯·æ±‚æ–°æ•°æ®ï¼ˆå¢åŠ æ•°é‡ä»¥ç¡®ä¿æœ‰è¶³å¤Ÿçš„å¼¹å¹•ï¼‰
                if (records.length < 15) {
                    await DanmakuManager.fillNewRecords(30); // å¢åŠ å¡«å……æ•°é‡
                } else {
                    // æ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°
                    const oldestRecord = records.reduce((oldest, record) => {
                        return record.timestamp < oldest.timestamp ? record : oldest;
                    }, records[0]);

                    if (now - oldestRecord.timestamp > DanmakuManager.EXPIRY_TIME * 0.5) { // é™ä½æ›´æ–°é˜ˆå€¼åˆ°50%æœ‰æ•ˆæœŸ
                        await DanmakuManager.fillNewRecords(15); // å¢åŠ æ¯æ¬¡å¡«å……çš„æ•°é‡
                    }
                }
            },

            // å¼€å§‹å®šæœŸåˆ·æ–°å¼¹å¹•æ•°æ®
            startRefresh: () => {
                // åœæ­¢ä¹‹å‰çš„åˆ·æ–°å®šæ—¶å™¨
                if (DanmakuManager.REFRESH_INTERVAL) {
                    clearInterval(DanmakuManager.REFRESH_INTERVAL);
                }

                // æ¯10åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æ˜¯å¦éœ€è¦æ›´æ–°å¼¹å¹•æ•°æ®
                DanmakuManager.REFRESH_INTERVAL = setInterval(async () => {
                    await DanmakuManager.fetchAndFill();
                }, 10 * 60 * 1000); // 10åˆ†é’Ÿ
            },

            // åœæ­¢å®šæœŸåˆ·æ–°å¼¹å¹•æ•°æ®
            stopRefresh: () => {
                if (DanmakuManager.REFRESH_INTERVAL) {
                    clearInterval(DanmakuManager.REFRESH_INTERVAL);
                    DanmakuManager.REFRESH_INTERVAL = null;
                }
            },

            // å¡«å……æ–°çš„å¼¹å¹•è®°å½•
            fillNewRecords: async (count) => {
                try {
                    for (let i = 0; i < count; i++) {
                        // éšæœºç”Ÿæˆå¼¹å¹•æ•°æ®ï¼ˆå¦‚æœAPIè°ƒç”¨å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤å€¼ï¼‰
                        const useKanye = Math.random() > 0.5;

                        const [userRes, textRes] = await Promise.all([
                            fetch('https://randomuser.me/api/?inc=name,picture'),
                            useKanye
                                ? fetch('https://api.kanye.rest/')
                                : fetch('https://v1.hitokoto.cn/?c=a&c=b')
                        ]);

                        const user = await userRes.json();
                        const text = await textRes.json();

                        const danmaku = {
                            name: user.results[0].name.first,
                            avatar: user.results[0].picture.thumbnail,
                            text: text.quote || text.hitokoto
                        };

                        DanmakuManager.add(danmaku);
                    }
                } catch (err) {
                    console.error('Failed to fetch new danmaku records:', err);
                    // å¦‚æœAPIè°ƒç”¨å¤±è´¥ï¼Œç”Ÿæˆä¸€äº›é»˜è®¤å¼¹å¹•
                    for (let i = 0; i < count; i++) {
                        const danmaku = {
                            name: 'ç”¨æˆ·' + (Math.floor(Math.random() * 10000)),
                            avatar: 'data:image/svg+xml;charset=UTF-8,%3Csvg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50"%3E%3Ccircle cx="25" cy="25" r="25" fill="%23ccc"/%3E%3C/svg%3E',
                            text: 'è¿™æ˜¯ä¸€æ¡éšæœºå¼¹å¹•'
                        };
                        DanmakuManager.add(danmaku);
                    }
                }
            }
        };

        // PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('SW registered:', reg.scope))
                .catch(err => console.log('SW failed:', err));
        }

        let deferredPrompt;
        window.addEventListener('beforeinstallprompt', e => {
            e.preventDefault();
            deferredPrompt = e;
            showInstallPrompt();
        });

        function showInstallPrompt() {
            if (document.querySelector('.install-prompt')) return;

            const div = document.createElement('div');
            div.className = 'install-prompt';
            div.innerHTML = `
                <div class="install-icon">ğŸ“±</div>
                <div class="install-text">
                    <div class="install-title">æ·»åŠ åˆ°ä¸»å±å¹•</div>
                    <div class="install-desc">è·å¾—æ›´å¥½çš„å…¨å±ä½“éªŒ</div>
                </div>
                <button class="install-btn" onclick="installApp()">å®‰è£…</button>
                <button class="install-close" onclick="this.parentElement.remove()">Ã—</button>
            `;
            document.body.appendChild(div);

            setTimeout(() => div.remove(), 10000);
        }

        // ========== æ”¶è—å’Œå†å²åŠŸèƒ½ ==========

        // åˆ‡æ¢æ”¶è—çŠ¶æ€
        function toggleFavorite() {
            if (!state.currentTrack) return;

            const trackId = state.currentTrack.trackId;
            const btn = $('favorite-btn');

            if (FavoritesManager.isFavorited(trackId)) {
                FavoritesManager.remove(trackId);
                btn.textContent = 'ğŸ¤';
                btn.classList.remove('favorited');
                showToast('å·²å–æ¶ˆæ”¶è—');
            } else {
                FavoritesManager.add(state.currentTrack);
                btn.textContent = 'â¤ï¸';
                btn.classList.add('favorited');
                showToast('å·²æ·»åŠ åˆ°æ”¶è—');
            }
        }

        // æ›´æ–°æ”¶è—æŒ‰é’®çŠ¶æ€
        function updateFavoriteButton() {
            if (!state.currentTrack) return;

            const btn = $('favorite-btn');
            const isFavorited = FavoritesManager.isFavorited(state.currentTrack.trackId);

            btn.textContent = isFavorited ? 'â¤ï¸' : 'ğŸ¤';
            if (isFavorited) {
                btn.classList.add('favorited');
            } else {
                btn.classList.remove('favorited');
            }
        }

        // æ‰“å¼€å†å²è®°å½•
        function openHistory() {
            $('history-modal').classList.add('show');
            renderHistory();
        }

        // å…³é—­å†å²è®°å½•
        function closeHistory() {
            $('history-modal').classList.remove('show');
        }

        // æ¸²æŸ“å†å²è®°å½•
        function renderHistory() {
            const history = HistoryManager.getAll();
            const container = $('history-content');

            if (history.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">ğŸ“–</div>
                        <div class="empty-title">æš‚æ— æ’­æ”¾å†å²</div>
                        <div class="empty-desc">å¼€å§‹æ’­æ”¾éŸ³ä¹åä¼šè‡ªåŠ¨è®°å½•</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div class="collection-grid">
                    ${history.map(song => `
                        <div class="collection-item" onclick="playHistoryItem('${song.trackId}')">
                            <img class="collection-item-cover" src="${(song.artworkUrl100 || song.artworkUrl || '').replace('100x100bb', '300x300bb')}" alt="">
                            <div class="collection-item-title">${escapeHtml(song.trackName)}</div>
                            <div class="collection-item-artist">${escapeHtml(song.artistName)}</div>
                            <div class="collection-item-time">${formatDate(song.playedAt)}</div>
                            <button class="collection-item-remove" onclick="event.stopPropagation(); removeHistory('${song.trackId}')" title="åˆ é™¤">Ã—</button>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // æ’­æ”¾å†å²ä¸­çš„æ­Œæ›²
        function playHistoryItem(trackId) {
            const history = HistoryManager.getAll();
            const song = history.find(s => s.trackId == trackId);
            if (song) {
                // å°†æ­Œæ›²æ·»åŠ åˆ°æ’­æ”¾åˆ—è¡¨å¹¶æ’­æ”¾
                state.playlist = [song];
                state.currentIndex = 0;
                playSong(0);
                closeHistory();
            }
        }

        // åˆ é™¤å†å²è®°å½•
        function removeHistory(trackId) {
            if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡å†å²è®°å½•å—ï¼Ÿ')) {
                HistoryManager.remove(trackId);
                renderHistory();
                showToast('å·²åˆ é™¤');
            }
        }

        // æ¸…ç©ºå†å²
        function clearHistory() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ’­æ”¾å†å²å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
                HistoryManager.clear();
                renderHistory();
                showToast('å†å²è®°å½•å·²æ¸…ç©º');
            }
        }

        // å¯¼å‡ºå†å²
        function exportHistory() {
            const history = HistoryManager.getAll();
            if (history.length === 0) {
                alert('æš‚æ— å†å²è®°å½•å¯å¯¼å‡º');
                return;
            }
            HistoryManager.export();
            showToast('å†å²è®°å½•å·²å¯¼å‡º');
        }

        // å¯¼å…¥å†å²
        function importHistory() {
            const input = $('import-file-input');
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const count = await HistoryManager.import(file);
                        renderHistory();
                        showToast(`æˆåŠŸå¯¼å…¥ ${count} æ¡å†å²è®°å½•`);
                    } catch (err) {
                        alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message);
                    }
                }
                input.value = '';
            };
            input.click();
        }

        // æ‰“å¼€æ”¶è—åˆ—è¡¨
        function openFavorites() {
            $('favorites-modal').classList.add('show');
            renderFavorites();
        }

        // å…³é—­æ”¶è—åˆ—è¡¨
        function closeFavorites() {
            $('favorites-modal').classList.remove('show');
        }

        // æ¸²æŸ“æ”¶è—åˆ—è¡¨
        function renderFavorites() {
            const favorites = FavoritesManager.getAll();
            const container = $('favorites-content');

            if (favorites.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-icon">â¤ï¸</div>
                        <div class="empty-title">æš‚æ— æ”¶è—</div>
                        <div class="empty-desc">ç‚¹å‡»æ’­æ”¾å™¨ä¸­çš„çˆ±å¿ƒæŒ‰é’®æ”¶è—æ­Œæ›²</div>
                    </div>
                `;
                return;
            }

            container.innerHTML = `
                <div class="collection-grid">
                    ${favorites.map(song => `
                        <div class="collection-item" onclick="playFavoriteItem('${song.trackId}')">
                            <img class="collection-item-cover" src="${(song.artworkUrl100 || song.artworkUrl || '').replace('100x100bb', '300x300bb')}" alt="">
                            <div class="collection-item-title">${escapeHtml(song.trackName)}</div>
                            <div class="collection-item-artist">${escapeHtml(song.artistName)}</div>
                            <div class="collection-item-time">${formatDate(song.favoritedAt)}</div>
                            <button class="collection-item-remove" onclick="event.stopPropagation(); removeFavorite('${song.trackId}')" title="å–æ¶ˆæ”¶è—">Ã—</button>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // æ’­æ”¾æ”¶è—ä¸­çš„æ­Œæ›²
        function playFavoriteItem(trackId) {
            const favorites = FavoritesManager.getAll();
            const song = favorites.find(s => s.trackId == trackId);
            if (song) {
                // å°†æ­Œæ›²æ·»åŠ åˆ°æ’­æ”¾åˆ—è¡¨å¹¶æ’­æ”¾
                state.playlist = [song];
                state.currentIndex = 0;
                playSong(0);
                closeFavorites();
            }
        }

        // å–æ¶ˆæ”¶è—
        function removeFavorite(trackId) {
            if (confirm('ç¡®å®šè¦å–æ¶ˆæ”¶è—è¿™é¦–æ­Œå—ï¼Ÿ')) {
                FavoritesManager.remove(trackId);
                renderFavorites();
                updateFavoriteButton();
                showToast('å·²å–æ¶ˆæ”¶è—');
            }
        }

        // æ¸…ç©ºæ”¶è—
        function clearFavorites() {
            if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ”¶è—å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ï¼')) {
                FavoritesManager.clear();
                renderFavorites();
                updateFavoriteButton();
                showToast('æ”¶è—å·²æ¸…ç©º');
            }
        }

        // å¯¼å‡ºæ”¶è—
        function exportFavorites() {
            const favorites = FavoritesManager.getAll();
            if (favorites.length === 0) {
                alert('æš‚æ— æ”¶è—å¯å¯¼å‡º');
                return;
            }
            FavoritesManager.export();
            showToast('æ”¶è—å·²å¯¼å‡º');
        }

        // å¯¼å…¥æ”¶è—
        function importFavorites() {
            const input = $('import-file-input');
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        const count = await FavoritesManager.import(file);
                        renderFavorites();
                        updateFavoriteButton();
                        showToast(`æˆåŠŸå¯¼å…¥ ${count} é¦–æ”¶è—`);
                    } catch (err) {
                        alert('å¯¼å…¥å¤±è´¥ï¼š' + err.message);
                    }
                }
                input.value = '';
            };
            input.click();
        }

        // æ ¼å¼åŒ–æ—¥æœŸ
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diff = now - date;

            // å°äº1åˆ†é’Ÿ
            if (diff < 60000) {
                return 'åˆšåˆš';
            }
            // å°äº1å°æ—¶
            if (diff < 3600000) {
                return Math.floor(diff / 60000) + 'åˆ†é’Ÿå‰';
            }
            // å°äº1å¤©
            if (diff < 86400000) {
                return Math.floor(diff / 3600000) + 'å°æ—¶å‰';
            }
            // å°äº7å¤©
            if (diff < 604800000) {
                return Math.floor(diff / 86400000) + 'å¤©å‰';
            }
            // æ˜¾ç¤ºå…·ä½“æ—¥æœŸ
            return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' });
        }

        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then(() => {
                    deferredPrompt = null;
                    document.querySelector('.install-prompt')?.remove();
                });
            }
        }
    </script>
</body>

</html>