<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ€åé˜²çº¿: æ˜Ÿé™…æˆ˜åœº</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€è®¾ç½® --- */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Segoe UI', Arial, sans-serif; user-select: none;
        }

        /* æ¸¸æˆç”»é¢å±‚ */
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* å—ä¼¤çº¢å±ç‰¹æ•ˆ */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, red 100%);
            opacity: 0; pointer-events: none; z-index: 99;
            transition: opacity 0.1s;
        }

        /* UI å®¹å™¨ */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 100; pointer-events: none; 
        }

        /* æŒ‰é’®ç»„ */
        .btn {
            position: absolute; z-index: 102; pointer-events: auto; cursor: pointer;
            background: rgba(20, 30, 40, 0.6); border: 2px solid rgba(100, 200, 255, 0.5); 
            border-radius: 50%; color: white; font-weight: bold; 
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.3); transition: 0.1s;
            backdrop-filter: blur(4px);
        }
        .btn:active { background: rgba(100, 200, 255, 0.5); transform: scale(0.95); }

        /* æŒ‰é’®ä½ç½®è°ƒæ•´ - é¿å¼€å³æ‘‡æ†ä¸­å¿ƒ */
        #btn-fire { 
            bottom: 70px; 
            right: 170px; /* ç§»åˆ°æ‘‡æ†å·¦ä¾§ */
            width: 90px; 
            height: 90px; 
            background: rgba(255, 50, 50, 0.4); 
            border-color: #ff5555;
            z-index: 110;
        }
        #btn-fire::after { content: 'SPACE'; font-size: 10px; position: absolute; bottom: 15px; opacity: 0.7; }

        #btn-reload { bottom: 180px; right: 120px; width: 55px; height: 55px; }
        #btn-reload::after { content: 'R'; font-size: 10px; position: absolute; bottom: 5px; opacity: 0.7; }

        #btn-switch { bottom: 160px; right: 40px; width: 55px; height: 55px; }
        #btn-switch::after { content: 'Q'; font-size: 10px; position: absolute; bottom: 5px; opacity: 0.7; }

        #btn-scope { display: none; bottom: 250px; right: 60px; width: 65px; height: 65px; background: rgba(0, 255, 255, 0.2); }
        #btn-scope::after { content: 'SHIFT'; font-size: 10px; position: absolute; bottom: 10px; opacity: 0.7; }

        /* HUD */
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 105;
            color: #00ffff; background: rgba(0, 20, 40, 0.6); padding: 15px; border-radius: 8px;
            font-size: 16px; pointer-events: none; border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        }
        #hud span { font-weight: bold; color: white; }
        #log { font-size: 12px; color: #ffaa00; margin-top: 8px; border-top: 1px solid rgba(255,255,255,0.1); padding-top:5px; }

        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 105;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="cyan" stroke-width="2"/><line x1="12" y1="2" x2="12" y2="8" stroke="cyan"/><line x1="12" y1="16" x2="12" y2="22" stroke="cyan"/><line x1="2" y1="12" x2="8" y2="12" stroke="cyan"/><line x1="16" y1="12" x2="22" y2="12" stroke="cyan"/></svg>');
            opacity: 0.8;
        }
        
        #controls-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); font-size: 14px; text-align: center;
            text-shadow: 1px 1px 2px #000; width: 100%; pointer-events: none;
        }

        /* è™šæ‹Ÿæ‘‡æ†æ ·å¼ */
        .joystick {
            position: absolute;
            width: 120px;
            height: 120px;
            bottom: 60px;
            z-index: 102;
            pointer-events: auto;
        }

        #joystick-left {
            left: 40px;
        }

        #joystick-right {
            right: 40px;
        }

        .joystick-base {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: rgba(20, 30, 40, 0.6);
            border: 2px solid rgba(100, 200, 255, 0.5);
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.3);
            backdrop-filter: blur(4px);
        }

        .joystick-handle {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(100, 200, 255, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.8);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.5);
            cursor: move;
        }

        /* é€‰æªç•Œé¢ */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #050510 0%, #101020 100%); z-index: 200;
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 40px; padding-bottom: 60px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            pointer-events: auto;
        }
        .card {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); 
            width: 85%; max-width: 450px; padding: 18px; margin: 8px;
            color: #ccc; border-radius: 8px; cursor: pointer; user-select: none;
            transition: 0.2s; display: flex; justify-content: space-between;
            align-items: center;
        }
        .card:hover { background: rgba(255,255,255,0.1); transform: translateX(10px); }
        .card.selected { border-color: #00ff00; background: rgba(0, 255, 0, 0.1); color: white; box-shadow: 0 0 15px rgba(0,255,0,0.2); }
        #start-btn {
            margin-top: 20px; margin-bottom: 20px; padding: 15px 60px; font-size: 24px; 
            background: #333; color: #666; font-weight: bold; flex-shrink: 0;
            border: none; border-radius: 4px; pointer-events: none; transition: 0.3s;
        }
        #start-btn.active { background: #00aaff; color: white; pointer-events: auto; cursor: pointer; box-shadow: 0 0 20px #00aaff; }
        
        /* --- iPad / Tablet ä¸“å±ä¼˜åŒ– --- */
        @media (min-width: 768px) {
            .btn { width: 65px; height: 65px; font-size: 18px; }
            #btn-fire { 
                width: 110px; height: 110px; 
                right: 220px; bottom: 80px;
                border-width: 4px;
            }
            #btn-reload { bottom: 220px; right: 140px; width: 60px; height: 60px; }
            #btn-switch { bottom: 200px; right: 50px; width: 60px; height: 60px; }
            #btn-scope { bottom: 300px; right: 70px; width: 75px; height: 75px; }
            
            .joystick { width: 160px; height: 160px; bottom: 80px; }
            #joystick-left { left: 60px; }
            #joystick-right { right: 60px; }
            .joystick-handle { width: 70px; height: 70px; }
            
            #hud { 
                top: 30px; left: 30px; 
                font-size: 20px; padding: 22px; 
                border-width: 2px;
            }
            #log { font-size: 14px; }
            
            #menu h1 { font-size: 48px; }
            .card { width: 500px; padding: 25px; font-size: 20px; }
        }

        /* å‘¼å¸ç¯åŠ¨ç”» */
        @keyframes pulse-glow {
            0% { box-shadow: 0 0 10px rgba(0, 150, 255, 0.3); }
            50% { box-shadow: 0 0 20px rgba(0, 150, 255, 0.6); }
            100% { box-shadow: 0 0 10px rgba(0, 150, 255, 0.3); }
        }

        .btn { animation: pulse-glow 3s infinite ease-in-out; }
        
        .hp-bar { 
            position: absolute; height: 6px; background: #ff3333; 
            z-index: 90; pointer-events: none; display: none; 
            box-shadow: 0 0 8px red; border-radius: 3px;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>
    <div id="damage-overlay"></div>

    <!-- UI -->
    <div id="ui-layer">
        <div id="hud">
            <div>è£…ç”²: <span id="ui-hp">100</span>%</div>
            <div>æ­¦å™¨: <span id="ui-wp">--</span></div>
            <div>å¼¹è¯: <span id="ui-ammo">--</span></div>
            <div id="log">æŒ‡æŒ¥å®˜: ç­‰å¾…éƒ¨ç½²...</div>
        </div>
        <div id="crosshair"></div>

        <!-- å·¦ä¾§è™šæ‹Ÿæ‘‡æ† - æ–¹å‘æ§åˆ¶ -->
        <div id="joystick-left" class="joystick">
            <div class="joystick-base"></div>
            <div class="joystick-handle"></div>
        </div>

        <!-- å³ä¾§è™šæ‹Ÿæ‘‡æ† - è§†è§’æ—‹è½¬ -->
        <div id="joystick-right" class="joystick">
            <div class="joystick-base"></div>
            <div class="joystick-handle"></div>
        </div>

        <div id="btn-fire" class="btn" 
             onpointerdown="event.preventDefault(); GAME.inputs.fire=true" 
             onpointerup="GAME.inputs.fire=false"
             onpointercancel="GAME.inputs.fire=false">ğŸ”¥</div>
        <div id="btn-reload" class="btn" onclick="doReload()">â™»ï¸</div>
        <div id="btn-switch" class="btn" onclick="doSwitch()">âš”ï¸</div>
        <div id="btn-scope" class="btn" onclick="doScope()">ğŸ¯</div>

        <div id="controls-hint">
            [W/A/S/D] ç§»åŠ¨ &nbsp; [â†‘/â†“/â†/â†’] ç„å‡† &nbsp; [Space] å¼€ç« &nbsp; [R] æ¢å¼¹ &nbsp; [Q] åˆ‡æª &nbsp; [Shift] ç„å‡†é•œ
        </div>
    </div>

    <!-- èœå• -->
    <div id="menu">
        <h1 style="color:#00aaff; text-shadow: 0 0 10px #00aaff; margin-bottom: 10px;">è¡Œæ˜Ÿé˜²å«å†›</h1>
        <h3 style="color:#888; margin-bottom: 30px;">é€‰æ‹© 2 æŠŠä¸»æ­¦å™¨</h3>
        <div class="card" onclick="selectWp(0, this)"><span>1. æ­»ç¥ç‹™å‡»</span><small style="color:#888">8å€é•œ/é«˜ä¼¤</small></div>
        <div class="card" onclick="selectWp(1, this)"><span>2. ç–¾é£å†²é”‹æª</span><small style="color:#888">é«˜å°„é€Ÿ</small></div>
        <div class="card" onclick="selectWp(2, this)"><span>3. é›·éœ†ç”µæª</span><small style="color:#888">è¿é”é—ªç”µ</small></div>
        <div class="card" onclick="selectWp(3, this)"><span>4. åŠ ç‰¹æ—æœºç‚®</span><small style="color:#888">å¼¹é›¨å‹åˆ¶</small></div>
        <div class="card" onclick="selectWp(4, this)"><span>5. æ¯ç­ç«ç®­ç­’</span><small style="color:#888">èŒƒå›´çˆ†ç‚¸</small></div>
        <button id="start-btn" onclick="startGame()">å¯åŠ¨å¼•æ“</button>
    </div>

<script>
    // --- å…¨å±€çŠ¶æ€ ---
    const GAME = {
        scene: null, camera: null, renderer: null, player: null, 
        ground: null, groundGrid: null,
        // è¾“å…¥
        inputs: { w:false, a:false, s:false, d:false, up:false, down:false, left:false, right:false, fire: false },
        camPitch: 0,
        // æ¸¸æˆå¯¹è±¡
        weapons: [], selected: [], curIdx: 0,
        bullets: [], enemies: [], allies: [], particles: [], decor: [], // è£…é¥°ç‰©
        isScoped: false, hp: 100, wave: 1, 
        isPlaying: false
    };

    const WEAPONS = [
        { name: "æ­»ç¥ç‹™å‡»", dmg: 100, rate: 1.5, mag: 6, type: 'hitscan', sniper: true },
        { name: "å†²é”‹æª", dmg: 12, rate: 0.1, mag: 60, type: 'hitscan' },
        { name: "é›·ç”µæª", dmg: 40, rate: 0.8, mag: 6, type: 'chain' },
        { name: "åŠ ç‰¹æ—", dmg: 8, rate: 0.05, mag: 500, type: 'hitscan' },
        { name: "ç«ç®­ç‚®", dmg: 0, rate: 1.5, mag: 5, type: 'rocket' }
    ];

    // --- èœå• ---
    function selectWp(id, el) {
        if(GAME.selected.includes(id)) {
            GAME.selected = GAME.selected.filter(i=>i!==id);
            el.classList.remove('selected');
        } else if(GAME.selected.length < 2) {
            GAME.selected.push(id);
            el.classList.add('selected');
        }
        const btn = document.getElementById('start-btn');
        if(GAME.selected.length===2) btn.classList.add('active');
        else btn.classList.remove('active');
    }

    function startGame() {
        if(GAME.selected.length !== 2) return;
        document.getElementById('menu').style.display = 'none';
        GAME.selected.forEach(id => {
            const w = WEAPONS[id];
            GAME.weapons.push({...w, curAmmo: w.mag, lastFire: 0});
        });
        initThree();
        initJoysticks(); // åˆå§‹åŒ–è™šæ‹Ÿæ‘‡æ†
    }

    // --- é”®ç›˜ç›‘å¬ ---
    window.addEventListener('keydown', (e) => {
        if(!GAME.isPlaying) return;
        switch(e.code) {
            case 'KeyW': GAME.inputs.w = true; break;
            case 'KeyS': GAME.inputs.s = true; break;
            case 'KeyA': GAME.inputs.a = true; break;
            case 'KeyD': GAME.inputs.d = true; break;
            case 'ArrowUp': GAME.inputs.up = true; break;
            case 'ArrowDown': GAME.inputs.down = true; break;
            case 'ArrowLeft': GAME.inputs.left = true; break;
            case 'ArrowRight': GAME.inputs.right = true; break;
            case 'Space': GAME.inputs.fire = true; break;
            case 'KeyR': doReload(); break;
            case 'KeyQ': doSwitch(); break;
            case 'ShiftLeft': case 'ShiftRight': doScope(); break;
        }
    });

    window.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'KeyW': GAME.inputs.w = false; break;
            case 'KeyS': GAME.inputs.s = false; break;
            case 'KeyA': GAME.inputs.a = false; break;
            case 'KeyD': GAME.inputs.d = false; break;
            case 'ArrowUp': GAME.inputs.up = false; break;
            case 'ArrowDown': GAME.inputs.down = false; break;
            case 'ArrowLeft': GAME.inputs.left = false; break;
            case 'ArrowRight': GAME.inputs.right = false; break;
            case 'Space': GAME.inputs.fire = false; break;
        }
    });

    function doReload() { GAME.weapons[GAME.curIdx].curAmmo = GAME.weapons[GAME.curIdx].mag; updateUI(); }
    function doSwitch() { GAME.curIdx = (GAME.curIdx + 1) % 2; GAME.isScoped = false; updateUI(); }
    function doScope() { GAME.isScoped = !GAME.isScoped; updateUI(); }

    // --- Three.js ---
    function initThree() {
        GAME.scene = new THREE.Scene();
        // 1. èƒŒæ™¯é«˜äº®ï¼šæ·±è“è‰²æ˜Ÿäº‘èƒŒæ™¯ + é›¾æ°”
        const bgColor = new THREE.Color(0x1a1a2e); 
        GAME.scene.background = bgColor;
        GAME.scene.fog = new THREE.Fog(bgColor, 30, 90);

        GAME.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 2000);
        
        GAME.renderer = new THREE.WebGLRenderer({ antialias: true });
        GAME.renderer.setSize(window.innerWidth, window.innerHeight);
        GAME.renderer.shadowMap.enabled = true;
        GAME.renderer.toneMapping = THREE.ACESFilmicToneMapping; // ç”µå½±çº§è‰²è°ƒ
        document.getElementById('game-container').appendChild(GAME.renderer.domElement);

        // 2. ç¯å…‰å¢å¼º
        // åŠçƒå…‰ (å¤©å…‰è“ï¼Œåœ°å…‰è¤)
        const hemiLight = new THREE.HemisphereLight(0x444488, 0x442200, 0.6);
        GAME.scene.add(hemiLight);
        // ä¸»é˜³å…‰
        const dir = new THREE.DirectionalLight(0xffeeb1, 1.2);
        dir.position.set(50, 80, 50); dir.castShadow = true;
        dir.shadow.mapSize.width = 2048; dir.shadow.mapSize.height = 2048;
        GAME.scene.add(dir);

        // åœ°é¢ (æ·±è‰²æè´¨)
        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x222225, 
            roughness: 0.9,
            metalness: 0.1
        });
        GAME.ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), planeMat);
        GAME.ground.rotation.x = -Math.PI/2; GAME.ground.receiveShadow = true;
        GAME.scene.add(GAME.ground);

        // ç½‘æ ¼è¾…åŠ© (æ›´æ·¡ä¸€ç‚¹)
        GAME.groundGrid = new THREE.GridHelper(2000, 200, 0x333344, 0x1a1a20);
        GAME.scene.add(GAME.groundGrid);

        // ç©å®¶ (å¢åŠ ä¸€ä¸ªè·Ÿéšç‚¹å…‰æºï¼Œç…§äº®è„šä¸‹)
        const pGeo = new THREE.ConeGeometry(0.5, 1.5, 8); pGeo.rotateX(Math.PI/2);
        GAME.player = new THREE.Mesh(pGeo, new THREE.MeshLambertMaterial({color: 0x00ccff, emissive: 0x004488}));
        GAME.player.position.y = 1; GAME.player.castShadow = true;
        
        const playerLight = new THREE.PointLight(0x00aaff, 1, 20);
        playerLight.position.set(0, 2, 0);
        GAME.player.add(playerLight);
        GAME.scene.add(GAME.player);

        // å†›é˜Ÿ
        for(let i=0; i<10; i++) {
            const ally = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshLambertMaterial({color: 0x0055ff}));
            ally.castShadow = true; ally.userData = { lastFire: 0, offsetAngle: (i/10)*Math.PI*2 };
            GAME.scene.add(ally); GAME.allies.push(ally);
        }

        // 3. åˆå§‹åŒ–åœ°é¢è£…é¥° (èŠ±è‰çŸ³å­)
        initDecorations();

        GAME.isPlaying = true;
        updateUI();
        spawnEnemy(); spawnEnemy(); spawnEnemy();
        
        requestAnimationFrame(loop);
    }

    // --- ç¯å¢ƒè£…é¥°ç³»ç»Ÿ ---
    function initDecorations() {
        const rockGeo = new THREE.DodecahedronGeometry(0.4, 0);
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 });
        
        const grassGeo = new THREE.ConeGeometry(0.2, 0.6, 4);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x33aa33 });
        
        const flowerGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const flowerMat = new THREE.MeshBasicMaterial({ color: 0xff00ff }); // å‘å…‰èŠ±æœµ

        for(let i=0; i<300; i++) {
            let type = Math.random();
            let mesh;
            
            if(type < 0.5) { // 50% çŸ³å¤´
                mesh = new THREE.Mesh(rockGeo, rockMat);
                mesh.scale.setScalar(0.5 + Math.random());
                mesh.position.y = 0.2;
            } else if(type < 0.9) { // 40% è‰
                mesh = new THREE.Mesh(grassGeo, grassMat);
                mesh.position.y = 0.3;
            } else { // 10% å¼‚æ˜ŸèŠ±
                mesh = new THREE.Mesh(flowerGeo, flowerMat);
                mesh.position.y = 0.5;
            }
            
            // éšæœºåˆ†å¸ƒåœ¨ç©å®¶å‘¨å›´
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 80;
            mesh.position.x = Math.cos(angle) * dist;
            mesh.position.z = Math.sin(angle) * dist;
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.rotation.y = Math.random() * Math.PI;
            
            GAME.scene.add(mesh);
            GAME.decor.push(mesh);
        }
    }

    // æ›´æ–°è£…é¥°ç‰©ä½ç½® (æ— é™å¾ªç¯é€»è¾‘)
    function updateDecorations() {
        GAME.decor.forEach(obj => {
            const dist = obj.position.distanceTo(GAME.player.position);
            // å¦‚æœç‰©ä½“ç¦»ç©å®¶å¤ªè¿œ(>70)ï¼ŒæŠŠå®ƒç§»åŠ¨åˆ°å‰æ–¹è§†çº¿èŒƒå›´å†…ï¼Œè¥é€ æ— é™æ„Ÿè§‰
            if(dist > 70) {
                const angle = GAME.player.rotation.y + (Math.random()-0.5) * Math.PI; // ç©å®¶å‰æ–¹æ‰‡å½¢åŒºåŸŸ
                const newDist = 60 + Math.random() * 10;
                obj.position.x = GAME.player.position.x - Math.sin(angle) * newDist; // æ³¨æ„ThreeJSæ—‹è½¬åæ ‡ç³»
                obj.position.z = GAME.player.position.z - Math.cos(angle) * newDist;
            }
        });
    }

    function spawnEnemy() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 30 + Math.random() * 20;
        const group = new THREE.Group();
        group.position.set(GAME.player.position.x + Math.sin(angle)*dist, 0, GAME.player.position.z + Math.cos(angle)*dist);
        
        // æ•Œäººå¤–è§‚ç¨å¾®å¤æ‚ä¸€ç‚¹ (èƒŒå½±è°ƒäº®)
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.4,1.8,6), new THREE.MeshStandardMaterial({color:0x88ee44, roughness:0.5}));
        body.position.y = 0.9;
        const head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5), new THREE.MeshStandardMaterial({color:0x66aa44}));
        head.position.y = 2.0;
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color:0xff0000}));
        eye.position.set(0, 2.0, 0.4);
        
        group.add(body); group.add(head); group.add(eye);
        group.userData = { hp: 50, maxHp: 50, speed: 4 + GAME.wave*0.5 };

        const bar = document.createElement('div');
        bar.className = 'hp-bar';
        bar.style.width = '30px';
        document.body.appendChild(bar);
        group.userData.bar = bar;

        GAME.scene.add(group); GAME.enemies.push(group);
    }

    function loop(time) {
        requestAnimationFrame(loop);
        if(!GAME.isPlaying) return;
        const dt = 0.016; const now = time/1000;

        // 1. WASD ç§»åŠ¨
        const moveSpd = 12;
        const camDir = new THREE.Vector3(); GAME.camera.getWorldDirection(camDir); camDir.y=0; camDir.normalize();
        const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0,1,0));
        
        if(GAME.inputs.w) GAME.player.position.addScaledVector(camDir, moveSpd * dt);
        if(GAME.inputs.s) GAME.player.position.addScaledVector(camDir, -moveSpd * dt);
        if(GAME.inputs.d) GAME.player.position.addScaledVector(camRight, moveSpd * dt);
        if(GAME.inputs.a) GAME.player.position.addScaledVector(camRight, -moveSpd * dt);

        // æ— é™åœ°é¢è·Ÿéš
        GAME.ground.position.x = GAME.player.position.x;
        GAME.ground.position.z = GAME.player.position.z;
        GAME.groundGrid.position.x = Math.floor(GAME.player.position.x / 10) * 10;
        GAME.groundGrid.position.z = Math.floor(GAME.player.position.z / 10) * 10;
        
        // æ›´æ–°èŠ±è‰çŸ³å­ (æ— é™å¾ªç¯)
        updateDecorations();

        // 2. ç®­å¤´é”® ç„å‡†
        const rotSpd = 2.5 * dt;
        if(GAME.inputs.left) GAME.player.rotation.y += rotSpd;
        if(GAME.inputs.right) GAME.player.rotation.y -= rotSpd;
        if(GAME.inputs.up) GAME.camPitch += rotSpd * 10;
        if(GAME.inputs.down) GAME.camPitch -= rotSpd * 10;
        GAME.camPitch = Math.max(-10, Math.min(20, GAME.camPitch));

        // 3. ç›¸æœºè·Ÿéš
        const targetPos = new THREE.Vector3(0, GAME.isScoped?1.5:5, GAME.isScoped?1.5:8).applyMatrix4(GAME.player.matrixWorld);
        const lookOff = new THREE.Vector3(0, 1 + GAME.camPitch*0.2, GAME.isScoped?-50:-20); 
        
        GAME.camera.fov = GAME.isScoped ? 15 : 70;
        GAME.camera.position.lerp(targetPos, 0.15);
        GAME.camera.lookAt(lookOff.applyMatrix4(GAME.player.matrixWorld));
        GAME.camera.updateProjectionMatrix();

        // 4. å†›é˜Ÿ
        GAME.allies.forEach(a => {
            const tX = GAME.player.position.x + Math.cos(a.userData.offsetAngle)*3;
            const tZ = GAME.player.position.z + Math.sin(a.userData.offsetAngle)*3;
            a.position.x += (tX - a.position.x)*0.1;
            a.position.z += (tZ - a.position.z)*0.1;
            // ç®€å•å‘¼å¸åŠ¨ç”»
            a.position.y = 0.6 + Math.sin(now*5 + a.userData.offsetAngle)*0.1;

            if(now - a.userData.lastFire > 1.0) {
                let near = null, minDist = 6;
                GAME.enemies.forEach(e => { const d=a.position.distanceTo(e.position); if(d<minDist){minDist=d; near=e;} });
                if(near) {
                    a.userData.lastFire = now; a.lookAt(near.position);
                    near.userData.hp -= 10;
                    createSparkle(near.position, 0x00aaff, 3);
                }
            }
        });

        // 5. å°„å‡»
        const wp = GAME.weapons[GAME.curIdx];
        if(GAME.inputs.fire && now - wp.lastFire > wp.rate && wp.curAmmo > 0) {
            wp.lastFire = now; wp.curAmmo--; updateUI();
            
            const gunPos = GAME.player.position.clone().add(new THREE.Vector3(0,1,0));
            const origin = GAME.isScoped ? GAME.camera.position.clone() : gunPos;

            if(wp.type === 'rocket') {
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:'red'}));
                b.position.copy(gunPos);
                const dir = new THREE.Vector3(); GAME.camera.getWorldDirection(dir);
                b.userData = { vel: dir.multiplyScalar(30), type: 'rocket' };
                GAME.scene.add(b); GAME.bullets.push(b);
            } else {
                const ray = new THREE.Raycaster();
                ray.setFromCamera(new THREE.Vector2(0,0), GAME.camera);
                const hits = ray.intersectObjects(GAME.enemies, true);
                const endPoint = hits.length ? hits[0].point : ray.ray.at(100, new THREE.Vector3());
                
                createTracer(gunPos, endPoint);
                if(hits.length) {
                    const group = hits[0].object.parent;
                    if(group && group.userData.hp) {
                        group.userData.hp -= wp.dmg;
                        createSparkle(endPoint, 0xffaa00, 8);
                        if(wp.type === 'chain') {
                            GAME.enemies.forEach(e => {
                                if(e!==group && e.position.distanceTo(group.position)<10) {
                                    e.userData.hp -= wp.dmg;
                                    createLightning(group.position, e.position);
                                }
                            });
                        }
                    }
                }
            }
        }

        // 6. æ•Œäººé€»è¾‘
        if(Math.random()<0.015) spawnEnemy();
        GAME.enemies.forEach((e, i) => {
            const dir = new THREE.Vector3().subVectors(GAME.player.position, e.position).normalize();
            e.position.addScaledVector(dir, e.userData.speed*dt);
            // å‡æ…¢æ—‹è½¬é€Ÿåº¦ï¼Œä½¿ç”¨æ’å€¼æ–¹å¼å¹³æ»‘è½¬å‘
            const targetRotation = Math.atan2(
                GAME.player.position.x - e.position.x,
                GAME.player.position.z - e.position.z
            );
            e.rotation.y += (targetRotation - e.rotation.y) * 0.05; // é™ä½æ—‹è½¬é€Ÿåº¦

            const bar = e.userData.bar;
            const screen = e.position.clone().add(new THREE.Vector3(0,2.5,0)).project(GAME.camera);
            if(screen.z < 1) {
                bar.style.display = 'block';
                bar.style.left = ((screen.x * 0.5 + 0.5) * window.innerWidth - 15) + 'px';
                bar.style.top = ((-screen.y * 0.5 + 0.5) * window.innerHeight) + 'px';
                bar.style.width = (e.userData.hp / e.userData.maxHp * 30) + 'px';
            } else bar.style.display = 'none';

            if(e.position.distanceTo(GAME.player.position) < 2.5) {
                GAME.hp -= 0.5; updateUI();
                const overlay = document.getElementById('damage-overlay');
                overlay.style.opacity = 0.5; setTimeout(() => overlay.style.opacity = 0, 100);
                if(GAME.hp <= 0) { alert('é˜²çº¿å¤±å®ˆ!'); location.reload(); }
            }
            if(e.userData.hp <= 0) {
                createExplosion(e.position, 0x00ff00);
                bar.remove(); GAME.scene.remove(e); GAME.enemies.splice(i, 1);
            }
        });

        // 7. ç²’å­æ›´æ–°
        for(let i=GAME.bullets.length-1; i>=0; i--) {
            const b = GAME.bullets[i]; b.position.addScaledVector(b.userData.vel, dt);
            if(b.userData.type==='rocket' && b.position.y < 0) {
                createExplosion(b.position, 0xff5500); 
                GAME.enemies.forEach(e => { if(e.position.distanceTo(b.position)<15) e.userData.hp-=30; });
                GAME.scene.remove(b); GAME.bullets.splice(i,1);
            } else if(b.position.distanceTo(GAME.player.position)>100) {
                GAME.scene.remove(b); GAME.bullets.splice(i,1);
            }
        }
        updateParticles(dt);

        GAME.renderer.render(GAME.scene, GAME.camera);
    }

    // --- ç‰¹æ•ˆ ---
    function createTracer(start, end) {
        const mat = new THREE.LineBasicMaterial({color: 0xffaa00, transparent:true, opacity:0.8});
        const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line); setTimeout(() => GAME.scene.remove(line), 50);
    }
    function createLightning(start, end) {
        const mid = new THREE.Vector3().lerpVectors(start, end, 0.5).add(new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5));
        const mat = new THREE.LineBasicMaterial({color: 0x00ffff});
        const geo = new THREE.BufferGeometry().setFromPoints([start, mid, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line); setTimeout(() => GAME.scene.remove(line), 100);
    }
    function createExplosion(pos, color) {
        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color: color}));
            p.position.copy(pos);
            const vel = new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5).multiplyScalar(10);
            GAME.particles.push({mesh:p, vel:vel, life:1.0}); GAME.scene.add(p);
        }
    }
    function createSparkle(pos, color, count) { createExplosion(pos, color); }
    function updateParticles(dt) {
        for(let i=GAME.particles.length-1; i>=0; i--) {
            const p = GAME.particles[i]; p.life -= dt;
            p.mesh.position.addScaledVector(p.vel, dt); p.vel.y -= 20*dt; p.mesh.scale.setScalar(p.life);
            if(p.life<=0 || p.mesh.position.y<0) { GAME.scene.remove(p.mesh); GAME.particles.splice(i,1); }
        }
    }
    // è™šæ‹Ÿæ‘‡æ†ç±»
    class VirtualJoystick {
        constructor(containerId, callback) {
            this.container = document.getElementById(containerId);
            this.base = this.container.querySelector('.joystick-base');
            this.handle = this.container.querySelector('.joystick-handle');
            this.callback = callback;

            this.active = false;
            this.centerX = 0;
            this.centerY = 0;
            this.maxDistance = 50; // æœ€å¤§ç§»åŠ¨è·ç¦»

            this.init();
        }

        init() {
            // è®¡ç®—ä¸­å¿ƒä½ç½®
            const rect = this.base.getBoundingClientRect();
            this.centerX = rect.left + rect.width / 2;
            this.centerY = rect.top + rect.height / 2;

            // è§¦æ‘¸äº‹ä»¶
            this.container.addEventListener('touchstart', this.start.bind(this));
            this.container.addEventListener('touchmove', this.move.bind(this));
            this.container.addEventListener('touchend', this.end.bind(this));
            this.container.addEventListener('touchcancel', this.end.bind(this));

            // é¼ æ ‡äº‹ä»¶ï¼ˆç”¨äºè°ƒè¯•ï¼‰
            this.container.addEventListener('mousedown', this.start.bind(this));
            document.addEventListener('mousemove', this.move.bind(this));
            document.addEventListener('mouseup', this.end.bind(this));
        }

        start(e) {
            e.preventDefault();
            this.active = true;
            this.updatePosition(e);
        }

        move(e) {
            if (!this.active) return;
            e.preventDefault();
            this.updatePosition(e);
        }

        end(e) {
            if (!this.active) return;
            e.preventDefault();
            this.active = false;

            // å›åˆ°ä¸­å¿ƒä½ç½®
            this.handle.style.transform = 'translate(-50%, -50%)';

            // é‡ç½®è¾“å…¥
            if (this.callback) {
                this.callback(0, 0);
            }
        }

        updatePosition(e) {
            const touch = e.touches && e.touches[0] ? e.touches[0] : e;
            const x = touch.clientX - this.centerX;
            const y = touch.clientY - this.centerY;

            // è®¡ç®—è·ç¦»å’Œè§’åº¦
            const distance = Math.min(Math.sqrt(x * x + y * y), this.maxDistance);
            const angle = Math.atan2(y, x);

            // è®¡ç®—å½’ä¸€åŒ–å€¼ (-1 åˆ° 1)
            const normalizedX = Math.min(Math.max(x / this.maxDistance, -1), 1);
            const normalizedY = Math.min(Math.max(y / this.maxDistance, -1), 1);

            // é™åˆ¶åœ¨æœ€å¤§è·ç¦»å†…
            const clampedX = Math.cos(angle) * distance;
            const clampedY = Math.sin(angle) * distance;

            // æ›´æ–°æ‰‹æŸ„ä½ç½®
            this.handle.style.transform = `translate(calc(-50% + ${clampedX}px), calc(-50% + ${clampedY}px))`;

            // è°ƒç”¨å›è°ƒå‡½æ•°
            if (this.callback) {
                this.callback(normalizedX, normalizedY);
            }
        }
    }

    // åˆå§‹åŒ–æ‘‡æ†
    let movementJoystick;
    let rotationJoystick;

    function initJoysticks() {
        // å·¦ä¾§ç§»åŠ¨æ‘‡æ†
        movementJoystick = new VirtualJoystick('joystick-left', (x, y) => {
            // å°†æ‘‡æ†è¾“å…¥æ˜ å°„åˆ°WASD
            GAME.inputs.w = y < -0.3;
            GAME.inputs.s = y > 0.3;
            GAME.inputs.a = x < -0.3;
            GAME.inputs.d = x > 0.3;
        });

        // å³ä¾§è§†è§’æ‘‡æ†
        rotationJoystick = new VirtualJoystick('joystick-right', (x, y) => {
            // å°†æ‘‡æ†è¾“å…¥æ˜ å°„åˆ°è§†è§’æ§åˆ¶
            GAME.inputs.left = x < -0.3;
            GAME.inputs.right = x > 0.3;
            GAME.inputs.up = y < -0.3;
            GAME.inputs.down = y > 0.3;
        });
    }

    function updateUI() {
        const w = GAME.weapons[GAME.curIdx];
        document.getElementById('ui-wp').innerText = w.name;
        document.getElementById('ui-ammo').innerText = w.curAmmo + '/' + w.mag;
        document.getElementById('ui-hp').innerText = Math.floor(GAME.hp);
        document.getElementById('btn-scope').style.display = w.sniper ? 'flex':'none';
        document.getElementById('btn-scope').style.background = GAME.isScoped?'rgba(0,255,255,0.8)':'rgba(0,255,255,0.2)';
    }

    window.addEventListener('resize', () => {
        GAME.camera.aspect = window.innerWidth / window.innerHeight;
        GAME.camera.updateProjectionMatrix();
        GAME.renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>