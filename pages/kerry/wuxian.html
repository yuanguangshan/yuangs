<!DOCTYPE html><html lang="zh"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ— é™åœ°å›¾æŠ½å¡æ¸¸æˆ</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        /* éŸ³æ•ˆæ§åˆ¶æŒ‰é’®æ ·å¼ */
        #soundToggle {
            position: absolute;
            top: 20px;
            left: 200px;
            width: 50px;
            height: 50px;
            background-color: rgba(100, 200, 100, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        #soundToggle:hover {
            transform: scale(1.1);
        }
        #soundToggle.muted {
            background-color: rgba(200, 100, 100, 0.7);
        }
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            background-color: #f0f0f0;
            overflow: hidden;
        }
        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background-color: #e0e0e0;
        }
        .ui-button {
            position: absolute;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 36px;
            font-weight: bold;
            user-select: none;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            touch-action: manipulation;
        }
        /* è°ƒæ•´æŒ‰é’®ä½ç½®ï¼Œç¡®ä¿å®ƒä»¬åœ¨iPadä¸Šå¯è§ */
        @media (min-width: 768px) { /* Apply original styles for iPad and desktop */
            .ui-button {
                width: 80px;
                height: 80px;
                font-size: 36px;
            }
            #upButton {
                bottom: 220px;
                left: 100px;
            }
            #leftButton {
                bottom: 140px;
                left: 20px;
            }
            #downButton {
                bottom: 60px;
                left: 100px;
            }
            #rightButton {
                bottom: 140px;
                left: 180px;
            }
            #attackButton {
                bottom: 140px;
                right: 60px; /* ç§»åŠ¨åˆ°å³è¾¹ */
                width: 120px;
                height: 120px;
                font-size: 28px;
            }
            #joystickContainer {
                position: absolute;
                width: 200px;
                height: 200px;
                top: auto;
                left: auto;
                transform: none;
                z-index: 20;
            }
            #outerCircle {
                width: 180px;
                height: 180px;
                left: 10px;
                top: 10px;
            }
            #middleCircle {
                width: 120px;
                height: 120px;
                left: 40px;
                top: 40px;
            }
            #innerCircle {
                width: 60px;
                height: 60px;
                left: 70px;
                top: 70px;
            }
            #shopButton, #cardSlotButton, #helpButton {
                width: 80px;
                height: 80px;
                font-size: 24px;
            }
            #shopButton {
                top: 20px;
                right: 20px;
            }
            #cardSlotButton {
                top: 20px;
                right: 110px;
            }
            #helpButton {
                top: 20px;
                right: 200px;
            }
            #statsContainer {
                top: 20px;
                left: 20px;
                font-size: 24px;
                padding: 15px;
            }
        }

        /* Mobile-specific styles */
        @media (max-width: 767px) {
            .ui-button {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
            #upButton {
                bottom: 140px;
                left: 70px;
            }
            #leftButton {
                bottom: 80px;
                left: 10px;
            }
            #downButton {
                bottom: 20px;
                left: 70px;
            }
            #rightButton {
                bottom: 80px;
                left: 130px;
            }
            #attackButton {
                bottom: 60px;
                right: 20px; /* ç§»åŠ¨åˆ°å³è¾¹ */
                width: 90px;
                height: 90px;
                font-size: 20px;
            }
            #joystickContainer {
                position: absolute;
                width: 150px;
                height: 150px;
                top: auto;
                left: auto; 
                transform: none;
                z-index: 20;
            }
            #outerCircle {
                width: 140px;
                height: 140px;
                left: 5px;
                top: 5px;
            }
            #middleCircle {
                width: 90px;
                height: 90px;
                left: 30px;
                top: 30px;
            }
            #innerCircle {
                width: 40px;
                height: 40px;
                left: 55px;
                top: 55px;
            }
            #shopButton, #cardSlotButton, #helpButton {
                width: 60px;
                height: 60px;
                font-size: 20px;
            }
            #shopButton {
                top: 10px;
                right: 10px;
            }
            #cardSlotButton {
                top: 10px;
                right: 80px;
            }
            #helpButton {
                top: 10px;
                right: 150px;
            }
            #statsContainer {
                font-size: 18px;
                padding: 10px;
                top: 10px;
                left: 10px;
            }
        }
        .circle {
            position: absolute;
            border-radius: 50%;
            background-color: rgba(255, 255, 255, 0.5);
        }
        #outerCircle {
            width: 180px;
            height: 180px;
            left: 10px;
            top: 10px;
            border: 2px solid rgba(100, 100, 100, 0.5);
        }
        #middleCircle {
            width: 120px;
            height: 120px;
            left: 40px;
            top: 40px;
            background-color: rgba(100, 100, 255, 0.5);
            cursor: pointer;
        }
        #innerCircle {
            width: 60px;
            height: 60px;
            left: 70px;
            top: 70px;
            background-color: rgba(200, 200, 255, 0.8);
        }
        #shopButton {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            background-color: rgba(255, 200, 100, 0.7);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #cardSlotButton {
            position: absolute;
            top: 20px;
            right: 110px;
            width: 80px;
            height: 80px;
            background-color: rgba(100, 200, 255, 0.7);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            font-weight: bold;
            z-index: 10;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        /* æ·»åŠ é—®å·æŒ‰é’®æ ·å¼ */
        #helpButton {
            position: absolute;
            top: 20px;
            right: 200px;
            width: 80px;
            height: 80px;
            background-color: rgba(120, 220, 120, 0.7);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            font-weight: bold;
            z-index: 10;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        #statsContainer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 24px;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: white;
            width: 90%;
            max-width: 800px;
            border-radius: 15px;
            padding: 30px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }
        .modal-header h2 {
            font-size: 32px;
            margin: 0;
        }
        .close-button {
            font-size: 36px;
            cursor: pointer;
            padding: 10px;
        }
        .card {
            width: 160px;
            height: 240px;
            background-color: #f0f0f0;
            border-radius: 15px;
            border: 3px solid #aaa;
            margin: 15px;
            display: inline-flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            box-sizing: border-box;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        .card-title {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }
        .card-image {
            width: 100px;
            height: 100px;
            background-color: #ddd;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        .card-description {
            font-size: 16px;
            text-align: center;
        }
        .card-slot-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 30px;
        }
        .card-slot {
            width: 120px;
            height: 180px;
            background-color: #e0e0e0;
            border-radius: 12px;
            border: 3px dashed #aaa;
            margin: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            color: #999;
        }
        .card-slot.filled {
            border: 3px solid #5a5;
            background-color: #efe;
        }
        .card-preview {
            width: 110px;
            height: 170px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            box-sizing: border-box;
            background-color: white;
        }
        .card-preview-title {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
        }
        .card-preview-image {
            width: 60px;
            height: 60px;
            background-color: #ddd;
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
        }
        .shop-section {
            text-align: center;
            margin-bottom: 30px;
        }
        .shop-section #shopCoinsDisplay {
            font-size: 28px;
            margin-bottom: 20px;
        }
        .buy-button {
            background-color: #5a5;
            color: white;
            border: none;
            border-radius: 10px;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .buy-button:hover {
            background-color: #494;
        }
        .shop-card-price {
            margin-top: 15px;
            font-weight: bold;
            font-size: 24px;
        }
        .slot-section-title {
            text-align: center;
            font-weight: bold;
            margin: 20px 0;
            padding: 10px;
            background-color: #eee;
            border-radius: 10px;
            font-size: 24px;
        }
        /* æ¸¸æˆè¯´æ˜æ ·å¼ */
        .help-section {
            margin-bottom: 20px;
        }
        .help-section h3 {
            margin-top: 25px;
            margin-bottom: 10px;
            color: #333;
            border-bottom: 2px solid #eee;
            padding-bottom: 5px;
        }
        .help-section p {
            margin: 10px 0;
            line-height: 1.5;
            font-size: 18px;
        }
        .help-section ul {
            margin: 10px 0;
            padding-left: 25px;
        }
        .help-section li {
            margin: 8px 0;
            line-height: 1.4;
            font-size: 16px;
        }
        .help-section .card-types {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            margin: 15px 0;
        }
        .help-section .card-type {
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 8px;
            margin: 5px;
            width: 30%;
            min-width: 200px;
        }
        /* è¡€æ¡æ ·å¼ */
        .health-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            overflow: hidden;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        /* Bossè¡€æ¡æ ·å¼ */
        .boss-health-bar {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 25px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            overflow: hidden;
            z-index: 15;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            display: none;
        }
        
        .boss-health-fill {
            height: 100%;
            background: linear-gradient(90deg, #8B0000, #DC143C);
            border-radius: 12px;
            transition: width 0.3s ease;
        }
        
        .boss-health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .boss-health-label {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff4444;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            display: none;
            z-index: 15;
        }
        
        /* Buffå›¾æ ‡æ ·å¼ */
        .buff-icons {
            position: absolute;
            top: 100px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 15;
        }
        
        .buff-icon {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            position: relative;
        }
        
        .buff-icon::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }
        
        .buff-icon:hover::after {
            opacity: 1;
        }
        
        /* ä¸ºiPadæ·»åŠ çš„é¢å¤–æ ·å¼ */
        @media (min-width: 768px) and (max-width: 1024px) {
            .ui-button {
                width: 100px;
                height: 100px;
                font-size: 48px;
            }
            #upButton {
                bottom: 280px;
                left: 120px;
            }
            #leftButton {
                bottom: 180px;
                left: 20px;
            }
            #downButton {
                bottom: 80px;
                left: 120px;
            }
            #rightButton {
                bottom: 180px;
                left: 220px;
            }
            #attackButton {
                bottom: 180px;
                right: 80px; /* ç§»åŠ¨åˆ°å³è¾¹ */
                width: 150px;
                height: 150px;
                font-size: 36px;
            }
            #joystickContainer {
                position: absolute;
                width: 250px;
                height: 250px;
                top: auto;
                left: auto;
                z-index: 20;
            }
            #outerCircle {
                width: 230px;
                height: 230px;
            }
            #middleCircle {
                width: 160px;
                height: 160px;
                left: 45px;
                top: 45px;
            }
            #innerCircle {
                width: 80px;
                height: 80px;
                left: 85px;
                top: 85px;
            }
            #statsContainer {
                font-size: 32px;
                padding: 20px;
            }
            #helpButton {
                width: 100px;
                height: 100px;
                font-size: 50px;
                right: 220px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="statsContainer">
            <div id="healthDisplay">è¡€é‡: 100</div>
            <div id="coinsDisplay">é“œæ¿: 0</div>
        </div>
        
        <div id="shopButton"><i class="fas fa-store"></i></div>
        <div id="cardSlotButton"><i class="fas fa-id-card"></i></div> <!-- Changed icon for better representation -->
        <div id="helpButton"><i class="fas fa-question"></i></div>
        
        <!-- Controls are re-arranged: Movement on left, Actions on right -->
        <div class="ui-button" id="upButton">â†‘</div>
        <div class="ui-button" id="leftButton">â†</div>
        <div class="ui-button" id="downButton">â†“</div>
        <div class="ui-button" id="rightButton">â†’</div>
        <div class="ui-button" id="attackButton">æ”»å‡»</div>
        
        <div id="joystickContainer">
            <div class="circle" id="outerCircle"></div>
            <div class="circle" id="middleCircle"></div>
            <div class="circle" id="innerCircle"></div>
        </div>
    </div>
    
    <!-- éŸ³æ•ˆæ§åˆ¶æŒ‰é’® -->
    <div id="soundToggle">ğŸ”Š</div>
    
    <div class="modal" id="shopModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>å•†åº—</h2>
                <span class="close-button" id="closeShop">Ã—</span>
            </div>
            <div class="shop-section">
                <div id="shopCoinsDisplay">å½“å‰é“œæ¿: 0</div>
                <div class="card">
                    <div class="card-title">å¡åŒ…</div>
                    <div class="card-image">å¡åŒ…</div>
                    <div class="card-description">éšæœºè·å¾—ä¸€å¼ å¡ç‰Œ</div>
                </div>
                <div class="shop-card-price">ä»·æ ¼: 50 é“œæ¿</div>
                <button class="buy-button" id="buyCardButton">è´­ä¹°</button>
            </div>
        </div>
    </div>
    
    <div class="modal" id="cardSlotModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>å¡æ§½</h2>
                <span class="close-button" id="closeCardSlot">Ã—</span>
            </div>
            
            <div class="slot-section-title">æªæ¢°å¡æ§½</div>
            <div class="card-slot-container" id="gunCardSlots">
                <div class="card-slot" data-slot="0" data-type="gun">ç©ºæ§½</div>
                <div class="card-slot" data-slot="1" data-type="gun">ç©ºæ§½</div>
                <div class="card-slot" data-slot="2" data-type="gun">ç©ºæ§½</div>
            </div>
            
            <div class="slot-section-title">æŠ€èƒ½å¡æ§½</div>
            <div class="card-slot-container" id="skillCardSlots">
                <div class="card-slot" data-slot="0" data-type="skill">ç©ºæ§½</div>
                <div class="card-slot" data-slot="1" data-type="skill">ç©ºæ§½</div>
                <div class="card-slot" data-slot="2" data-type="skill">ç©ºæ§½</div>
                <div class="card-slot" data-slot="3" data-type="skill">ç©ºæ§½</div>
                <div class="card-slot" data-slot="4" data-type="skill">ç©ºæ§½</div>
                <div class="card-slot" data-slot="5" data-type="skill">ç©ºæ§½</div>
                <div class="card-slot" data-slot="6" data-type="skill">ç©ºæ§½</div>
                <div class="card-slot" data-slot="7" data-type="skill">ç©ºæ§½</div>
            </div>
            
            <div class="slot-section-title">é“å…·å¡æ§½</div>
            <div class="card-slot-container" id="itemCardSlots">
                <div class="card-slot" data-slot="0" data-type="item">ç©ºæ§½</div>
                <div class="card-slot" data-slot="1" data-type="item">ç©ºæ§½</div>
                <div class="card-slot" data-slot="2" data-type="item">ç©ºæ§½</div>
                <div class="card-slot" data-slot="3" data-type="item">ç©ºæ§½</div>
            </div>
        </div>
    </div>
    
    <!-- æ·»åŠ æ¸¸æˆè¯´æ˜æ¨¡æ€æ¡† -->
    <div class="modal" id="helpModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>æ¸¸æˆè¯´æ˜</h2>
                <span class="close-button" id="closeHelp">Ã—</span>
            </div>
            <div class="help-section">
                <h3>æ¸¸æˆç›®æ ‡</h3>
                <p>åœ¨è¿™ä¸ªæ— é™åœ°å›¾ä¸­æ¢ç´¢ï¼Œæ”¶é›†é“œæ¿ï¼Œå‡»è´¥æ•Œäººå’ŒBossï¼Œè·å–å„ç§å¼ºåŠ›å¡ç‰Œæ¥å¢å¼ºä½ çš„è§’è‰²ã€‚</p>
                
                <h3>åŸºæœ¬æ“ä½œ</h3>
                <ul>
                    <li><strong>ç§»åŠ¨ï¼š</strong>ä½¿ç”¨æ–¹å‘é”®ï¼ˆâ†‘â†â†“â†’ï¼‰æˆ–æ‘‡æ†ç§»åŠ¨è§’è‰²</li>
                    <li><strong>æ”»å‡»ï¼š</strong>ç‚¹å‡»æ”»å‡»æŒ‰é’®å‘å°„å­å¼¹</li>
                    <li><strong>å•†åº—ï¼š</strong>ç‚¹å‡»å³ä¸Šè§’"å•†åº—"æŒ‰é’®è´­ä¹°å¡åŒ…</li>
                    <li><strong>å¡æ§½ï¼š</strong>ç‚¹å‡»å³ä¸Šè§’"å¡æ§½"æŒ‰é’®ç®¡ç†å’Œæ¿€æ´»ä½ çš„å¡ç‰Œ</li>
                </ul>
                
                <h3>åœ°å›¾å…ƒç´ </h3>
                <ul>
                    <li><strong>æ™®é€šæ ¼å­ï¼š</strong>ç°è‰²æ ¼å­ï¼Œæ²¡æœ‰ç‰¹æ®Šæ•ˆæœ</li>
                    <li><strong>å®ç®±æ ¼å­ï¼š</strong>é‡‘è‰²æ ¼å­ï¼Œè¸©ä¸Šå»å¯è·å¾—100é“œæ¿</li>
                    <li><strong>ç®±å­æ ¼å­ï¼š</strong>æ£•è‰²æ ¼å­ï¼Œè¸©ä¸Šå»å¯è·å¾—5ç§’æŠ¤ç›¾ä¿æŠ¤</li>
                    <li><strong>æ•Œäººï¼š</strong>çº¢è‰²å°åœ†åœˆï¼Œç¢°åˆ°ä¼šå‡å°‘è¡€é‡</li>
                    <li><strong>Bossï¼š</strong>æ·±çº¢è‰²å¤§åœ†åœˆï¼Œè¡€é‡æ›´é«˜ï¼Œç¢°åˆ°ä¼šå‡å°‘æ›´å¤šè¡€é‡</li>
                </ul>
                
                <h3>å¡ç‰Œç³»ç»Ÿ</h3>
                <p>æ¸¸æˆæœ‰ä¸‰ç§ç±»å‹çš„å¡ç‰Œï¼š</p>
                
                <div class="card-types">
                    <div class="card-type">
                        <h4>æªæ¢°å¡ç‰Œ</h4>
                        <p>æ›´æ¢ä½ çš„æ­¦å™¨ï¼Œæä¾›ä¸åŒçš„æ”»å‡»æ–¹å¼å’Œæ•ˆæœã€‚</p>
                        <ul>
                            <li>ç«ç„°æªï¼šä¼¤å®³ä¸º2</li>
                            <li>å¯’å†°æªï¼šå¯å†»ç»“æ•Œäºº10ç§’</li>
                            <li>æ¯’è¯æªï¼šä¼¤å®³ä¸º3</li>
                            <li>å„ç§åŒå€æªï¼šå‘å°„ä¸¤é¢—å­å¼¹</li>
                        </ul>
                    </div>
                    
                    <div class="card-type">
                        <h4>æŠ€èƒ½å¡ç‰Œ</h4>
                        <p>è‡ªåŠ¨æ–½æ”¾çš„ç‰¹æ®ŠæŠ€èƒ½ï¼Œå¸®åŠ©ä½ æ”»å‡»æ•Œäººã€‚</p>
                        <ul>
                            <li>ä¹¾å¤åœˆï¼šç”Ÿæˆå…­ä¸ªå›´ç»•ä½ è½¬åŠ¨çš„åœˆ</li>
                            <li>æ··å¤©å‡Œï¼šåœ¨å±å¹•ä¸­é£æ¥é£å»</li>
                            <li>ç«å°–æªï¼šå®šæœŸä»ä½ èº«åå‘å°„</li>
                            <li>æ›´å¤šå¼ºåŠ›æŠ€èƒ½ç­‰ä½ å‘ç°...</li>
                        </ul>
                    </div>
                    
                    <div class="card-type">
                        <h4>é“å…·å¡ç‰Œ</h4>
                        <p>æä¾›å„ç§è¢«åŠ¨å¢ç›Šæ•ˆæœã€‚</p>
                        <ul>
                            <li>è¿å‘ï¼šé•¿æŒ‰æ”»å‡»æŒ‰é’®å¯è¿ç»­å‘å°„</li>
                            <li>æ”»å‡»åŠ›æå‡ï¼šå¢åŠ å­å¼¹ä¼¤å®³</li>
                            <li>å¢åŠ è¡€é‡ï¼šæ¯3ç§’æ¢å¤1ç‚¹è¡€é‡</li>
                            <li>å†°å†»æå‡ï¼šç»™å­å¼¹å¢åŠ å†°å†»æ•ˆæœ</li>
                        </ul>
                    </div>
                </div>
                
                <h3>æ¸¸æˆæç¤º</h3>
                <ul>
                    <li>å°½å¯èƒ½æ”¶é›†é“œæ¿è´­ä¹°å¡åŒ…</li>
                    <li>ä¼˜å…ˆä½¿ç”¨èƒ½æé«˜ç”Ÿå­˜èƒ½åŠ›çš„é“å…·å’ŒæŠ€èƒ½</li>
                    <li>é¢å¯¹Bossæ—¶ä¿æŒè·ç¦»ï¼Œåˆ©ç”¨å†°å†»æ•ˆæœå‡ç¼“å…¶ç§»åŠ¨</li>
                    <li>åœ°å›¾æ˜¯æ— é™çš„ï¼Œå¯ä»¥ä¸æ–­æ¢ç´¢æ–°åŒºåŸŸ</li>
                    <li>å–„ç”¨æŠ¤ç›¾æ•ˆæœæŠµæŒ¡ä¼¤å®³</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // éŸ³æ•ˆç®¡ç†å™¨
        const SoundManager = {
            context: null,
            sounds: {},
            muted: false,
            volume: 0.5,
            
            init() {
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            },
            
            createSounds() {
                // åˆ›å»ºå„ç§éŸ³æ•ˆ
                this.sounds.background = this.createTone(440, 0.1, 0.3, 'sine');
                this.sounds.shoot = this.createTone(800, 0.05, 0.2, 'square');
                this.sounds.hit = this.createTone(600, 0.1, 0.3, 'sawtooth');
                this.sounds.enemyDeath = this.createTone(300, 0.2, 0.4, 'sawtooth');
                this.sounds.coin = this.createTone(1000, 0.1, 0.2, 'sine');
                this.sounds.levelUp = this.createTone(1200, 0.3, 0.5, 'sine');
                this.sounds.damage = this.createTone(200, 0.1, 0.3, 'square');
                this.sounds.shield = this.createTone(500, 0.2, 0.3, 'sine');
            },
            
            createTone(frequency, attack, decay, waveType) {
                return () => {
                    if (this.muted || !this.context) return;
                    
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.type = waveType;
                    oscillator.frequency.setValueAtTime(frequency, this.context.currentTime);
                    
                    gainNode.gain.setValueAtTime(0, this.context.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.volume, this.context.currentTime + attack);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + decay);
                    
                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + decay);
                };
            },
            
            play(soundName) {
                if (this.sounds[soundName]) {
                    this.sounds[soundName]();
                }
            },
            
            toggleMute() {
                this.muted = !this.muted;
                const soundToggle = document.getElementById('soundToggle');
                if (this.muted) {
                    soundToggle.textContent = 'ğŸ”‡';
                    soundToggle.classList.add('muted');
                } else {
                    soundToggle.textContent = 'ğŸ”Š';
                    soundToggle.classList.remove('muted');
                }
            }
        };
        
        // æ·»åŠ éŸ³æ•ˆæ§åˆ¶äº‹ä»¶
        document.addEventListener('DOMContentLoaded', () => {
            const soundToggle = document.getElementById('soundToggle');
            soundToggle.addEventListener('click', () => {
                SoundManager.toggleMute();
            });
        });
    
        // æ¸¸æˆä¸»è¦å¯¹è±¡
        // è§†è§‰ç‰¹æ•ˆç®¡ç†å™¨
        const EffectsManager = {
            particles: [],
            damageNumbers: [],
            screenEffects: [],
            
            // åˆ›å»ºç²’å­æ•ˆæœ
            createParticle(x, y, color, size, velocityX, velocityY, lifetime = 1000) {
                this.particles.push({
                    x, y, color, size,
                    velocityX, velocityY,
                    lifetime, maxLifetime: lifetime,
                    alpha: 1
                });
            },
            
            // åˆ›å»ºå‘½ä¸­åé¦ˆ
            createHitEffect(x, y, color = 'yellow') {
                // åˆ›å»ºé—ªçƒæ•ˆæœ
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const speed = 2 + Math.random() * 2;
                    this.createParticle(
                        x, y,
                        color,
                        3 + Math.random() * 3,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        500
                    );
                }
            },
            
            // åˆ›å»ºæ­»äº¡ç‰¹æ•ˆ
            createDeathEffect(x, y, color = 'red') {
                // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const speed = 3 + Math.random() * 4;
                    this.createParticle(
                        x, y,
                        color,
                        4 + Math.random() * 4,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        800
                    );
                }
                // æ·»åŠ ä¸€äº›é‡‘è‰²ç²’å­è¡¨ç¤ºå¥–åŠ±
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const speed = 2 + Math.random() * 2;
                    this.createParticle(
                        x, y,
                        'gold',
                        3 + Math.random() * 2,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed,
                        1000
                    );
                }
            },
            
            // åˆ›å»ºæ‹¾å–åŠ¨ç”»
            createPickupEffect(x, y, text, color = 'gold') {
                this.damageNumbers.push({
                    x, y,
                    text: '+' + text,
                    color,
                    velocityY: -2,
                    alpha: 1,
                    lifetime: 1500,
                    size: 16
                });
            },
            
            // åˆ›å»ºä¼¤å®³æ•°å­—
            createDamageNumber(x, y, damage, color = 'white') {
                this.damageNumbers.push({
                    x, y,
                    text: '-' + damage,
                    color,
                    velocityY: -1,
                    alpha: 1,
                    lifetime: 1000,
                    size: 14
                });
            },
            
            // åˆ›å»ºå±å¹•é—ªçƒæ•ˆæœ
            createScreenFlash(color = 'red', duration = 200) {
                this.screenEffects.push({
                    color,
                    alpha: 0.3,
                    duration,
                    maxDuration: duration
                });
            },
            
            // æ›´æ–°æ‰€æœ‰ç‰¹æ•ˆ
            update(deltaTime) {
                // æ›´æ–°ç²’å­
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.velocityX;
                    particle.y += particle.velocityY;
                    particle.lifetime -= deltaTime;
                    particle.alpha = particle.lifetime / particle.maxLifetime;
                    
                    if (particle.lifetime <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // æ›´æ–°ä¼¤å®³æ•°å­—
                for (let i = this.damageNumbers.length - 1; i >= 0; i--) {
                    const number = this.damageNumbers[i];
                    number.y += number.velocityY;
                    number.lifetime -= deltaTime;
                    number.alpha = number.lifetime / 1000;
                    
                    if (number.lifetime <= 0) {
                        this.damageNumbers.splice(i, 1);
                    }
                }
                
                // æ›´æ–°å±å¹•æ•ˆæœ
                for (let i = this.screenEffects.length - 1; i >= 0; i--) {
                    const effect = this.screenEffects[i];
                    effect.duration -= deltaTime;
                    effect.alpha = (effect.duration / effect.maxDuration) * 0.3;
                    
                    if (effect.duration <= 0) {
                        this.screenEffects.splice(i, 1);
                    }
                }
            },
            
            // ç»˜åˆ¶æ‰€æœ‰ç‰¹æ•ˆ
            draw(ctx) {
                // ç»˜åˆ¶å±å¹•æ•ˆæœ
                for (const effect of this.screenEffects) {
                    ctx.fillStyle = effect.color;
                    ctx.globalAlpha = effect.alpha;
                    ctx.fillRect(0, 0, game.width, game.height);
                    ctx.globalAlpha = 1;
                }
                
                // ç»˜åˆ¶ç²’å­
                for (const particle of this.particles) {
                    ctx.save();
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
                
                // ç»˜åˆ¶ä¼¤å®³æ•°å­—
                for (const number of this.damageNumbers) {
                    ctx.save();
                    ctx.globalAlpha = number.alpha;
                    ctx.fillStyle = number.color;
                    ctx.font = `bold ${number.size}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.fillText(number.text, number.x, number.y);
                    ctx.restore();
                }
            }
        };

        // æ¸¸æˆä¸»è¦å¯¹è±¡
        const game = {
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            gridSize: 40,
            gridCols: 30,
            gridRows: 15,
            grid: [],
            removedCols: { left: [], right: [] },
            removedRows: { top: [], bottom: [] },
            // ç”¨äºè·Ÿè¸ªç§»å‡ºå±å¹•çš„æ•Œäººå’ŒBoss
            offscreenEnemies: [],
            offscreenBosses: [],
            player: {
                x: 0,
                y: 0,
                radius: 20,
                color: 'blue',
                health: 100, // å¢åŠ é»˜è®¤è¡€é‡åˆ°30
                maxHealth: 1000, // å¢åŠ æœ€å¤§è¡€é‡åˆ°30
                direction: 90, // æ–¹å‘ï¼ˆåº¦æ•°ï¼‰
                shield: {
                    active: false,
                    duration: 0
                },
                coins: 0,
                gun: {
                    type: 'normal',
                    color: 'grey',
                    damage: 1,
                    bulletCount: 1,
                    bulletSpeed: 7,
                    frozen: false,
                    poison: false
                }
            },
            enemies: [],
            bosses: [],
            bullets: [],
            skills: [],
            lastEnemySpawn: 0,
            lastBossSpawn: 0,
            enemySpawnRate: 500, // æ¯«ç§’
            bossSpawnRate: 500000, // æ¯«ç§’
            keys: {
                w: false,
                a: false,
                s: false,
                d: false,
                space: false,
                ArrowUp: false,
                ArrowDown: false,
                ArrowLeft: false,
                ArrowRight: false
            },
            joystick: {
                active: false,
                angle: 0
            },
            paused: false,
            gameTime: 0,
            cards: {
                guns: [
                    { id: 'fire', name: 'ç«ç„°æª', description: 'å‘å°„ç«ç„°å­å¼¹ï¼Œä¼¤å®³ä¸º2', color: 'red', damage: 2, bulletCount: 1, frozen: false, poison: false, shape: 'flame' },
                    { id: 'bingdong', name: 'å¯’å†°æª', description: 'å‘å°„å¯’å†°å­å¼¹ï¼Œå¯å†»ç»“æ•Œäºº10ç§’', color: 'blue', damage: 1, bulletCount: 1, frozen: true, poison: false, shape: 'snowflake' },
                    { id: 'doubleFire', name: 'åŒå€ç«ç„°æª', description: 'å‘å°„ä¸¤ä¸ªç«ç„°å­å¼¹ï¼Œæ¯ä¸ªä¼¤å®³ä¸º2', color: 'red', damage: 2, bulletCount: 2, frozen: false, poison: false, shape: 'doubleFlame' },
                    { id: 'doubleIce', name: 'åŒå€å¯’å†°æª', description: 'å‘å°„ä¸¤ä¸ªå¯’å†°å­å¼¹ï¼Œå¯å†»ç»“æ•Œäºº10ç§’', color: 'blue', damage: 1, bulletCount: 2, frozen: true, poison: false, shape: 'doubleSnowflake' },
                    { id: 'poison', name: 'æ¯’è¯æª', description: 'å‘å°„æ¯’è¯å­å¼¹ï¼Œä¼¤å®³ä¸º3', color: 'purple', damage: 3, bulletCount: 1, frozen: false, poison: true, shape: 'skull' }
                ],
                skills: [
                    { id: 'qiankun', name: 'ä¹¾å¤åœˆ', description: 'ç”Ÿæˆå…­ä¸ªä¹¾å¤åœˆåœ¨ç©å®¶å››å‘¨è½¬åŠ¨', shape: 'ring' },
                    { id: 'huntian', name: 'æ··å¤©å‡Œ', description: 'åœ¨å±å¹•ä¸­é£æ¥é£å»ï¼Œä¼¤å®³ä¸º3', shape: 'ribbon' },
                    { id: 'huojianqiang', name: 'ç«å°–æª', description: 'åœ¨ç©å®¶èƒŒåï¼Œæ¯éš”0.5ç§’å‘å°„ï¼Œä¼¤å®³ä¸º3', shape: 'spear' },
                    { id: 'fenghuolun', name: 'é£ç«è½®', description: 'åœ¨åœ°é¢ä¸Šç•™ä¸‹ç«ç„°ç—•è¿¹ï¼Œä¼¤å®³ä¸º3', shape: 'wheel' },
                    { id: 'jiulong', name: 'ä¹é¾™ç›–ç«ç½©', description: 'æ¯éš”50ç§’å‡ºç°ä¸€æ¬¡ï¼Œä¼¤å®³ä¸º40', shape: 'dragon' },
                    { id: 'bagua', name: 'å…«å¦é˜µå®å‰‘', description: 'å‘å››é¢å…«æ–¹å‘å°„å…«å¦é˜µï¼Œä¼¤å®³ä¸º5', shape: 'sword' },
                    { id: 'huangjin', name: 'é‡‘ç –', description: 'éšæœºæ–¹å‘å‘å°„é‡‘ç –ï¼Œä¼¤å®³ä¸º5', shape: 'brick' },
                    { id: 'jianyu', name: 'ç®­é›¨', description: 'æœéšæœºæ–¹å‘å‘å°„50æ”¯ç®­ï¼Œä¼¤å®³ä¸º2', shape: 'arrow' }
                ],
                items: [
                    { id: 'lianshe', name: 'è¿å‘', description: 'é•¿æŒ‰æ”»å‡»æŒ‰é”®å¯ä»¥è¿ç»­å‘å°„å­å¼¹', color: 'orange', shape: 'lightning' },
                    { id: 'gongjili', name: 'æ”»å‡»åŠ›æå‡', description: 'æ¯ä¸€æ¬¡å‘å°„å­å¼¹çš„æ”»å‡»åŠ›å¢åŠ 2', color: 'red', shape: 'sword' },
                    { id: 'heal', name: 'å¢åŠ è¡€é‡', description: 'æ¯3ç§’+1è¡€', color: 'green', shape: 'heart' },
                    { id: 'bingdong', name: 'å†°å†»æå‡', description: 'ç»™å­å¼¹å¢åŠ å†°å†»ç‰¹æ•ˆï¼Œå¯å†°å†»10ç§’', color: 'cyan', shape: 'snowflake' }
                ]
            },
            cardSlots: {
                guns: [null, null, null],
                skills: [null, null, null, null, null, null, null, null],
                items: [null, null, null, null]
            },
            activeEffects: {
                rapidFire: false,
                damageBoost: false,
                healing: false,
                freezeBoost: false
            },
            lastActiveSkillTimes: {},
            // ç”¨äºè·Ÿè¸ªåœ°å›¾ç§»åŠ¨çš„æ–¹å‘å’Œè·ç¦»
            mapMovement: {
                dx: 0,
                dy: 0
            },
            // æ˜¯å¦æ˜¯iPad
            isIPad: false,
            // æ¸¸æˆéš¾åº¦è°ƒæ•´
            difficultySettings: {
                enemyDamage: 1,
                bossDamage: 2,
                bossHealth: 100, // æ·»åŠ bossHealthå±æ€§
                enemySpeed: 2,
                bossSpeed: 1
            }
        };

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            game.canvas = document.getElementById('gameCanvas');
            game.ctx = game.canvas.getContext('2d');
            
            // æ£€æµ‹æ˜¯å¦ä¸ºiPad
            checkDeviceType();
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // è®¾ç½®ç©å®¶åˆå§‹ä½ç½®
            game.player.x = game.width / 2;
            game.player.y = game.height / 2;
            
            // åˆå§‹åŒ–ç½‘æ ¼
            initGrid();
            
            // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨
            setupEventListeners();
            
            // è®¾ç½®å•†åº—å’Œå¡æ§½
            setupShopAndCardSlots();
            
            // è®¾ç½®å¸®åŠ©æŒ‰é’®
            setupHelpButton();
            
            // ç»™ç©å®¶ä¸€äº›åˆå§‹é“œæ¿ï¼Œæ–¹ä¾¿æµ‹è¯•
            game.player.coins = 150;
            document.getElementById('coinsDisplay').textContent = `é“œæ¿: ${game.player.coins}`;
            
            // å¯åŠ¨æ¸¸æˆå¾ªç¯
            requestAnimationFrame(gameLoop);
            
            // åˆå§‹åŒ–éŸ³æ•ˆç³»ç»Ÿ
            SoundManager.init();
        }
        
        // è®¾ç½®å¸®åŠ©æŒ‰é’®
        function setupHelpButton() {
            const helpButton = document.getElementById('helpButton');
            const helpModal = document.getElementById('helpModal');
            const closeHelp = document.getElementById('closeHelp');
            
            // æ‰“å¼€å¸®åŠ©
            helpButton.addEventListener('click', () => {
                game.paused = true;
                helpModal.style.display = 'flex';
            });
            
            // å…³é—­å¸®åŠ©
            closeHelp.addEventListener('click', () => {
                game.paused = false;
                helpModal.style.display = 'none';
            });
        }
        
        // æ£€æµ‹è®¾å¤‡ç±»å‹
        function checkDeviceType() {
            // æ£€æµ‹æ˜¯å¦ä¸ºiPad
            const userAgent = navigator.userAgent.toLowerCase();
            const isIPad = /ipad/.test(userAgent) || 
                          (/macintosh/.test(userAgent) && 'ontouchend' in document);
            
            game.isIPad = isIPad;
            
            // å¦‚æœæ˜¯iPadï¼Œè°ƒæ•´UIå¤§å°
            if (isIPad) {
                document.documentElement.classList.add('ipad');
            }
        }
        
        // è°ƒæ•´ç”»å¸ƒå¤§å°
        function resizeCanvas() {
            game.width = window.innerWidth;
            game.height = window.innerHeight;
            game.canvas.width = game.width;
            game.canvas.height = game.height;
            
            // è°ƒæ•´ç½‘æ ¼å¤§å°ä»¥é€‚åº”å±å¹•
            game.gridCols = Math.ceil(game.width / game.gridSize) + 4; // å¢åŠ é¢å¤–çš„åˆ—ä»¥ç¡®ä¿è¦†ç›–
            game.gridRows = Math.ceil(game.height / game.gridSize) + 4; // å¢åŠ é¢å¤–çš„è¡Œä»¥ç¡®ä¿è¦†ç›–
        }
        
        // åˆå§‹åŒ–ç½‘æ ¼
        function initGrid() {
            game.grid = [];
            
            for (let y = 0; y < game.gridRows; y++) {
                const row = [];
                for (let x = 0; x < game.gridCols; x++) {
                    // éšæœºç”Ÿæˆæ ¼å­ç±»å‹
                    let cellType = 'normal';
                    const rand = Math.random();
                    if (rand < 0.03) {
                        cellType = 'treasure';
                    } else if (rand < 0.07) {
                        cellType = 'box';
                    }
                    
                    row.push({
                        type: cellType,
                        x: x * game.gridSize,
                        y: y * game.gridSize
                    });
                }
                game.grid.push(row);
            }
        }
        
        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            // é”®ç›˜äº‹ä»¶
            window.addEventListener('keydown', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': 
                        game.keys.w = true; 
                        game.player.direction = 270; // Up
                        break;
                    case 'a': 
                        game.keys.a = true; 
                        game.player.direction = 180; // Left
                        break;
                    case 's': 
                        game.keys.s = true; 
                        game.player.direction = 90; // Down
                        break;
                    case 'd': 
                        game.keys.d = true; 
                        game.player.direction = 0; // Right
                        break;
                    case ' ': 
                        game.keys.space = true; 
                        fireBullet(); 
                        if (game.activeEffects.rapidFire) {
                            game.attackInterval = setInterval(fireBullet, 200);
                        }
                        break;
                    case 'e': game.keys.e = true; break;
                    case 'r': game.keys.r = true; break;
                    case 'arrowup': 
                        e.preventDefault();
                        game.keys.ArrowUp = true; 
                        game.player.direction = 270; // Up
                        break;
                    case 'arrowdown': 
                        e.preventDefault();
                        game.keys.ArrowDown = true; 
                        game.player.direction = 90; // Down
                        break;
                    case 'arrowleft': 
                        e.preventDefault();
                        game.keys.ArrowLeft = true; 
                        game.player.direction = 180; // Left
                        break;
                    case 'arrowright': 
                        e.preventDefault();
                        game.keys.ArrowRight = true; 
                        game.player.direction = 0; // Right
                        break;
                }
            });
            
            window.addEventListener('keyup', (e) => {
                switch (e.key.toLowerCase()) {
                    case 'w': game.keys.w = false; break;
                    case 'a': game.keys.a = false; break;
                    case 's': game.keys.s = false; break;
                    case 'd': game.keys.d = false; break;
                    case ' ': 
                        game.keys.space = false; 
                        if (game.attackInterval) {
                            clearInterval(game.attackInterval);
                            game.attackInterval = null;
                        }
                        break;
                    case 'arrowup': game.keys.ArrowUp = false; break;
                    case 'arrowdown': game.keys.ArrowDown = false; break;
                    case 'arrowleft': game.keys.ArrowLeft = false; break;
                    case 'arrowright': game.keys.ArrowRight = false; break;
                    case 'e': game.keys.e = false; break;
                    case 'r': game.keys.r = false; break;
                }
            });
            
            // æ–¹å‘æŒ‰é’®äº‹ä»¶ - å¢å¼ºè§¦æ‘¸æ”¯æŒ
            const directionButtons = ['upButton', 'leftButton', 'downButton', 'rightButton'];
            const directions = ['up', 'left', 'down', 'right']; // ä¿®æ­£æ–¹å‘ï¼Œå®ç°ç©å®¶è§†è§’
            
            directionButtons.forEach((buttonId, index) => {
                const button = document.getElementById(buttonId);
                
                // è§¦æ‘¸äº‹ä»¶
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    moveGrid(directions[index]);
                });
                
                // é¼ æ ‡äº‹ä»¶
                button.addEventListener('mousedown', () => {
                    moveGrid(directions[index]);
                });
                
                // é•¿æŒ‰æ”¯æŒ
                let pressTimer = null;
                
                button.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    moveGrid(directions[index]);
                    pressTimer = setInterval(() => {
                        moveGrid(directions[index]);
                    }, 150);
                });
                
                button.addEventListener('mousedown', () => {
                    moveGrid(directions[index]);
                    pressTimer = setInterval(() => {
                        moveGrid(directions[index]);
                    }, 150);
                });
                
                const clearTimer = () => {
                    if (pressTimer) {
                        clearInterval(pressTimer);
                        pressTimer = null;
                    }
                };
                
                button.addEventListener('touchend', clearTimer);
                button.addEventListener('touchcancel', clearTimer);
                button.addEventListener('mouseup', clearTimer);
                button.addEventListener('mouseleave', clearTimer);
            });
            
            // æ”»å‡»æŒ‰é’®äº‹ä»¶
            const attackButton = document.getElementById('attackButton');
            
            attackButton.addEventListener('touchstart', (e) => {
                e.preventDefault();
                fireBullet();
                if (game.activeEffects.rapidFire) {
                    game.attackInterval = setInterval(fireBullet, 200);
                }
            });
            
            attackButton.addEventListener('mousedown', () => {
                fireBullet();
                if (game.activeEffects.rapidFire) {
                    game.attackInterval = setInterval(fireBullet, 200);
                }
            });
            
            const stopAttack = () => {
                if (game.attackInterval) {
                    clearInterval(game.attackInterval);
                    game.attackInterval = null;
                }
            };
            
            attackButton.addEventListener('touchend', stopAttack);
            attackButton.addEventListener('touchcancel', stopAttack);
            attackButton.addEventListener('mouseup', stopAttack);
            attackButton.addEventListener('mouseleave', stopAttack);
            
            // æ‘‡æ†æ§åˆ¶
            const middleCircle = document.getElementById('middleCircle');
            
            middleCircle.addEventListener('touchstart', (e) => {
                e.preventDefault();
                game.joystick.active = true;
                updateJoystick(e.touches[0]);
            });
            
            middleCircle.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (game.joystick.active) {
                    updateJoystick(e.touches[0]);
                }
            });
            
            middleCircle.addEventListener('touchend', () => {
                game.joystick.active = false;
                resetJoystick();
            });
            
            middleCircle.addEventListener('mousedown', (e) => {
                game.joystick.active = true;
                updateJoystick(e);
            });
            
            window.addEventListener('mousemove', (e) => {
                if (game.joystick.active) {
                    updateJoystick(e);
                }
            });
            
            window.addEventListener('mouseup', () => {
                game.joystick.active = false;
                resetJoystick();
            });
            
            // é˜»æ­¢iOSä¸Šçš„åŒå‡»ç¼©æ”¾
            document.addEventListener('touchend', (e) => {
                const now = Date.now();
                const lastTouch = game.lastTouch || now;
                const delta = now - lastTouch;
                if (delta < 500 && delta > 0) {
                    e.preventDefault();
                }
                game.lastTouch = now;
            }, false);
            
            // é˜²æ­¢åœ¨iOS Safariä¸Šæ‹–åŠ¨å¯¼è‡´æ•´ä¸ªé¡µé¢ç§»åŠ¨
            document.addEventListener('touchmove', (e) => {
                if (e.touches.length > 1) {
                    e.preventDefault();
                }
            }, { passive: false });
        }
        
        // è®¾ç½®å•†åº—å’Œå¡æ§½
        function setupShopAndCardSlots() {
            const shopButton = document.getElementById('shopButton');
            const cardSlotButton = document.getElementById('cardSlotButton');
            const shopModal = document.getElementById('shopModal');
            const cardSlotModal = document.getElementById('cardSlotModal');
            const closeShop = document.getElementById('closeShop');
            const closeCardSlot = document.getElementById('closeCardSlot');
            const buyCardButton = document.getElementById('buyCardButton');
            
            // æ‰“å¼€å•†åº—
            shopButton.addEventListener('click', () => {
                document.getElementById('shopCoinsDisplay').textContent = `å½“å‰é“œæ¿: ${game.player.coins}`;
                game.paused = true;
                shopModal.style.display = 'flex';
            });
            
            // å…³é—­å•†åº—
            closeShop.addEventListener('click', () => {
                game.paused = false;
                shopModal.style.display = 'none';
            });
            
            // æ‰“å¼€å¡æ§½
            cardSlotButton.addEventListener('click', () => {
                game.paused = true;
                updateCardSlotDisplay();
                cardSlotModal.style.display = 'flex';
            });
            
            // å…³é—­å¡æ§½
            closeCardSlot.addEventListener('click', () => {
                game.paused = false;
                cardSlotModal.style.display = 'none';
            });
            
            // è´­ä¹°å¡ç‰Œ
            buyCardButton.addEventListener('click', () => {
                if (game.player.coins >= 50) {
                    game.player.coins -= 50;
                    document.getElementById('shopCoinsDisplay').textContent = `å½“å‰é“œæ¿: ${game.player.coins}`;
                    
                    // éšæœºè·å–å¡ç‰Œ
                    const randomCard = getRandomCard();
                    
                    if (randomCard) {
                        // æ·»åŠ å¡ç‰Œåˆ°å¡æ§½
                        addCardToSlot(randomCard);
                        
                        // æ›´æ–°UI
                        document.getElementById('coinsDisplay').textContent = `é“œæ¿: ${game.player.coins}`;
                        alert(`è·å¾—äº† ${randomCard.name}ï¼`);
                    } else {
                        // å¦‚æœæ²¡æœ‰å¯ç”¨å¡ç‰Œï¼Œè¿”è¿˜é“œæ¿
                        game.player.coins += 50;
                        document.getElementById('shopCoinsDisplay').textContent = `å½“å‰é“œæ¿: ${game.player.coins}`;
                        alert('æ‰€æœ‰å¡ç‰Œéƒ½å·²è·å¾—ï¼Œæ— æ³•è´­ä¹°æ›´å¤šå¡ç‰Œã€‚');
                    }
                } else {
                    alert('é“œæ¿ä¸è¶³ï¼');
                }
            });
            
            // æ·»åŠ å¡æ§½ç‚¹å‡»äº‹ä»¶
            const gunCardSlots = document.querySelectorAll('#gunCardSlots .card-slot');
            gunCardSlots.forEach(slot => {
                slot.addEventListener('click', () => {
                    const slotIndex = parseInt(slot.getAttribute('data-slot'));
                    const cardInfo = game.cardSlots.guns[slotIndex];
                    
                    if (cardInfo) {
                        // æ›´æ¢å½“å‰æªæ”¯
                        const currentGun = game.player.gun;
                        
                        // å¦‚æœå½“å‰æªä¸æ˜¯æ™®é€šæªï¼Œä¿å­˜å®ƒ
                        if (currentGun.type !== 'normal') {
                            // å¯»æ‰¾ç©ºçš„æªæ§½
                            const emptySlotIndex = game.cardSlots.guns.findIndex(slot => slot === null);
                            if (emptySlotIndex !== -1) {
                                const gunInfo = game.cards.guns.find(g => g.id === currentGun.type);
                                game.cardSlots.guns[emptySlotIndex] = gunInfo;
                            }
                        }
                        
                        // è®¾ç½®æ–°æª
                        game.player.gun = {
                            type: cardInfo.id,
                            color: cardInfo.color,
                            damage: cardInfo.damage,
                            bulletCount: cardInfo.bulletCount,
                            bulletSpeed: 7,
                            frozen: cardInfo.frozen,
                            poison: cardInfo.poison
                        };
                        
                        // ç§»é™¤é€‰ä¸­çš„å¡ç‰Œ
                        game.cardSlots.guns[slotIndex] = null;
                        
                        // æ›´æ–°UI
                        updateCardSlotDisplay();
                    }
                });
            });
        }
        
        // æ›´æ–°å¡æ§½æ˜¾ç¤º
        function updateCardSlotDisplay() {
            // æ›´æ–°æªæ¢°å¡æ§½
            const gunCardSlots = document.querySelectorAll('#gunCardSlots .card-slot');
            gunCardSlots.forEach((slot, index) => {
                const cardInfo = game.cardSlots.guns[index];
                updateCardSlotUI(slot, cardInfo);
            });
            
            // æ›´æ–°æŠ€èƒ½å¡æ§½
            const skillCardSlots = document.querySelectorAll('#skillCardSlots .card-slot');
            skillCardSlots.forEach((slot, index) => {
                const cardInfo = game.cardSlots.skills[index];
                updateCardSlotUI(slot, cardInfo);
            });
            
            // æ›´æ–°é“å…·å¡æ§½
            const itemCardSlots = document.querySelectorAll('#itemCardSlots .card-slot');
            itemCardSlots.forEach((slot, index) => {
                const cardInfo = game.cardSlots.items[index];
                updateCardSlotUI(slot, cardInfo);
            });
        }
        
        // ç»˜åˆ¶å¡ç‰Œå›¾æ ‡
        function drawCardIcon(ctx, shape, x, y, size, color) {
            ctx.save();
            ctx.translate(x, y);
            
            switch(shape) {
                case 'flame':
                    // ç«ç„°
                    ctx.fillStyle = color || 'red';
                    ctx.beginPath();
                    ctx.moveTo(0, -size/2);
                    ctx.quadraticCurveTo(-size/3, -size/3, -size/4, 0);
                    ctx.quadraticCurveTo(-size/3, size/3, 0, size/2);
                    ctx.quadraticCurveTo(size/3, size/3, size/4, 0);
                    ctx.quadraticCurveTo(size/3, -size/3, 0, -size/2);
                    ctx.fill();
                    break;
                    
                case 'snowflake':
                    // é›ªèŠ±
                    ctx.strokeStyle = color || 'cyan';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 6; i++) {
                        ctx.rotate(Math.PI / 3);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, -size/2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(0, -size/3);
                        ctx.lineTo(-size/6, -size/4);
                        ctx.moveTo(0, -size/3);
                        ctx.lineTo(size/6, -size/4);
                        ctx.stroke();
                    }
                    break;
                    
                case 'skull':
                    // éª·é«…
                    ctx.fillStyle = color || 'purple';
                    ctx.beginPath();
                    ctx.arc(0, -size/4, size/3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillRect(-size/4, 0, size/2, size/3);
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(-size/6, -size/4, size/10, 0, Math.PI * 2);
                    ctx.arc(size/6, -size/4, size/10, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                    
                case 'ring':
                    // åœ†ç¯
                    ctx.strokeStyle = color || 'gold';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                    ctx.stroke();
                    break;
                    
                case 'lightning':
                    // é—ªç”µ
                    ctx.fillStyle = color || 'yellow';
                    ctx.beginPath();
                    ctx.moveTo(-size/4, -size/2);
                    ctx.lineTo(size/8, -size/6);
                    ctx.lineTo(-size/8, size/6);
                    ctx.lineTo(size/4, size/2);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(size/8, -size/3);
                    ctx.closePath();
                    ctx.fill();
                    break;
                    
                case 'heart':
                    // å¿ƒå½¢
                    ctx.fillStyle = color || 'red';
                    ctx.beginPath();
                    ctx.moveTo(0, -size/4);
                    ctx.bezierCurveTo(-size/2, -size/2, -size/2, 0, 0, size/2);
                    ctx.bezierCurveTo(size/2, 0, size/2, -size/2, 0, -size/4);
                    ctx.fill();
                    break;
                    
                case 'sword':
                    // å‰‘
                    ctx.fillStyle = color || 'silver';
                    ctx.fillRect(-size/16, -size/2, size/8, size);
                    ctx.fillRect(-size/4, -size/6, size/2, size/8);
                    ctx.fillStyle = color || 'brown';
                    ctx.fillRect(-size/8, size/4, size/4, size/4);
                    break;
                    
                case 'arrow':
                    // ç®­
                    ctx.strokeStyle = color || 'brown';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(0, size/2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(-size/4, -size/4);
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(size/4, -size/4);
                    ctx.stroke();
                    break;
                    
                default:
                    // é»˜è®¤å½¢çŠ¶
                    ctx.fillStyle = color || '#ddd';
                    ctx.fillRect(-size/2, -size/2, size, size);
                    break;
            }
            
            ctx.restore();
        }
        
        // æ›´æ–°å•ä¸ªå¡æ§½UI
        function updateCardSlotUI(slotElement, cardInfo) {
            if (cardInfo) {
                slotElement.classList.add('filled');
                
                // åˆ›å»ºcanvasæ¥ç»˜åˆ¶å›¾æ ‡
                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = 60;
                iconCanvas.height = 60;

                
                slotElement.innerHTML = `
                    <div class="card-preview">
                        <div class="card-preview-title">${cardInfo.name}</div>
                        <div class="card-preview-image" style="background-color: transparent; padding: 0;">
                            <img src="./tools/${cardInfo.id}.png" alt="${cardInfo.name}" style="width: 100%; height: 100%; object-fit: contain;">
                        </div>
                        <div class="card-preview-description" style="font-size: 12px">${cardInfo.description}</div>
                    </div>
                `;

            } else {
                slotElement.classList.remove('filled');
                slotElement.textContent = 'ç©ºæ§½';
            }
        }
        
        // è·å–éšæœºå¡ç‰Œ
        function getRandomCard() {
            // ç»„åˆæ‰€æœ‰å¯èƒ½çš„å¡ç‰Œ
            const availableCards = [];
            
            // æ£€æŸ¥æªæ¢°å¡æ§½
            game.cards.guns.forEach(gun => {
                // æ£€æŸ¥è¿™ä¸ªæªæ˜¯å¦å·²ç»åœ¨å¡æ§½ä¸­
                if (!game.cardSlots.guns.some(g => g && g.id === gun.id) && 
                    game.player.gun.type !== gun.id) {
                    availableCards.push({...gun, type: 'gun'});
                }
            });
            
            // æ£€æŸ¥æŠ€èƒ½å¡æ§½
            game.cards.skills.forEach(skill => {
                // æ£€æŸ¥è¿™ä¸ªæŠ€èƒ½æ˜¯å¦å·²ç»åœ¨å¡æ§½ä¸­
                if (!game.cardSlots.skills.some(s => s && s.id === skill.id)) {
                    availableCards.push({...skill, type: 'skill'});
                }
            });
            
            // æ£€æŸ¥é“å…·å¡æ§½
            game.cards.items.forEach(item => {
                // æ£€æŸ¥è¿™ä¸ªé“å…·æ˜¯å¦å·²ç»åœ¨å¡æ§½ä¸­
                if (!game.cardSlots.items.some(i => i && i.id === item.id)) {
                    availableCards.push({...item, type: 'item'});
                }
            });
            
            // å¦‚æœæœ‰å¯ç”¨å¡ç‰Œï¼Œéšæœºé€‰æ‹©ä¸€ä¸ª
            if (availableCards.length > 0) {
                return availableCards[Math.floor(Math.random() * availableCards.length)];
            }
            
            return null;
        }
        
        // æ·»åŠ å¡ç‰Œåˆ°å¡æ§½
        function addCardToSlot(card) {
            switch (card.type) {
                case 'gun':
                    // æ‰¾åˆ°ç©ºçš„æªæ¢°å¡æ§½
                    const emptyGunSlot = game.cardSlots.guns.findIndex(slot => slot === null);
                    if (emptyGunSlot !== -1) {
                        game.cardSlots.guns[emptyGunSlot] = card;
                    }
                    break;
                    
                case 'skill':
                    // æ‰¾åˆ°ç©ºçš„æŠ€èƒ½å¡æ§½
                    const emptySkillSlot = game.cardSlots.skills.findIndex(slot => slot === null);
                    if (emptySkillSlot !== -1) {
                        game.cardSlots.skills[emptySkillSlot] = card;
                        // æŠ€èƒ½è‡ªåŠ¨ç”Ÿæ•ˆ
                        activateSkill(card.id);
                    }
                    break;
                    
                case 'item':
                    // æ‰¾åˆ°ç©ºçš„é“å…·å¡æ§½
                    const emptyItemSlot = game.cardSlots.items.findIndex(slot => slot === null);
                    if (emptyItemSlot !== -1) {
                        game.cardSlots.items[emptyItemSlot] = card;
                        // é“å…·è‡ªåŠ¨ç”Ÿæ•ˆ
                        activateItem(card.id);
                    }
                    break;
            }
        }
        
        // æ¿€æ´»æŠ€èƒ½
        function activateSkill(skillId) {
            game.lastActiveSkillTimes[skillId] = 0;
        }
        
        // æ¿€æ´»é“å…·
        function activateItem(itemId) {
            switch (itemId) {
                case 'lianshe':
                    game.activeEffects.rapidFire = true;
                    break;
                case 'gongjili':
                    game.activeEffects.damageBoost = true;
                    break;
                case 'heal':
                    game.activeEffects.healing = true;
                    break;
                case 'bingdong':
                    game.activeEffects.freezeBoost = true;
                    break;
            }
        }
        
        // æ›´æ–°æ‘‡æ†

        let isDraggingJoystick = false;
        let joystickOffsetX, joystickOffsetY;

        joystickContainer.addEventListener('mousedown', handleDragStart);
        joystickContainer.addEventListener('touchstart', handleDragStart);

        function handleDragStart(e) {
            isDraggingJoystick = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            joystickOffsetX = clientX - joystickContainer.getBoundingClientRect().left;
            joystickOffsetY = clientY - joystickContainer.getBoundingClientRect().top;
            joystickContainer.style.cursor = 'grabbing';
        }

        document.addEventListener('mousemove', handleDragMove);
        document.addEventListener('touchmove', handleDragMove);

        function handleDragMove(e) {
            if (!isDraggingJoystick) return;

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            let newLeft = clientX - joystickOffsetX;
            let newTop = clientY - joystickOffsetY;

            // é™åˆ¶æ‹–æ‹½èŒƒå›´åœ¨å¯è§†åŒºåŸŸå†…
            newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - joystickContainer.offsetWidth));
            newTop = Math.max(0, Math.min(newTop, window.innerHeight - joystickContainer.offsetHeight));

            // é˜»æ­¢é¡µé¢æ»šåŠ¨
            e.preventDefault();

            joystickContainer.style.left = `${newLeft}px`;
            joystickContainer.style.top = `${newTop}px`;
        });

        document.addEventListener('mouseup', handleDragEnd);
        document.addEventListener('touchend', handleDragEnd);

        function handleDragEnd() {
            isDraggingJoystick = false;
            joystickContainer.style.cursor = 'grab';
        }

        // åˆå§‹è®¾ç½®æ‘‡æ†ä¸ºå¯æ‹–æ‹½çŠ¶æ€
        joystickContainer.style.cursor = 'grab';
        function updateJoystick(e) {
            const joystickContainer = document.getElementById('joystickContainer');
            const containerRect = joystickContainer.getBoundingClientRect();
            const middleCircle = document.getElementById('middleCircle');
            
            // è®¡ç®—æ‘‡æ†ä¸­å¿ƒ
            const centerX = containerRect.left + containerRect.width / 2;
            const centerY = containerRect.top + containerRect.height / 2;
            
            // è®¡ç®—è§¦æ‘¸ç‚¹ç›¸å¯¹äºä¸­å¿ƒçš„ä½ç½®
            let deltaX = (e.clientX || e.pageX) - centerX;
            let deltaY = (e.clientY || e.pageY) - centerY;
            
            // è®¡ç®—è·ç¦»å’Œè§’åº¦
            const maxDistance = game.isIPad ? 80 : 50;
            const distance = Math.min(maxDistance, Math.sqrt(deltaX * deltaX + deltaY * deltaY));
            const angle = Math.atan2(deltaY, deltaX);
            
            // æ›´æ–°æ‘‡æ†ä½ç½®
            const x = distance * Math.cos(angle);
            const y = distance * Math.sin(angle);
            
            middleCircle.style.transform = `translate(${x}px, ${y}px)`;
            
            // æ›´æ–°æ¸¸æˆä¸­çš„æ‘‡æ†æ•°æ®
            game.joystick.angle = angle * 180 / Math.PI;
            game.player.direction = game.joystick.angle;
        }
        
        // é‡ç½®æ‘‡æ†
        function resetJoystick() {
            const middleCircle = document.getElementById('middleCircle');
            middleCircle.style.transform = 'translate(0px, 0px)';
        }
        
        // ç§»åŠ¨ç½‘æ ¼ï¼ˆä»¥ç©å®¶è§†è§’ï¼‰
        function moveGrid(direction) {
            // é‡ç½®åœ°å›¾ç§»åŠ¨è®°å½•
            game.mapMovement = { dx: 0, dy: 0 };
            
            switch (direction) {
                case 'up':
                    moveGridDown(); // åœ°å›¾å‘ä¸‹ç§»åŠ¨ï¼Œè®©ç©å®¶çœ‹èµ·æ¥å‘ä¸Šç§»åŠ¨
                    game.mapMovement.dy = -game.gridSize;
                    break;
                case 'down':
                    moveGridUp(); // åœ°å›¾å‘ä¸Šç§»åŠ¨ï¼Œè®©ç©å®¶çœ‹èµ·æ¥å‘ä¸‹ç§»åŠ¨
                    game.mapMovement.dy = game.gridSize;
                    break;
                case 'left':
                    moveGridRight(); // åœ°å›¾å‘å³ç§»åŠ¨ï¼Œè®©ç©å®¶çœ‹èµ·æ¥å‘å·¦ç§»åŠ¨
                    game.mapMovement.dx = game.gridSize;
                    break;
                case 'right':
                    moveGridLeft(); // åœ°å›¾å‘å·¦ç§»åŠ¨ï¼Œè®©ç©å®¶çœ‹èµ·æ¥å‘å³ç§»åŠ¨
                    game.mapMovement.dx = -game.gridSize;
                    break;
            }
            
            // ç§»åŠ¨åœºæ™¯ä¸­çš„æ‰€æœ‰æ•Œäººå’ŒBoss
            moveEnemiesWithGrid(game.mapMovement.dx, game.mapMovement.dy);
            
            // å¤„ç†ç¦»å±æ•Œäººå’ŒBoss
            handleOffscreenEntities();
        }
        
        // ç§»åŠ¨æ•Œäººå’ŒBossè·Ÿéšç½‘æ ¼ç§»åŠ¨
        function moveEnemiesWithGrid(dx, dy) {
            // ç§»åŠ¨æ‰€æœ‰æ•Œäºº
            for (let i = 0; i < game.enemies.length; i++) {
                game.enemies[i].x += dx;
                game.enemies[i].y += dy;
            }
            
            // ç§»åŠ¨æ‰€æœ‰Boss
            for (let i = 0; i < game.bosses.length; i++) {
                game.bosses[i].x += dx;
                game.bosses[i].y += dy;
            }
            
            // ç§»åŠ¨æ‰€æœ‰æŠ€èƒ½
            for (let i = 0; i < game.skills.length; i++) {
                if (!game.skills[i].isPlayerBound) { // ä¸è·Ÿéšç©å®¶çš„æŠ€èƒ½éœ€è¦ç§»åŠ¨
                    game.skills[i].x += dx;
                    game.skills[i].y += dy;
                }
            }
        }
        
        // å¤„ç†ç¦»å±æ•Œäººå’ŒBoss
        function handleOffscreenEntities() {
            // æ£€æŸ¥å¹¶å¤„ç†ç¦»å±æ•Œäºº
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                if (isOffscreen(enemy)) {
                    // å°†æ•Œäººç§»åˆ°ç¦»å±åˆ—è¡¨
                    game.offscreenEnemies.push(enemy);
                    game.enemies.splice(i, 1);
                }
            }
            
            // æ£€æŸ¥å¹¶å¤„ç†ç¦»å±Boss
            for (let i = game.bosses.length - 1; i >= 0; i--) {
                const boss = game.bosses[i];
                if (isOffscreen(boss)) {
                    // å°†Bossç§»åˆ°ç¦»å±åˆ—è¡¨
                    game.offscreenBosses.push(boss);
                    game.bosses.splice(i, 1);
                }
            }
            
            // å¦‚æœæœ‰ç¦»å±æ•Œäººï¼Œéšæœºé€‰æ‹©ä¸€äº›é‡æ–°è¿›å…¥å±å¹•
            if (game.offscreenEnemies.length > 0 && Math.random() < 0.3) {
                // æœ€å¤šè¿”å›3ä¸ªæ•Œäºº
                const count = Math.min(3, game.offscreenEnemies.length);
                for (let i = 0; i < count; i++) {
                    if (game.offscreenEnemies.length > 0) {
                        const index = Math.floor(Math.random() * game.offscreenEnemies.length);
                        const enemy = game.offscreenEnemies[index];
                        
                        // é‡æ–°å®šä½æ•Œäººåˆ°å±å¹•è¾¹ç¼˜
                        repositionEntityToScreenEdge(enemy);
                        
                        // å°†æ•Œäººæ·»åŠ å›æ¸¸æˆ
                        game.enemies.push(enemy);
                        game.offscreenEnemies.splice(index, 1);
                    }
                }
            }
            
            // å¦‚æœæœ‰ç¦»å±Bossï¼Œè®©å®ƒä»¬æ›´å®¹æ˜“å›åˆ°å±å¹•
            if (game.offscreenBosses.length > 0 && Math.random() < 0.5) {
                const boss = game.offscreenBosses[0];
                
                // é‡æ–°å®šä½Bossåˆ°å±å¹•è¾¹ç¼˜
                repositionEntityToScreenEdge(boss);
                
                // å°†Bossæ·»åŠ å›æ¸¸æˆ
                game.bosses.push(boss);
                game.offscreenBosses.splice(0, 1);
            }
        }
        
        // æ£€æŸ¥å®ä½“æ˜¯å¦åœ¨å±å¹•å¤–
        function isOffscreen(entity) {
            const margin = entity.radius * 2;
            return (entity.x < -margin || 
                    entity.x > game.width + margin || 
                    entity.y < -margin || 
                    entity.y > game.height + margin);
        }
        
        // å°†å®ä½“é‡æ–°å®šä½åˆ°å±å¹•è¾¹ç¼˜
        function repositionEntityToScreenEdge(entity) {
            // éšæœºé€‰æ‹©è¾¹ç¼˜
            const edge = Math.floor(Math.random() * 4);
            switch (edge) {
                case 0: // ä¸Šè¾¹ç¼˜
                    entity.x = Math.random() * game.width;
                    entity.y = -entity.radius;
                    break;
                case 1: // å³è¾¹ç¼˜
                    entity.x = game.width + entity.radius;
                    entity.y = Math.random() * game.height;
                    break;
                case 2: // ä¸‹è¾¹ç¼˜
                    entity.x = Math.random() * game.width;
                    entity.y = game.height + entity.radius;
                    break;
                case 3: // å·¦è¾¹ç¼˜
                    entity.x = -entity.radius;
                    entity.y = Math.random() * game.height;
                    break;
            }
        }
        
        // å‘ä¸Šç§»åŠ¨ç½‘æ ¼
        function moveGridUp() {
            const removedRow = game.grid.shift();
            game.removedRows.top.push(removedRow);
            
            // ä»åº•éƒ¨æ·»åŠ æ–°è¡Œ
            let newRow;
            if (game.removedRows.bottom.length > 0) {
                newRow = game.removedRows.bottom.pop();
            } else {
                newRow = [];
                for (let x = 0; x < game.gridCols; x++) {
                    let cellType = 'normal';
                    const rand = Math.random();
                    if (rand < 0.03) {
                        cellType = 'treasure';
                    } else if (rand < 0.07) {
                        cellType = 'box';
                    }
                    
                    newRow.push({
                        type: cellType,
                        x: x * game.gridSize,
                        y: (game.gridRows - 1) * game.gridSize
                    });
                }
            }
            
            game.grid.push(newRow);
            
            // æ›´æ–°æ‰€æœ‰æ ¼å­çš„Yåæ ‡
            for (let y = 0; y < game.grid.length; y++) {
                for (let x = 0; x < game.grid[y].length; x++) {
                    game.grid[y][x].y = y * game.gridSize;
                }
            }
        }
        
        // å‘ä¸‹ç§»åŠ¨ç½‘æ ¼
        function moveGridDown() {
            const removedRow = game.grid.pop();
            game.removedRows.bottom.push(removedRow);
            
            // ä»é¡¶éƒ¨æ·»åŠ æ–°è¡Œ
            let newRow;
            if (game.removedRows.top.length > 0) {
                newRow = game.removedRows.top.pop();
            } else {
                newRow = [];
                for (let x = 0; x < game.gridCols; x++) {
                    let cellType = 'normal';
                    const rand = Math.random();
                    if (rand < 0.03) {
                        cellType = 'treasure';
                    } else if (rand < 0.07) {
                        cellType = 'box';
                    }
                    
                    newRow.push({
                        type: cellType,
                        x: x * game.gridSize,
                        y: 0
                    });
                }
            }
            
            game.grid.unshift(newRow);
            
            // æ›´æ–°æ‰€æœ‰æ ¼å­çš„Yåæ ‡
            for (let y = 0; y < game.grid.length; y++) {
                for (let x = 0; x < game.grid[y].length; x++) {
                    game.grid[y][x].y = y * game.gridSize;
                }
            }
        }
        
        // å‘å·¦ç§»åŠ¨ç½‘æ ¼
        function moveGridLeft() {
            // ä»æ¯ä¸€è¡Œç§»é™¤æœ€å·¦è¾¹çš„æ ¼å­
            const removedCol = [];
            for (let y = 0; y < game.grid.length; y++) {
                const cell = game.grid[y].shift();
                removedCol.push(cell);
            }
            game.removedCols.left.push(removedCol);
            
            // åœ¨æ¯ä¸€è¡Œçš„å³è¾¹æ·»åŠ æ–°æ ¼å­
            let newCol;
            if (game.removedCols.right.length > 0) {
                newCol = game.removedCols.right.pop();
                for (let y = 0; y < game.grid.length; y++) {
                    game.grid[y].push(newCol[y]);
                }
            } else {
                for (let y = 0; y < game.grid.length; y++) {
                    let cellType = 'normal';
                    const rand = Math.random();
                    if (rand < 0.03) {
                        cellType = 'treasure';
                    } else if (rand < 0.07) {
                        cellType = 'box';
                    }
                    
                    game.grid[y].push({
                        type: cellType,
                        x: (game.gridCols - 1) * game.gridSize,
                        y: y * game.gridSize
                    });
                }
            }
            
            // æ›´æ–°æ‰€æœ‰æ ¼å­çš„Xåæ ‡
            for (let y = 0; y < game.grid.length; y++) {
                for (let x = 0; x < game.grid[y].length; x++) {
                    game.grid[y][x].x = x * game.gridSize;
                }
            }
        }
        
        // å‘å³ç§»åŠ¨ç½‘æ ¼
        function moveGridRight() {
            // ä»æ¯ä¸€è¡Œç§»é™¤æœ€å³è¾¹çš„æ ¼å­
            const removedCol = [];
            for (let y = 0; y < game.grid.length; y++) {
                const cell = game.grid[y].pop();
                removedCol.push(cell);
            }
            game.removedCols.right.push(removedCol);
            
            // åœ¨æ¯ä¸€è¡Œçš„å·¦è¾¹æ·»åŠ æ–°æ ¼å­
            let newCol;
            if (game.removedCols.left.length > 0) {
                newCol = game.removedCols.left.pop();
                for (let y = 0; y < game.grid.length; y++) {
                    game.grid[y].unshift(newCol[y]);
                }
            } else {
                for (let y = 0; y < game.grid.length; y++) {
                    let cellType = 'normal';
                    const rand = Math.random();
                    if (rand < 0.1) {
                        cellType = 'treasure';
                    } else if (rand < 0.2) {
                        cellType = 'box';
                    }
                    
                    game.grid[y].unshift({
                        type: cellType,
                        x: 0,
                        y: y * game.gridSize
                    });
                }
            }
            
            // æ›´æ–°æ‰€æœ‰æ ¼å­çš„Xåæ ‡
            for (let y = 0; y < game.grid.length; y++) {
                for (let x = 0; x < game.grid[y].length; x++) {
                    game.grid[y][x].x = x * game.gridSize;
                }
            }
        }
        
        // å‘å°„å­å¼¹
        function fireBullet() {
            if (game.paused) return;
            
            const gunInfo = game.player.gun;
            const bulletCount = gunInfo.bulletCount;
            const bulletSpeed = gunInfo.bulletSpeed;
            let damage = gunInfo.damage;
            
            // åº”ç”¨æ”»å‡»åŠ›æå‡æ•ˆæœ
            if (game.activeEffects.damageBoost) {
                damage += 2;
            }
            
            // åº”ç”¨å†°å†»æå‡æ•ˆæœ
            let frozen = gunInfo.frozen;
            if (game.activeEffects.freezeBoost) {
                frozen = true;
            }
            
            for (let i = 0; i < bulletCount; i++) {
                // è®¡ç®—æ¯ä¸ªå­å¼¹çš„è§’åº¦åç§»
                let angleOffset = 0;
                if (bulletCount > 1) {
                    angleOffset = (i - Math.floor(bulletCount / 2)) * 10;
                }
                
                let angle = (game.player.direction + angleOffset) * Math.PI / 180;
                // å¦‚æœç©å®¶æ²¡æœ‰ç§»åŠ¨ï¼Œä½†æ‘‡æ†æœ‰æ–¹å‘ï¼Œåˆ™ä½¿ç”¨æ‘‡æ†æ–¹å‘
                if (!game.keys.w && !game.keys.a && !game.keys.s && !game.keys.d &&
                    !game.keys.ArrowUp && !game.keys.ArrowDown && !game.keys.ArrowLeft && !game.keys.ArrowRight &&
                    game.joystick.active) {
                    angle = (game.joystick.angle + angleOffset) * Math.PI / 180;
                }
                
                // è®¡ç®—å­å¼¹åˆå§‹ä½ç½®
                const bulletX = game.player.x + Math.cos(angle) * (game.player.radius + 10);
                const bulletY = game.player.y + Math.sin(angle) * (game.player.radius + 10);
                
                // æ·»åŠ å­å¼¹
                game.bullets.push({
                    x: bulletX,
                    y: bulletY,
                    radius: 5,
                    color: gunInfo.color,
                    velocityX: Math.cos(angle) * bulletSpeed,
                    velocityY: Math.sin(angle) * bulletSpeed,
                    damage: damage,
                    frozen: frozen,
                    poison: gunInfo.poison
                });
                
                // æ’­æ”¾å°„å‡»éŸ³æ•ˆ
                SoundManager.play('shoot');
            }
        }
        
        // ç”Ÿæˆæ•Œäºº
        function spawnEnemy() {
            const now = Date.now();
            
            // ç”Ÿæˆå°æ€ª
            if (now - game.lastEnemySpawn > game.enemySpawnRate) {
                // åœ¨éšæœºä½ç½®ç”Ÿæˆæ•Œäºº
                const spawnX = Math.random() * game.width;
                const spawnY = Math.random() * game.height;
                
                game.enemies.push({
                    x: spawnX,
                    y: spawnY,
                    radius: game.player.radius / 2,
                    color: 'red',
                    health: 3,
                    speed: game.difficultySettings.enemySpeed,
                    frozen: {
                        active: false,
                        duration: 0
                    }
                });
                
                game.lastEnemySpawn = now;
            }
            
            // ç”ŸæˆBoss
            if (now - game.lastBossSpawn > game.bossSpawnRate) {
                // åœ¨éšæœºä½ç½®ç”ŸæˆBoss
                const spawnX = Math.random() * game.width;
                const spawnY = Math.random() * game.height;
                
                game.bosses.push({
                    x: spawnX,
                    y: spawnY,
                    radius: game.player.radius * 2,
                    color: 'darkred',
                    health: Math.min(game.difficultySettings.bossHealth * 2, 100), // è¡€é‡ç¿»å€ï¼Œæœ€é«˜100
                    speed: game.difficultySettings.bossSpeed,
                    frozen: {
                        active: false,
                        duration: 0
                    }
                });
                
                game.lastBossSpawn = now;
            } else if (game.bosses.length === 0 && game.bossRespawnTime === 0) {
                // å¦‚æœæ²¡æœ‰Bossä¸”Bossé‡ç”Ÿæ—¶é—´æœªè®¾ç½®ï¼Œåˆ™è®¾ç½®é‡ç”Ÿæ—¶é—´
                game.bossRespawnTime = now + 3000; // 3ç§’åé‡ç”Ÿ
            }

            // æ£€æŸ¥Bossæ˜¯å¦éœ€è¦é‡ç”Ÿ
            if (game.bossRespawnTime !== 0 && now >= game.bossRespawnTime) {
                // åœ¨éšæœºä½ç½®ç”ŸæˆBoss
                const spawnX = Math.random() * game.width;
                const spawnY = Math.random() * game.height;

                game.bosses.push({
                    x: spawnX,
                    y: spawnY,
                    radius: game.player.radius * 2,
                    color: 'darkred',
                    health: 30,
                    speed: game.difficultySettings.bossSpeed,
                    frozen: {
                        active: false,
                        duration: 0
                    }
                });
                game.bossRespawnTime = 0; // é‡ç”Ÿåé‡ç½®æ—¶é—´
            }
        }
        
        // æ›´æ–°æ¸¸æˆçŠ¶æ€
        function update(deltaTime) {
            if (game.paused) return;
            
            game.gameTime += deltaTime;
            
            // å¤„ç†æŒ‰é”®è¾“å…¥
            handleKeyInput();
            
            // ç”Ÿæˆæ•Œäºº
            spawnEnemy();
            
            // æ›´æ–°å­å¼¹
            updateBullets(deltaTime);
            
            // æ›´æ–°æ•Œäºº
            updateEnemies(deltaTime);
            
            // æ›´æ–°Boss
            updateBosses(deltaTime);
            
            // æ›´æ–°æŠ€èƒ½
            updateSkills(deltaTime);
            
            // æ›´æ–°ç‰¹æ®Šæ•ˆæœ
            updateEffects(deltaTime);
            
            // æ£€æŸ¥ç©å®¶æ˜¯å¦ç«™åœ¨ç‰¹æ®Šæ ¼å­ä¸Š
            checkPlayerOnSpecialCell();
            
            // æ›´æ–°æŠ¤ç›¾
            if (game.player.shield.active) {
                game.player.shield.duration -= deltaTime;
                if (game.player.shield.duration <= 0) {
                    game.player.shield.active = false;
                }
            }
            
            // æ›´æ–°è§†è§‰ç‰¹æ•ˆ
            EffectsManager.update(deltaTime);
        }
        
        // å¤„ç†æŒ‰é”®è¾“å…¥
        function handleKeyInput() {
            if (game.keys.w || game.keys.ArrowUp) moveGrid('up');
            if (game.keys.a || game.keys.ArrowLeft) moveGrid('left');
            if (game.keys.s || game.keys.ArrowDown) moveGrid('down');
            if (game.keys.d || game.keys.ArrowRight) moveGrid('right');

            // è°ƒæ•´æ”»å‡»è§’åº¦
            if (game.keys.e) {
                game.player.direction = (game.player.direction - 15 + 360) % 360;
                game.keys.e = false; // æ¯æ¬¡æŒ‰ä¸‹åªè°ƒæ•´ä¸€æ¬¡
            }
            if (game.keys.r) {
                game.player.direction = (game.player.direction + 15) % 360;
                game.keys.r = false; // æ¯æ¬¡æŒ‰ä¸‹åªè°ƒæ•´ä¸€æ¬¡
            }
            
            // è¿å‘
            if (game.keys.space && game.activeEffects.rapidFire) {
                fireBullet();
            }
        }
        
        // æ›´æ–°å­å¼¹
        function updateBullets(deltaTime) {
            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const bullet = game.bullets[i];
                
                // ç§»åŠ¨å­å¼¹
                bullet.x += bullet.velocityX;
                bullet.y += bullet.velocityY;
                
                // æ£€æŸ¥å­å¼¹æ˜¯å¦è¶…å‡ºå±å¹•
                if (bullet.x < 0 || bullet.x > game.width || bullet.y < 0 || bullet.y > game.height) {
                    game.bullets.splice(i, 1);
                    continue;
                }
                
                // æ£€æŸ¥å­å¼¹æ˜¯å¦å‡»ä¸­æ•Œäºº
                let hitEnemy = false;
                for (let j = game.enemies.length - 1; j >= 0; j--) {
                    const enemy = game.enemies[j];
                    const dx = bullet.x - enemy.x;
                    const dy = bullet.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < bullet.radius + enemy.radius) {
                        // é€ æˆä¼¤å®³
                        enemy.health -= bullet.damage;
                        
                        // æ’­æ”¾å‡»ä¸­éŸ³æ•ˆå’Œè§†è§‰ç‰¹æ•ˆ
                        SoundManager.play('hit');
                        EffectsManager.createHitEffect(enemy.x, enemy.y, 'yellow');
                        EffectsManager.createDamageNumber(enemy.x, enemy.y, bullet.damage, 'white');
                        
                        // å†°å†»æ•ˆæœ
                        if (bullet.frozen) {
                            enemy.frozen.active = true;
                            enemy.frozen.duration = 10000; // 10ç§’
                        }
                        
                        // æ¯’è¯æ•ˆæœ
                        if (bullet.poison) {
                            enemy.health -= 3;
                        }
                        
                        // å¦‚æœæ•Œäººæ­»äº¡
                        if (enemy.health <= 0) {
                            // å¥–åŠ±
                            game.player.coins += 10;
                            document.getElementById('coinsDisplay').textContent = `é“œæ¿: ${game.player.coins}`;
                            
                            // æ’­æ”¾æ•Œäººæ­»äº¡éŸ³æ•ˆå’Œè§†è§‰ç‰¹æ•ˆ
                            SoundManager.play('enemyDeath');
                            SoundManager.play('coin');
                            EffectsManager.createDeathEffect(enemy.x, enemy.y, 'red');
                            EffectsManager.createPickupEffect(enemy.x, enemy.y, '10', 'gold');
                            
                            // ç§»é™¤æ•Œäºº
                            game.enemies.splice(j, 1);
                        }
                        
                        hitEnemy = true;
                        break;
                    }
                }
                
                // æ£€æŸ¥å­å¼¹æ˜¯å¦å‡»ä¸­Boss
                if (!hitEnemy) {
                    for (let j = game.bosses.length - 1; j >= 0; j--) {
                        const boss = game.bosses[j];
                        const dx = bullet.x - boss.x;
                        const dy = bullet.y - boss.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < bullet.radius + boss.radius) {
                            // é€ æˆä¼¤å®³
                            boss.health -= bullet.damage;
                            
                            // æ’­æ”¾å‡»ä¸­éŸ³æ•ˆå’Œè§†è§‰ç‰¹æ•ˆ
                            SoundManager.play('hit');
                            EffectsManager.createHitEffect(boss.x, boss.y, 'orange');
                            EffectsManager.createDamageNumber(boss.x, boss.y, bullet.damage, 'white');
                            
                            // å†°å†»æ•ˆæœ
                            if (bullet.frozen) {
                                boss.frozen.active = true;
                                boss.frozen.duration = 10000; // 10ç§’
                            }
                            
                            // æ¯’è¯æ•ˆæœ
                            if (bullet.poison) {
                                boss.health -= 3;
                            }
                            
                            // å¥–åŠ±æ¯å‡å°‘1è¡€ç»™10é“œæ¿
                            game.player.coins += bullet.damage;
                            document.getElementById('coinsDisplay').textContent = `é“œæ¿: ${game.player.coins}`;
                            
                            // å¦‚æœBossæ­»äº¡
                            if (boss.health <= 0) {
                                // æ’­æ”¾Bossæ­»äº¡éŸ³æ•ˆå’Œè§†è§‰ç‰¹æ•ˆ
                                SoundManager.play('enemyDeath');
                                EffectsManager.createDeathEffect(boss.x, boss.y, 'darkred');
                                EffectsManager.createPickupEffect(boss.x, boss.y, '50', 'gold');
                                
                                // ç§»é™¤Boss
                                game.bosses.splice(j, 1);
                                game.bossRespawnTime = Date.now() + 3000; // è®¾ç½®3ç§’åé‡ç”Ÿ
                                // ç©å®¶è¡€é‡å¢åŠ ï¼Œç¿»å€å’Œ50å–æœ€å°å€¼
                                game.player.health += Math.min(game.player.health, 50);
                                document.getElementById('healthDisplay').textContent = `è¡€é‡: ${game.player.health}`;
                            }
                            
                            hitEnemy = true;
                            break;
                        }
                    }
                }
                
                // å¦‚æœå­å¼¹å‡»ä¸­ç›®æ ‡ï¼Œç§»é™¤å­å¼¹
                if (hitEnemy) {
                    game.bullets.splice(i, 1);
                }
            }
        }
        
        // æ›´æ–°æ•Œäºº
        function updateEnemies(deltaTime) {
            for (let i = game.enemies.length - 1; i >= 0; i--) {
                const enemy = game.enemies[i];
                
                // å¦‚æœæ•Œäººè¢«å†»ç»“ï¼Œè·³è¿‡ç§»åŠ¨
                if (enemy.frozen.active) {
                    enemy.frozen.duration -= deltaTime;
                    if (enemy.frozen.duration <= 0) {
                        enemy.frozen.active = false;
                    }
                    continue;
                }
                
                // è®¡ç®—æ•Œäººåˆ°ç©å®¶çš„æ–¹å‘
                const dx = game.player.x - enemy.x;
                const dy = game.player.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // ç§»åŠ¨æ•Œäºº
                if (distance > 0) {
                    enemy.x += (dx / distance) * enemy.speed;
                    enemy.y += (dy / distance) * enemy.speed;
                }
                
                // æ£€æŸ¥æ•Œäººæ˜¯å¦ç¢°åˆ°ç©å®¶
                if (distance < enemy.radius + game.player.radius) {
                    // å¦‚æœç©å®¶æœ‰æŠ¤ç›¾ï¼Œä¸å—ä¼¤å®³
                    if (!game.player.shield.active) {
                        game.player.health -= game.difficultySettings.enemyDamage;
                        document.getElementById('healthDisplay').textContent = `è¡€é‡: ${game.player.health}`;
                        
                        // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
                        if (game.player.health <= 0) {
                            alert('æ¸¸æˆç»“æŸï¼');
                            location.reload(); // é‡æ–°åŠ è½½é¡µé¢ä»¥é‡å¯æ¸¸æˆ
                        }
                    }
                    
                    // ç§»é™¤æ•Œäºº
                    game.enemies.splice(i, 1);
                }
            }
        }
        
        // æ›´æ–°Boss
        function updateBosses(deltaTime) {
            for (let i = game.bosses.length - 1; i >= 0; i--) {
                const boss = game.bosses[i];
                
                // å¦‚æœBossè¢«å†»ç»“ï¼Œè·³è¿‡ç§»åŠ¨
                if (boss.frozen.active) {
                    boss.frozen.duration -= deltaTime;
                    if (boss.frozen.duration <= 0) {
                        boss.frozen.active = false;
                    }
                    continue;
                }
                
                // è®¡ç®—Bossåˆ°ç©å®¶çš„æ–¹å‘
                const dx = game.player.x - boss.x;
                const dy = game.player.y - boss.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // ç§»åŠ¨Boss
                if (distance > 0) {
                    boss.x += (dx / distance) * boss.speed;
                    boss.y += (dy / distance) * boss.speed;
                }
                
                // æ£€æŸ¥Bossæ˜¯å¦ç¢°åˆ°ç©å®¶
                if (distance < boss.radius + game.player.radius) {
                    // å¦‚æœç©å®¶æœ‰æŠ¤ç›¾ï¼Œä¸å—ä¼¤å®³
                    if (!game.player.shield.active) {
                        game.player.health -= game.difficultySettings.bossDamage;
                        document.getElementById('healthDisplay').textContent = `è¡€é‡: ${game.player.health}`;
                        
                        // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
                        if (game.player.health <= 0) {
                            alert('æ¸¸æˆç»“æŸï¼');
                            location.reload(); // é‡æ–°åŠ è½½é¡µé¢ä»¥é‡å¯æ¸¸æˆ
                        }
                    }
                    
                    // Bossä¸ä¼šæ¶ˆå¤±ï¼Œåªä¼šè¢«å‡»é€€
                    const pushDistance = 50; // å‡»é€€è·ç¦»
                    if (distance > 0) {
                        boss.x -= (dx / distance) * pushDistance;
                        boss.y -= (dy / distance) * pushDistance;
                    }
                }
            }
        }
        
        // æ›´æ–°æŠ€èƒ½
        function updateSkills(deltaTime) {
            // æ£€æŸ¥æŠ€èƒ½å¡æ§½ä¸­çš„æŠ€èƒ½
            for (const skillCard of game.cardSlots.skills) {
                if (!skillCard) continue;
                
                const skillId = skillCard.id;
                const now = game.gameTime;
                
                // ç¡®ä¿lastActiveSkillTimeså­˜åœ¨
                if (!game.lastActiveSkillTimes[skillId]) {
                    game.lastActiveSkillTimes[skillId] = 0;
                }
                
                switch (skillId) {
                    case 'qiankun': // ä¹¾å¤åœˆ
                        if (now - game.lastActiveSkillTimes[skillId] > 5000) { // æ¯5ç§’
                            createQiankunCircles();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                        
                    case 'huntian': // æ··å¤©å‡Œ
                        if (now - game.lastActiveSkillTimes[skillId] > 10000) { // æ¯10ç§’
                            createHuntianLing();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                        
                    case 'huojian': // ç«å°–æª
                        if (now - game.lastActiveSkillTimes[skillId] > 500) { // æ¯0.5ç§’
                            createHuojianSpear();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                        
                    case 'fenghuolun': // é£ç«è½®
                        if (now - game.lastActiveSkillTimes[skillId] > 1000) { // æ¯1ç§’
                            createFenghuoWheel();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                        
                    case 'jiulong': // ä¹é¾™ç›–ç«ç½©
                        if (now - game.lastActiveSkillTimes[skillId] > 50000) { // æ¯50ç§’
                            createJiulongCover();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                        
                    case 'bagua': // å…«å¦é˜µå®å‰‘
                        if (now - game.lastActiveSkillTimes[skillId] > 3000) { // æ¯3ç§’
                            createBaguaSwords();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                        
                    case 'jinzhuan': // é‡‘ç –
                        if (now - game.lastActiveSkillTimes[skillId] > 1000) { // æ¯1ç§’
                            createJinzhuanBricks();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                        
                    case 'jianyu': // ç®­é›¨
                        if (now - game.lastActiveSkillTimes[skillId] > 3000) { // æ¯3ç§’
                            createJianyuArrows();
                            game.lastActiveSkillTimes[skillId] = now;
                        }
                        break;
                }
            }
            
            // æ›´æ–°ç°æœ‰æŠ€èƒ½æ•ˆæœ
            for (let i = game.skills.length - 1; i >= 0; i--) {
                const skill = game.skills[i];
                
                // æ›´æ–°æŠ€èƒ½ä½ç½®
                if (skill.update) {
                    skill.update(deltaTime);
                }
                
                // æ£€æŸ¥æŠ€èƒ½æ˜¯å¦è¿‡æœŸ
                if (skill.duration !== undefined) {
                    skill.duration -= deltaTime;
                    if (skill.duration <= 0) {
                        game.skills.splice(i, 1);
                        continue;
                    }
                }
                
                // æ£€æŸ¥æŠ€èƒ½æ˜¯å¦è¶…å‡ºå±å¹•
                if (skill.x < -100 || skill.x > game.width + 100 || 
                    skill.y < -100 || skill.y > game.height + 100) {
                    if (!skill.isGlobal) {
                        game.skills.splice(i, 1);
                        continue;
                    }
                }
                
                // æ£€æŸ¥æŠ€èƒ½æ˜¯å¦å‡»ä¸­æ•Œäºº
                for (let j = game.enemies.length - 1; j >= 0; j--) {
                    const enemy = game.enemies[j];
                    if (checkSkillHitEnemy(skill, enemy)) {
                        // åº”ç”¨æŠ€èƒ½æ•ˆæœ
                        enemy.health -= skill.damage || 3;
                        
                        // å¦‚æœæ•Œäººæ­»äº¡
                        if (enemy.health <= 0) {
                            // å¥–åŠ±
                            game.player.coins += 10;
                            document.getElementById('coinsDisplay').textContent = `é“œæ¿: ${game.player.coins}`;
                            
                            // ç§»é™¤æ•Œäºº
                            game.enemies.splice(j, 1);
                        }
                        
                        // å¦‚æœæŠ€èƒ½æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œç§»é™¤å®ƒ
                        if (skill.oneTime) {
                            game.skills.splice(i, 1);
                            break;
                        }
                    }
                }
                
                // æ£€æŸ¥æŠ€èƒ½æ˜¯å¦å‡»ä¸­Boss
                for (let j = game.bosses.length - 1; j >= 0; j--) {
                    const boss = game.bosses[j];
                    if (checkSkillHitEnemy(skill, boss)) {
                        // åº”ç”¨æŠ€èƒ½æ•ˆæœ
                        boss.health -= skill.damage || 3;
                        
                        // å¥–åŠ±æ¯å‡å°‘1è¡€ç»™10é“œæ¿
                        game.player.coins += skill.damage || 3;
                        document.getElementById('coinsDisplay').textContent = `é“œæ¿: ${game.player.coins}`;
                        
                        // å¦‚æœBossæ­»äº¡
                        if (boss.health <= 0) {
                            // ç§»é™¤Boss
                            game.bosses.splice(j, 1);
                        }
                        
                        // å¦‚æœæŠ€èƒ½æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œç§»é™¤å®ƒ
                        if (skill.oneTime) {
                            game.skills.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        
        // æ£€æŸ¥æŠ€èƒ½æ˜¯å¦å‡»ä¸­æ•Œäºº
        function checkSkillHitEnemy(skill, enemy) {
            if (skill.type === 'circle') {
                const dx = skill.x - enemy.x;
                const dy = skill.y - enemy.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < skill.radius + enemy.radius;
            } else if (skill.type === 'rectangle') {
                // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
                return (
                    skill.x < enemy.x + enemy.radius &&
                    skill.x + skill.width > enemy.x - enemy.radius &&
                    skill.y < enemy.y + enemy.radius &&
                    skill.y + skill.height > enemy.y - enemy.radius
                );
            }
            return false;
        }
        
        // åˆ›å»ºä¹¾å¤åœˆ
        function createQiankunCircles() {
            const circleCount = 6;
            for (let i = 0; i < circleCount; i++) {
                const angle = (i / circleCount) * Math.PI * 2;
                const distance = 80;
                
                game.skills.push({
                    type: 'circle',
                    x: game.player.x + Math.cos(angle) * distance,
                    y: game.player.y + Math.sin(angle) * distance,
                    radius: 15,
                    color: 'gold',
                    damage: 3,
                    duration: 5000,
                    angle: angle,
                    isPlayerBound: true, // è·Ÿéšç©å®¶
                    update: function(deltaTime) {
                        // æ—‹è½¬ä¹¾å¤åœˆ
                        this.angle += 0.005 * deltaTime;
                        this.x = game.player.x + Math.cos(this.angle) * distance;
                        this.y = game.player.y + Math.sin(this.angle) * distance;
                    }
                });
            }
        }
        
        // åˆ›å»ºæ··å¤©å‡Œ
        function createHuntianLing() {
            const angle = Math.random() * Math.PI * 2;
            const speed = 5;
            
            game.skills.push({
                type: 'circle',
                x: game.player.x,
                y: game.player.y,
                radius: 20,
                color: 'purple',
                damage: 3,
                velocityX: Math.cos(angle) * speed,
                velocityY: Math.sin(angle) * speed,
                duration: 10000,
                update: function(deltaTime) {
                    // ç§»åŠ¨æ··å¤©å‡Œ
                    this.x += this.velocityX;
                    this.y += this.velocityY;
                    
                    // å¦‚æœç¢°åˆ°è¾¹ç•Œï¼Œåå¼¹
                    if (this.x < this.radius || this.x > game.width - this.radius) {
                        this.velocityX = -this.velocityX;
                    }
                    if (this.y < this.radius || this.y > game.height - this.radius) {
                        this.velocityY = -this.velocityY;
                    }
                }
            });
        }
        
        // åˆ›å»ºç«å°–æª
        function createHuojianSpear() {
            // è·å–ç©å®¶çš„åæ–¹å‘
            const angle = (game.player.direction + 180) * Math.PI / 180;
            const distance = game.player.radius + 20;
            
            const spearX = game.player.x + Math.cos(angle) * distance;
            const spearY = game.player.y + Math.sin(angle) * distance;
            
            const spearLength = 30;
            const spearWidth = 8;
            
            game.skills.push({
                type: 'rectangle',
                x: spearX - (spearWidth / 2),
                y: spearY - (spearLength / 2),
                width: spearWidth,
                height: spearLength,
                angle: angle,
                color: 'orangered',
                damage: 3,
                duration: 500,
                isPlayerBound: true, // è·Ÿéšç©å®¶
                update: function(deltaTime) {
                    // ç«å°–æªè·Ÿéšç©å®¶
                    this.angle = (game.player.direction + 180) * Math.PI / 180;
                    const spearX = game.player.x + Math.cos(this.angle) * distance;
                    const spearY = game.player.y + Math.sin(this.angle) * distance;
                    this.x = spearX - (spearWidth / 2);
                    this.y = spearY - (spearLength / 2);
                }
            });
        }
        
        // åˆ›å»ºé£ç«è½®
        function createFenghuoWheel() {
            // åœ¨ç©å®¶å½“å‰ä½ç½®åˆ›å»ºç«ç„°ç—•è¿¹
            game.skills.push({
                type: 'circle',
                x: game.player.x,
                y: game.player.y,
                radius: 15,
                color: 'orange',
                damage: 3,
                duration: 5000,
                isGlobal: true
            });
        }
        
        // åˆ›å»ºä¹é¾™ç›–ç«ç½©ï¼ˆèŒƒå›´å¢å¤§5å€ï¼‰
        function createJiulongCover() {
            // å¦‚æœæœ‰Bossï¼Œä¼˜å…ˆç›–ä½Boss
            let targetX = game.player.x;
            let targetY = game.player.y;
            
            if (game.bosses.length > 0) {
                targetX = game.bosses[0].x;
                targetY = game.bosses[0].y;
            }
            
            game.skills.push({
                type: 'circle',
                x: targetX,
                y: targetY,
                radius: 500, // èŒƒå›´å¢å¤§åˆ°5å€
                color: 'rgba(255, 100, 0, 0.3)',
                damage: 40,
                duration: 3000,
                // oneTime: true // <-- BUG FIX: Removed this line
            });
        }
        
        // åˆ›å»ºå…«å¦é˜µå®å‰‘
        function createBaguaSwords() {
            const swordCount = 8;
            for (let i = 0; i < swordCount; i++) {
                const angle = (i / swordCount) * Math.PI * 2;
                const distance = 50;
                const speed = 5;
                
                game.skills.push({
                    type: 'rectangle',
                    x: game.player.x + Math.cos(angle) * distance,
                    y: game.player.y + Math.sin(angle) * distance,
                    width: 10,
                    height: 30,
                    angle: angle,
                    color: 'cyan',
                    damage: 5,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    duration: 3000,
                    update: function(deltaTime) {
                        this.x += this.velocityX;
                        this.y += this.velocityY;
                    }
                });
            }
        }
        
        // åˆ›å»ºé‡‘ç –
        function createJinzhuanBricks() {
            const brickCount = 10;
            for (let i = 0; i < brickCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 3 + Math.random() * 2;
                
                game.skills.push({
                    type: 'rectangle',
                    x: game.player.x,
                    y: game.player.y,
                    width: 20,
                    height: 10,
                    angle: angle,
                    color: 'gold',
                    damage: 5,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    duration: 5000,
                    update: function(deltaTime) {
                        this.x += this.velocityX;
                        this.y += this.velocityY;
                    }
                });
            }
        }
        
        // åˆ›å»ºç®­é›¨
        function createJianyuArrows() {
            const arrowCount = 50;
            const baseAngle = Math.random() * Math.PI * 2;
            const angleSpread = Math.PI / 3; // 60åº¦æ‰‡å½¢
            
            for (let i = 0; i < arrowCount; i++) {
                const angle = baseAngle + (i / arrowCount - 0.5) * angleSpread;
                const speed = 5 + Math.random() * 2;
                
                game.skills.push({
                    type: 'rectangle',
                    x: game.player.x,
                    y: game.player.y,
                    width: 5,
                    height: 20,
                    angle: angle,
                    color: 'brown',
                    damage: 2,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    duration: 5000,
                    update: function(deltaTime) {
                        this.x += this.velocityX;
                        this.y += this.velocityY;
                    }
                });
            }
        }
        
        // æ›´æ–°ç‰¹æ®Šæ•ˆæœ
        function updateEffects(deltaTime) {
            // æ²»ç–—æ•ˆæœ
            if (game.activeEffects.healing) {
                if (game.gameTime % 3000 < deltaTime) {
                    if (game.player.health < game.player.maxHealth) {
                        game.player.health += 1;
                        document.getElementById('healthDisplay').textContent = `è¡€é‡: ${game.player.health}`;
                    }
                }
            }
        }
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦ç«™åœ¨ç‰¹æ®Šæ ¼å­ä¸Š
        function checkPlayerOnSpecialCell() {
            const playerGridX = Math.floor(game.player.x / game.gridSize);
            const playerGridY = Math.floor(game.player.y / game.gridSize);
            
            // ç¡®ä¿æ ¼å­ç´¢å¼•åœ¨æœ‰æ•ˆèŒƒå›´å†…
            if (playerGridY >= 0 && playerGridY < game.grid.length && 
                playerGridX >= 0 && playerGridX < game.grid[playerGridY].length) {
                
                const cell = game.grid[playerGridY][playerGridX];
                
                if (cell.type === 'treasure') {
                    // å®ç®±æ ¼å­ï¼šè·å¾—100é“œæ¿
                    game.player.coins += 100;
                    document.getElementById('coinsDisplay').textContent = `é“œæ¿: ${game.player.coins}`;
                    
                    // æ’­æ”¾è·å¾—é“œæ¿éŸ³æ•ˆå’Œè§†è§‰ç‰¹æ•ˆ
                    SoundManager.play('coin');
                    EffectsManager.createPickupEffect(game.player.x, game.player.y - 30, '100', 'gold');
                    EffectsManager.createHitEffect(game.player.x, game.player.y, 'gold');
                    
                    cell.type = 'normal';
                } else if (cell.type === 'box') {
                    // ç®±å­æ ¼å­ï¼šè·å¾—ä¿æŠ¤ç½©
                    game.player.shield.active = true;
                    game.player.shield.duration = 5000; // 5ç§’
                    
                    // æ’­æ”¾è·å¾—æŠ¤ç›¾éŸ³æ•ˆå’Œè§†è§‰ç‰¹æ•ˆ
                    SoundManager.play('shield');
                    EffectsManager.createHitEffect(game.player.x, game.player.y, 'cyan');
                    
                    cell.type = 'normal';
                }
            }
        }
        
        // ç»˜åˆ¶æ¸¸æˆ
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            game.ctx.clearRect(0, 0, game.width, game.height);
            
            // ç»˜åˆ¶ç½‘æ ¼
            drawGrid();
            
            // ç»˜åˆ¶æŠ€èƒ½
            drawSkills();
            
            // ç»˜åˆ¶æ•Œäºº
            drawEnemies();
            
            // ç»˜åˆ¶Boss
            drawBosses();
            
            // ç»˜åˆ¶ç©å®¶
            drawPlayer();
            
            // ç»˜åˆ¶å­å¼¹
            drawBullets();
            
            // ç»˜åˆ¶è§†è§‰ç‰¹æ•ˆ
            EffectsManager.draw(game.ctx);
        }
        
        // ç»˜åˆ¶ç½‘æ ¼
        function drawGrid() {
            for (let y = 0; y < game.grid.length; y++) {
                for (let x = 0; x < game.grid[y].length; x++) {
                    const cell = game.grid[y][x];
                    
                    // è®¾ç½®æ ¼å­é¢œè‰²
                    let cellColor;
                    switch (cell.type) {
                        case 'treasure':
                            cellColor = 'gold';
                            break;
                        case 'box':
                            cellColor = 'brown';
                            break;
                        default:
                            cellColor = '#ccc';
                            break;
                    }
                    
                    // ç»˜åˆ¶æ ¼å­
                    game.ctx.fillStyle = cellColor;
                    game.ctx.fillRect(cell.x, cell.y, game.gridSize, game.gridSize);
                    
                    // ç»˜åˆ¶æ ¼å­è¾¹æ¡†
                    game.ctx.strokeStyle = '#aaa';
                    game.ctx.strokeRect(cell.x, cell.y, game.gridSize, game.gridSize);
                }
            }
        }
        
        // ç»˜åˆ¶ç©å®¶
        function drawPlayer() {
            // åˆ›å»ºç©å®¶å›¾ç‰‡å…ƒç´ ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!game.playerImage) {
                game.playerImage = new Image();
                game.playerImage.src = 'tools/player.png';
            }
            
            // ç»˜åˆ¶ç©å®¶å›¾ç‰‡
            if (game.playerImage.complete) {
                game.ctx.save();
                game.ctx.translate(game.player.x, game.player.y);
                game.ctx.rotate((game.player.direction - 90) * Math.PI / 180);
                game.ctx.drawImage(
                    game.playerImage, 
                    -game.player.radius, 
                    -game.player.radius, 
                    game.player.radius * 2, 
                    game.player.radius * 2
                );
                game.ctx.restore();
            }
            
            // å¦‚æœç©å®¶æœ‰æŠ¤ç›¾ï¼Œç»˜åˆ¶æŠ¤ç›¾
            if (game.player.shield.active) {
                game.ctx.beginPath();
                game.ctx.arc(game.player.x, game.player.y, game.player.radius + 5, 0, Math.PI * 2);
                game.ctx.strokeStyle = 'rgba(100, 200, 255, 0.7)';
                game.ctx.lineWidth = 3;
                game.ctx.stroke();
                game.ctx.closePath();
            }
        }
        
        // ç»˜åˆ¶æ•Œäºº
        function drawEnemies() {
            // åˆ›å»ºæ•Œäººå›¾ç‰‡å…ƒç´ ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!game.enemyImage) {
                game.enemyImage = new Image();
                game.enemyImage.src = 'tools/xiaoguai.png';
            }
            
            for (const enemy of game.enemies) {
                if (game.enemyImage.complete) {
                    game.ctx.drawImage(
                        game.enemyImage, 
                        enemy.x - enemy.radius, 
                        enemy.y - enemy.radius, 
                        enemy.radius * 2, 
                        enemy.radius * 2
                    );
                }
                
                // ç»˜åˆ¶è¡€é‡
                game.ctx.fillStyle = 'white';
                game.ctx.font = '10px Arial';
                game.ctx.textAlign = 'center';
                game.ctx.fillText(enemy.health, enemy.x, enemy.y);
            }
        }
        
        // ç»˜åˆ¶Boss
        function drawBosses() {
            // åˆ›å»ºBosså›¾ç‰‡å…ƒç´ ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!game.bossImage) {
                game.bossImage = new Image();
                game.bossImage.src = 'tools/monster.png';
            }
            
            for (const boss of game.bosses) {
                if (game.bossImage.complete) {
                    game.ctx.drawImage(
                        game.bossImage, 
                        boss.x - boss.radius, 
                        boss.y - boss.radius, 
                        boss.radius * 2, 
                        boss.radius * 2
                    );
                }
                
                // ç»˜åˆ¶è¡€é‡
                game.ctx.fillStyle = 'white';
                game.ctx.font = '16px Arial';
                game.ctx.textAlign = 'center';
                game.ctx.fillText(boss.health, boss.x, boss.y);
            }
        }
        
        // ç»˜åˆ¶å­å¼¹
        function drawBullets() {
            for (const bullet of game.bullets) {
                game.ctx.beginPath();
                game.ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
                game.ctx.fillStyle = bullet.color;
                game.ctx.fill();
                game.ctx.closePath();
            }
        }
        
        // ç»˜åˆ¶æŠ€èƒ½
        function drawSkills() {
            for (const skill of game.skills) {
                if (skill.type === 'circle') {
                    game.ctx.beginPath();
                    game.ctx.arc(skill.x, skill.y, skill.radius, 0, Math.PI * 2);
                    game.ctx.fillStyle = skill.color;
                    game.ctx.fill();
                    game.ctx.closePath();
                } else if (skill.type === 'rectangle') {
                    // ä¿å­˜å½“å‰çŠ¶æ€
                    game.ctx.save();
                    
                    // å¹³ç§»åˆ°çŸ©å½¢ä¸­å¿ƒ
                    game.ctx.translate(skill.x + skill.width / 2, skill.y + skill.height / 2);
                    
                    // æ—‹è½¬
                    if (skill.angle !== undefined) {
                        game.ctx.rotate(skill.angle);
                    }
                    
                    // ç»˜åˆ¶çŸ©å½¢
                    game.ctx.fillStyle = skill.color;
                    game.ctx.fillRect(-skill.width / 2, -skill.height / 2, skill.width, skill.height);
                    
                    // æ¢å¤çŠ¶æ€
                    game.ctx.restore();
                }
            }
        }
        
        // æ¸¸æˆå¾ªç¯
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            update(deltaTime);
            draw();
            
            requestAnimationFrame(gameLoop);
        }
        
        // å¯åŠ¨æ¸¸æˆ
        window.onload = initGame;
    </script>



</body></html>