<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>æ–¹å—ç¯®çƒå¯¹å†³</title>
    <style>
        /* åŸºç¡€æ ·å¼é‡ç½® */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #333;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            overflow: hidden;
        }

        /* æ¸¸æˆä¸»å®¹å™¨ */
        #game-container {
            position: relative;
            width: 100%;
            max-width: 1000px;
            height: 600px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            background-color: #f0f8ff; /* æ·¡è“è‰²å¤©ç©ºèƒŒæ™¯ */
        }

        /* Canvasç”»å¸ƒ */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* é¡¶éƒ¨UIæ  */
        #ui-top {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            box-sizing: border-box;
            pointer-events: none; /* å…è®¸ç‚¹å‡»ç©¿é€ */
        }

        .score-board {
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
        }
        #player-score { color: #4a90e2; } /* ç©å®¶è“è‰² */
        #ai-score { color: #d0021b; } /* AIçº¢è‰² */

        #timer {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            background-color: rgba(0,0,0,0.4);
            padding: 5px 20px;
            border-radius: 10px;
            z-index: 10;
        }

        /* æŠ€èƒ½æŒ‰é’® */
        .skill-container {
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }

        .skill-button {
            position: relative;
            width: 150px;
            height: 50px;
            border: none;
            border-radius: 25px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .skill-button.skill-ready {
            background: linear-gradient(45deg, #FFD700, #FFA500);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.4);
        }
        .skill-button.skill-ready:hover { transform: scale(1.05); }

        .skill-button.skill-cooldown {
            background: #555;
            color: #aaa;
            cursor: not-allowed;
        }

        .skill-cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%; /* åˆå§‹ä¸º0 */
            background-color: rgba(40, 40, 40, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            transition: height 0.2s linear;
            pointer-events: none;
        }

        #steal-button {
            background: linear-gradient(45deg, #4CAF50, #8BC34A);
        }
        #steal-button.skill-cooldown {
            background: #555;
        }

        /* æ§åˆ¶æŒ‰é’®åŒºåŸŸ */
        #controls-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: grid;
            grid-template-areas:
                "jump jump"
                "left right";
            gap: 15px;
            z-index: 10;
        }
        
        .control-button {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.5);
            background-color: rgba(0,0,0,0.4);
            color: white;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none; /* é˜²æ­¢æ–‡æœ¬è¢«é€‰ä¸­ */
            transition: background-color 0.2s;
        }
        .control-button:active {
            background-color: rgba(0,0,0,0.6);
        }

        #left-button { grid-area: left; }
        #right-button { grid-area: right; }
        #jump-button { grid-area: jump; width: 100px; height: 100px; margin: 0 auto; }

        /* æŠ•ç¯®æŒ‰é’® */
        #shoot-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }

        #shoot-button {
            position: relative;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.5);
            background-color: rgba(217, 83, 79, 0.7); /* çº¢è‰²ç³» */
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            overflow: hidden;
        }
        #shoot-button:active {
            background-color: rgba(217, 83, 79, 0.9);
        }

        #charge-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 100%;
            width: 0%; /* åˆå§‹ä¸º0 */
            background-color: rgba(255, 235, 59, 0.6); /* é»„è‰²è“„åŠ›æ¡ */
            transition: width 0.1s linear;
        }

        /* æ¸¸æˆç»“æŸå¼¹çª— */
        #game-over-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none; /* é»˜è®¤éšè— */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #game-over-text {
            font-size: 72px;
            font-weight: bold;
            margin-bottom: 20px;
        }
        #final-score {
            font-size: 48px;
            margin-bottom: 40px;
        }
        #restart-button {
            padding: 15px 40px;
            font-size: 24px;
            cursor: pointer;
            border: 2px solid white;
            background-color: #4a90e2;
            color: white;
            border-radius: 10px;
            transition: background-color 0.3s;
        }
        #restart-button:hover {
            background-color: #357abd;
        }

        /* å“åº”å¼è®¾è®¡è°ƒæ•´ */
        @media (max-width: 768px) {
            .score-board, #timer {
                font-size: 32px;
            }
            
            .control-button {
                width: 60px;
                height: 60px;
            }
            
            #jump-button {
                width: 80px;
                height: 80px;
            }
            
            #shoot-button {
                width: 100px;
                height: 100px;
                font-size: 20px;
            }
            
            .skill-button {
                width: 120px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="ui-top">
            <div id="ai-score" class="score-board">0</div>
            
            <div class="skill-container" id="steal-container">
                <button id="steal-button" class="skill-button skill-ready">
                    æŠ¢æ–­
                    <span id="steal-cooldown-overlay" class="skill-cooldown-overlay"></span>
                </button>
            </div>
            
            <div id="timer">1:30</div>
            
            <div class="skill-container" id="teleport-container">
                <button id="teleport-button" class="skill-button skill-ready">
                    æ–—è½¬æ˜Ÿç§»
                    <span id="teleport-cooldown-overlay" class="skill-cooldown-overlay"></span>
                </button>
            </div>
            
            <div id="player-score" class="score-board">0</div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="controls-container">
            <div id="jump-button" class="control-button">è·³è·ƒ</div>
            <div id="left-button" class="control-button">â†</div>
            <div id="right-button" class="control-button">â†’</div>
        </div>

        <div id="shoot-container">
            <button id="shoot-button">
                æŠ•ç¯®
                <div id="charge-bar"></div>
            </button>
        </div>

        <div id="game-over-modal">
            <div id="game-over-text">æ¸¸æˆç»“æŸ</div>
            <div id="final-score"></div>
            <button id="restart-button">å†æ¥ä¸€å±€</button>
        </div>
    </div>

    <script>
        // --- DOMå…ƒç´ è·å– ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        
        const playerScoreEl = document.getElementById('player-score');
        const aiScoreEl = document.getElementById('ai-score');
        const timerEl = document.getElementById('timer');
        
        const teleportButton = document.getElementById('teleport-button');
        const teleportCooldownOverlay = document.getElementById('teleport-cooldown-overlay');
        const stealButton = document.getElementById('steal-button');
        const stealCooldownOverlay = document.getElementById('steal-cooldown-overlay');
        
        const leftButton = document.getElementById('left-button');
        const rightButton = document.getElementById('right-button');
        const jumpButton = document.getElementById('jump-button');
        const shootButton = document.getElementById('shoot-button');
        const chargeBar = document.getElementById('charge-bar');

        const gameOverModal = document.getElementById('game-over-modal');
        const gameOverTextEl = document.getElementById('game-over-text');
        const finalScoreEl = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');

        // --- æ¸¸æˆå°ºå¯¸ä¸å¸¸é‡ ---
        let canvasInitialized = false;
        const CANVAS_WIDTH = 1000;
        const CANVAS_HEIGHT = 600;
        const GROUND_Y = CANVAS_HEIGHT - 50;
        const GRAVITY = 0.6;
        const PLAYER_SPEED = 6;
        const JUMP_FORCE = -15;
        const TELEPORT_COOLDOWN_TIME = 15; // 15ç§’å†·å´
        const STEAL_COOLDOWN_TIME = 8; // 8ç§’å†·å´
        const GAME_DURATION = 90; // 90ç§’æ¸¸æˆæ—¶é—´
        const MAX_CHARGE_POWER = 100;
        const SHOOT_POWER_MULTIPLIER = 5; // æŠ•ç¯®åŠ›åº¦å€å¢å™¨ï¼Œ5å€åŠ›åº¦
        const AI_DECISION_RATE = 0.02; // AIå†³ç­–é¢‘ç‡
        const AI_SHOOT_ACCURACY = 0.7; // AIæŠ•ç¯®å‡†ç¡®åº¦
        const AI_STUCK_THRESHOLD = 2; // AIå¡ä½æ£€æµ‹é˜ˆå€¼ï¼ˆç§’ï¼‰
        const STEAL_DISTANCE = 100; // æŠ¢æ–­æœ‰æ•ˆè·ç¦»
        const STEAL_SUCCESS_CHANCE = 0.75; // æŠ¢æ–­æˆåŠŸç‡

        // --- æ¸¸æˆçŠ¶æ€ ---
        let game = {};
        let gameTimerInterval = null;

        function initCanvas() {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            canvasInitialized = true;
        }

        function resetGame() {
            if (!canvasInitialized) {
                initCanvas();
            }
            
            // æ¸…é™¤æ—§è®¡æ—¶å™¨
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
            }
            
            game = {
                player: {
                    x: CANVAS_WIDTH * 0.75, y: GROUND_Y - 50, // ç©å®¶åœ¨å³ä¾§
                    width: 50, height: 50,
                    vx: 0, vy: 0,
                    color: '#4a90e2',
                    onGround: true,
                    emoji: "ğŸ‘¨" // ä½¿ç”¨emojiè¡¨ç¤ºç©å®¶
                },
                ai: {
                    x: CANVAS_WIDTH * 0.25, y: GROUND_Y - 50, // AIåœ¨å·¦ä¾§
                    width: 50, height: 50,
                    vx: 0, vy: 0,
                    color: '#d0021b',
                    onGround: true,
                    lastMoveTime: 0, // ä¸Šæ¬¡ç§»åŠ¨æ—¶é—´
                    stuckTime: 0, // å¡ä½æ—¶é—´è®¡æ•°
                    emoji: "ğŸ¤–" // ä½¿ç”¨æœºå™¨äººemojiè¡¨ç¤ºAI
                },
                ball: {
                    x: CANVAS_WIDTH / 2, y: CANVAS_HEIGHT / 2,
                    radius: 15,
                    vx: 0, vy: 0,
                    color: '#f5a623',
                    owner: null
                },
                hoops: [
                    { 
                        x: 50, 
                        y: CANVAS_HEIGHT * 0.3, 
                        width: 120, 
                        height: 80, 
                        side: 'ai' 
                    }, // å·¦ä¾§ç¯®ç­(AIçš„)
                    { 
                        x: CANVAS_WIDTH - 170, 
                        y: CANVAS_HEIGHT * 0.3, 
                        width: 120, 
                        height: 80, 
                        side: 'player' 
                    } // å³ä¾§ç¯®ç­(ç©å®¶çš„)
                ],
                score: { player: 0, ai: 0 },
                gameTime: GAME_DURATION,
                isGameOver: false,
                keys: { left: false, right: false, jump: false },
                shooting: { isCharging: false, chargePower: 0, startTime: 0 },
                skills: { 
                    teleport: { isReady: true, cooldownTimer: 0 },
                    steal: { isReady: true, cooldownTimer: 0 }
                },
                lastTime: 0
            };
            
            // è®¾ç½®å€’è®¡æ—¶
            gameTimerInterval = setInterval(() => {
                if (game.gameTime > 0 && !game.isGameOver) {
                    game.gameTime--;
                    updateUI();
                } else if (!game.isGameOver) {
                    endGame();
                }
            }, 1000);
            
            updateUI();
            gameOverModal.style.display = 'none';
        }

        // --- ç‰©ç†ä¸æ›´æ–°é€»è¾‘ ---
        function updateEntity(entity) {
            // åº”ç”¨é‡åŠ›
            if (!entity.onGround) {
                entity.vy += GRAVITY;
            }
            // æ›´æ–°ä½ç½®
            entity.x += entity.vx;
            entity.y += entity.vy;
            // é€Ÿåº¦è¡°å‡
            entity.vx *= 0.9;

            // åœ°é¢ç¢°æ’
            const bottomY = entity.y + (entity.height || entity.radius * 2);
            if (bottomY >= GROUND_Y) {
                entity.y = GROUND_Y - (entity.height || entity.radius * 2);
                entity.vy = 0;
                entity.onGround = true;
            } else {
                entity.onGround = false;
            }

            // å¢™å£ç¢°æ’
            const leftEdge = entity.radius || 0;
            const rightEdge = entity.width || entity.radius * 2;
            
            if (entity.x - leftEdge < 0) entity.x = leftEdge;
            if (entity.x + rightEdge > CANVAS_WIDTH) entity.x = CANVAS_WIDTH - rightEdge;
        }

        function updateBall() {
            if (game.ball.owner) {
                // çƒè¢«æŒæœ‰ï¼Œè·ŸéšæŒæœ‰è€…
                game.ball.x = game.ball.owner.x + game.ball.owner.width / 2;
                game.ball.y = game.ball.owner.y - game.ball.radius;
                game.ball.vx = game.ball.owner.vx;
                game.ball.vy = 0;
            } else {
                // ç¯®çƒç‰©ç†
                game.ball.vy += GRAVITY * 0.8;
                game.ball.x += game.ball.vx;
                game.ball.y += game.ball.vy;
                game.ball.vx *= 0.99;

                // ç¯®çƒåœ°é¢åå¼¹
                if (game.ball.y + game.ball.radius >= GROUND_Y) {
                    game.ball.y = GROUND_Y - game.ball.radius;
                    game.ball.vy *= -0.6; // èƒ½é‡æŸå¤±
                }
                // ç¯®çƒå¢™å£åå¼¹
                if (game.ball.x - game.ball.radius < 0) {
                    game.ball.x = game.ball.radius;
                    game.ball.vx *= -0.8;
                } else if (game.ball.x + game.ball.radius > CANVAS_WIDTH) {
                    game.ball.x = CANVAS_WIDTH - game.ball.radius;
                    game.ball.vx *= -0.8;
                }
            }
        }

        function updateAI(deltaTime) {
            const { ai, ball, player, hoops } = game;
            const targetHoop = hoops[1]; // AIè¦æŠ•çš„æ˜¯å³ä¾§ç¯®ç­ï¼ˆç©å®¶çš„ç¯®ç­ï¼‰
            const aiHoop = hoops[0];     // AIè‡ªå·±çš„ç¯®ç­åœ¨å·¦ä¾§
            
            // è®°å½•AIæ˜¯å¦æœ‰ç§»åŠ¨
            const initialX = ai.x;
            
            if (ball.owner === ai) { // AIæŒçƒï¼Œè¿›æ”»
                // ç§»åŠ¨åˆ°ç¯®ä¸‹
                if (ai.x > targetHoop.x - 50) {
                    ai.vx = -PLAYER_SPEED * 0.6;
                } else if (ai.x < targetHoop.x - 200) {
                    ai.vx = PLAYER_SPEED * 0.6;
                } else {
                    // åœ¨ç¯®ä¸‹ï¼Œå‡†å¤‡æŠ•ç¯®
                    if (ai.onGround && Math.random() < AI_DECISION_RATE) { // éšæœºè·³è·ƒæŠ•ç¯®
                        ai.vy = JUMP_FORCE * 0.8;
                        setTimeout(() => {
                            if (ball.owner === ai) {
                                // AIæŠ•ç¯®
                                ball.owner = null;
                                const accuracy = Math.random() < AI_SHOOT_ACCURACY ? 1 : 0.8;
                                const targetX = targetHoop.x + targetHoop.width / 2;
                                const targetY = targetHoop.y + targetHoop.height / 3;
                                const dx = targetX - ball.x;
                                const dy = targetY - ball.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                // AIä½¿ç”¨5å€åŠ›åº¦
                                const power = distance * 0.05 * accuracy * SHOOT_POWER_MULTIPLIER;
                                const angle = Math.atan2(dy, dx);
                                
                                ball.vx = Math.cos(angle) * power;
                                ball.vy = Math.sin(angle) * power;
                            }
                        }, 300);
                    }
                }
            } else if (ball.owner === player) { // ç©å®¶æŒçƒï¼ŒAIé˜²å®ˆ
                // å‘ç©å®¶ç§»åŠ¨
                if (ai.x < player.x - 10) {
                    ai.vx = PLAYER_SPEED * 0.5;
                } else if (ai.x > player.x + 10) {
                    ai.vx = -PLAYER_SPEED * 0.5;
                }
                
                // éšæœºè·³è·ƒæ‹¦æˆª
                if (ai.onGround && Math.abs(ai.x - player.x) < 80 && Math.random() < AI_DECISION_RATE) {
                    ai.vy = JUMP_FORCE * 0.9;
                }
            } else { // æ— äººæŒçƒï¼ŒAIæŠ¢çƒ
                const dx = ball.x - (ai.x + ai.width / 2);
                const dy = ball.y - ai.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    // å‘çƒç§»åŠ¨
                    if (dx > 0) {
                        ai.vx = PLAYER_SPEED * 0.7;
                    } else {
                        ai.vx = -PLAYER_SPEED * 0.7;
                    }
                    
                    // é è¿‘æ—¶è·³è·ƒæŠ“çƒ
                    if (ai.onGround && Math.abs(dx) < 50 && dy < -30 && Math.random() < AI_DECISION_RATE * 2) {
                        ai.vy = JUMP_FORCE * 0.9;
                    }
                }
                
                // åœ¨è‡ªå·±ç¯®ç­é˜²å®ˆ
                if (ball.x < CANVAS_WIDTH / 2 && ai.x > CANVAS_WIDTH / 2) {
                    ai.vx = -PLAYER_SPEED * 0.8;
                }
            }
            
            // æ£€æµ‹AIæ˜¯å¦å¡ä½
            if (Math.abs(ai.x - initialX) < 0.5 && ai.onGround) {
                ai.stuckTime += deltaTime / 1000;
                
                // å¦‚æœAIå¡ä½è¶…è¿‡é˜ˆå€¼ï¼Œå¼ºåˆ¶ç§»åŠ¨
                if (ai.stuckTime > AI_STUCK_THRESHOLD) {
                    // æ ¹æ®åœºä¸Šä½ç½®å†³å®šç§»åŠ¨æ–¹å‘
                    if (ai.x < CANVAS_WIDTH / 4) {
                        ai.vx = PLAYER_SPEED; // å¦‚æœåœ¨å·¦è¾¹å››åˆ†ä¹‹ä¸€ï¼Œå‘å³ç§»åŠ¨
                    } else if (ai.x > CANVAS_WIDTH * 3/4) {
                        ai.vx = -PLAYER_SPEED; // å¦‚æœåœ¨å³è¾¹å››åˆ†ä¹‹ä¸€ï¼Œå‘å·¦ç§»åŠ¨
                    } else {
                        // å¦åˆ™ï¼Œéšæœºæ–¹å‘
                        ai.vx = (Math.random() > 0.5 ? 1 : -1) * PLAYER_SPEED;
                    }
                    
                    // æœ‰æ—¶éšæœºè·³è·ƒä»¥é¿å…å¡ä½
                    if (Math.random() < 0.3) {
                        ai.vy = JUMP_FORCE * 0.7;
                    }
                    
                    ai.stuckTime = 0; // é‡ç½®å¡ä½è®¡æ—¶å™¨
                }
            } else {
                ai.stuckTime = 0; // å¦‚æœç§»åŠ¨äº†ï¼Œé‡ç½®å¡ä½è®¡æ—¶å™¨
            }
        }

        // --- ç¢°æ’æ£€æµ‹ ---
        function checkCollisions() {
            const { player, ai, ball, hoops } = game;
            
            // çƒå‘˜ç¢°æ’
            if (checkRectCollision(player, ai)) {
                const pushForce = 2;
                if (player.x < ai.x) {
                    player.vx -= pushForce;
                    ai.vx += pushForce;
                } else {
                    player.vx += pushForce;
                    ai.vx -= pushForce;
                }
            }
            
            // çƒå’Œç©å®¶/AIç¢°æ’
            if (!ball.owner) {
                if (checkBallPlayerCollision(ball, player)) {
                    ball.owner = player;
                }
                if (checkBallPlayerCollision(ball, ai)) {
                    ball.owner = ai;
                }
            }
            
            // çƒå’Œç¯®ç­ç¢°æ’
            hoops.forEach(hoop => {
                if (checkBallHoopCollision(ball, hoop)) {
                    // å¾—åˆ†
                    if (hoop.side === 'player') {
                        game.score.ai++;
                    } else {
                        game.score.player++;
                    }
                    updateUI();
                    
                    // é‡ç½®çƒ
                    resetBall();
                }
            });
        }
        
        function checkRectCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }
        
        function checkBallPlayerCollision(ball, player) {
            // ç®€åŒ–çš„åœ†å½¢ä¸çŸ©å½¢ç¢°æ’
            const halfWidth = player.width / 2;
            const halfHeight = player.height / 2;
            
            const dx = Math.abs(ball.x - (player.x + halfWidth));
            const dy = Math.abs(ball.y - (player.y + halfHeight));
            
            if (dx > halfWidth + ball.radius || dy > halfHeight + ball.radius) {
                return false;
            }
            
            if (dx <= halfWidth || dy <= halfHeight) {
                return true;
            }
            
            const cornerDistSq = Math.pow(dx - halfWidth, 2) + Math.pow(dy - halfHeight, 2);
            return cornerDistSq <= Math.pow(ball.radius, 2);
        }
        
        function checkBallHoopCollision(ball, hoop) {
            // æ£€æŸ¥çƒæ˜¯å¦è¿›å…¥ç¯®ç­
            const hoopCenterX = hoop.x + hoop.width / 2;
            const hoopCenterY = hoop.y + hoop.height / 3;
            const hoopRadius = 25; // ç¯®ç­åŠå¾„
            
            const dx = ball.x - hoopCenterX;
            const dy = ball.y - hoopCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // çƒå¿…é¡»ä»ä¸Šæ–¹è¿›å…¥ç¯®ç­ï¼Œä¸”å¿…é¡»æœ‰å‘ä¸‹çš„é€Ÿåº¦
            return distance < hoopRadius && ball.vy > 0 && ball.y < hoopCenterY;
        }

        // --- ç©å®¶æ§åˆ¶ ---
        function handlePlayerInput() {
            const { player, keys, ball } = game;
            
            // ç§»åŠ¨
            if (keys.left) {
                player.vx = -PLAYER_SPEED;
            } else if (keys.right) {
                player.vx = PLAYER_SPEED;
            }
            
            // è·³è·ƒ
            if (keys.jump && player.onGround) {
                player.vy = JUMP_FORCE;
                player.onGround = false;
            }
        }
        
        // ä¿®å¤æŠ•ç¯®åŠŸèƒ½ï¼Œ5å€åŠ›åº¦ï¼Œç„å‡†æ–¹å‘ä¿®æ­£
        function shoot() {
            const { player, ball, shooting } = game;
            
            if (ball.owner === player && shooting.isCharging) {
                // é‡Šæ”¾çƒ
                ball.owner = null;
                
                // è®¡ç®—æŠ•ç¯®åŠ›é‡å’Œæ–¹å‘ï¼Œä½¿ç”¨5å€åŠ›åº¦
                const power = Math.min(shooting.chargePower, MAX_CHARGE_POWER) / 20 * SHOOT_POWER_MULTIPLIER;
                const targetHoop = game.hoops[0]; // ç©å®¶æŠ•çš„æ˜¯å·¦ä¾§ç¯®ç­(AIçš„ç¯®ç­)
                const targetX = targetHoop.x + targetHoop.width / 2;
                const targetY = targetHoop.y + targetHoop.height / 3;
                
                // è®¡ç®—ä»çƒåˆ°ç¯®ç­çš„å‘é‡
                const dx = targetX - ball.x;
                const dy = targetY - ball.y;
                const angle = Math.atan2(dy, dx);
                
                // è®¾ç½®çƒçš„é€Ÿåº¦
                ball.vx = Math.cos(angle) * power;
                ball.vy = Math.sin(angle) * power;
                
                // é‡ç½®è“„åŠ›
                shooting.isCharging = false;
                shooting.chargePower = 0;
                chargeBar.style.width = '0%';
            }
        }
        
        // ä¿®å¤æ–—è½¬æ˜Ÿç§»åŠŸèƒ½
        function useTeleportSkill() {
            if (!game.skills.teleport.isReady || game.isGameOver) return;
            
            // å®ç°æ–—è½¬æ˜Ÿç§»æŠ€èƒ½: äº¤æ¢ç©å®¶å’ŒAIçš„ä½ç½®
            const tempX = game.player.x;
            const tempY = game.player.y;
            const tempVx = game.player.vx;
            const tempVy = game.player.vy;
            const tempOnGround = game.player.onGround;
            
            game.player.x = game.ai.x;
            game.player.y = game.ai.y;
            game.player.vx = game.ai.vx;
            game.player.vy = game.ai.vy;
            game.player.onGround = game.ai.onGround;
            
            game.ai.x = tempX;
            game.ai.y = tempY;
            game.ai.vx = tempVx;
            game.ai.vy = tempVy;
            game.ai.onGround = tempOnGround;
            
            // å¦‚æœAIæŒæœ‰çƒï¼Œåˆ™è½¬ç§»ç»™ç©å®¶ï¼Œåä¹‹äº¦ç„¶
            if (game.ball.owner === game.ai) {
                game.ball.owner = game.player;
            } else if (game.ball.owner === game.player) {
                game.ball.owner = game.ai;
            }
            
            // è®¾ç½®æŠ€èƒ½å†·å´
            game.skills.teleport.isReady = false;
            game.skills.teleport.cooldownTimer = TELEPORT_COOLDOWN_TIME;
            
            // æ›´æ–°UI
            teleportButton.classList.remove('skill-ready');
            teleportButton.classList.add('skill-cooldown');
            
            updateTeleportCooldown();
        }

        // æ–°å¢æŠ¢æ–­æŠ€èƒ½
        function useStealSkill() {
            if (!game.skills.steal.isReady || game.isGameOver) return;
            
            const { player, ai, ball } = game;
            
            // è®¡ç®—ç©å®¶ä¸AIçš„è·ç¦»
            const dx = (player.x + player.width/2) - (ai.x + ai.width/2);
            const dy = (player.y + player.height/2) - (ai.y + ai.height/2);
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // åˆ¤æ–­æ˜¯å¦åœ¨æŠ¢æ–­æœ‰æ•ˆèŒƒå›´å†…
            if (distance <= STEAL_DISTANCE) {
                // å¦‚æœAIæŒçƒï¼Œæœ‰ä¸€å®šæ¦‚ç‡æŠ¢æ–­æˆåŠŸ
                if (ball.owner === ai && Math.random() < STEAL_SUCCESS_CHANCE) {
                    ball.owner = player;
                    
                    // äº§ç”Ÿä¸€ä¸ªå°çš„æ¨åŠ›ï¼Œè®©AIåé€€ä¸€ç‚¹
                    const pushDirection = dx > 0 ? -1 : 1;
                    ai.vx = pushDirection * PLAYER_SPEED * 0.5;
                }
            }
            
            // è®¾ç½®æŠ€èƒ½å†·å´
            game.skills.steal.isReady = false;
            game.skills.steal.cooldownTimer = STEAL_COOLDOWN_TIME;
            
            // æ›´æ–°UI
            stealButton.classList.remove('skill-ready');
            stealButton.classList.add('skill-cooldown');
            
            updateStealCooldown();
        }

        // --- æ¸¸æˆæ¸²æŸ“ ---
        function render() {
            // ç¡®ä¿Canvaså·²åˆå§‹åŒ–
            if (!canvasInitialized) {
                initCanvas();
            }
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            drawBackground();
            
            // ç»˜åˆ¶ç¯®ç­
            game.hoops.forEach(drawHoop);
            
            // ç»˜åˆ¶åœ°é¢
            drawGround();
            
            // ç»˜åˆ¶è§’è‰²
            drawCharacter(game.player);
            drawCharacter(game.ai);
            
            // ç»˜åˆ¶çƒ
            drawBall();
        }
        
        function drawBackground() {
            // å¤©ç©º
            const skyGradient = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
            skyGradient.addColorStop(0, '#87CEEB');
            skyGradient.addColorStop(1, '#E0F7FA');
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // äº‘æœµ
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            for (let i = 0; i < 5; i++) {
                const x = (canvas.width / 5) * i + 50;
                const y = 80 + (i % 2) * 50;
                const size = 40 + (i % 3) * 20;
                
                drawCloud(x, y, size);
            }
        }
        
        function drawCloud(x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size * 0.8, 0, Math.PI * 2);
            ctx.arc(x + size * 0.6, y - size * 0.2, size * 0.6, 0, Math.PI * 2);
            ctx.arc(x + size, y, size * 0.7, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
        }
        
        function drawGround() {
            // è‰åœ°
            ctx.fillStyle = '#4CAF50';
            ctx.fillRect(0, GROUND_Y, canvas.width, canvas.height - GROUND_Y);
            
            // åœºåœ°çº¿
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, GROUND_Y);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            
            // ä¸­å¿ƒåœ†
            ctx.beginPath();
            ctx.arc(canvas.width / 2, GROUND_Y + 30, 30, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        function drawHoop(hoop) {
            // ç¯®çƒæ¶æ”¯æŸ±
            ctx.fillStyle = '#795548';
            ctx.fillRect(hoop.x + hoop.width / 2 - 10, hoop.y + hoop.height, 20, GROUND_Y - (hoop.y + hoop.height));
            
            // ç¯®æ¿
            ctx.fillStyle = '#ECEFF1';
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 2;
            ctx.fillRect(hoop.x + 20, hoop.y, 80, 60);
            ctx.strokeRect(hoop.x + 20, hoop.y, 80, 60);
            
            // ç¯®ç­
            ctx.strokeStyle = '#FF5722';
            ctx.lineWidth = 4;
            ctx.beginPath();
            
            const hoopCenterX = hoop.x + hoop.width / 2;
            const hoopCenterY = hoop.y + hoop.height / 3;
            const hoopRadius = 25;
            
            // ç”»ç¯®åœˆ
            ctx.arc(hoopCenterX, hoopCenterY, hoopRadius, 0, Math.PI);
            ctx.stroke();
            
            // ç¯®ç½‘
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                const angle = (Math.PI / 8) * i;
                const startX = hoopCenterX + Math.cos(angle) * hoopRadius;
                const startY = hoopCenterY;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(startX, startY + 15);
                ctx.stroke();
            }
        }
        
        function drawCharacter(character) {
            // èƒŒæ™¯è‰²å—
            ctx.fillStyle = character.color;
            ctx.fillRect(character.x, character.y, character.width, character.height);
            
            // ç»˜åˆ¶emoji
            ctx.font = "30px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(
                character.emoji,
                character.x + character.width / 2,
                character.y + character.height / 2
            );
        }
        
        function drawBall() {
            const { ball } = game;
            
            // çƒä½“
            ctx.fillStyle = ball.color;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
            
            // çƒçš„æ¡çº¹
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.moveTo(ball.x - ball.radius, ball.y);
            ctx.lineTo(ball.x + ball.radius, ball.y);
            ctx.moveTo(ball.x, ball.y - ball.radius);
            ctx.lineTo(ball.x, ball.y + ball.radius);
            ctx.stroke();
        }

        // --- æ¸¸æˆUIæ›´æ–° ---
        function updateUI() {
            playerScoreEl.textContent = game.score.player;
            aiScoreEl.textContent = game.score.ai;
            
            const minutes = Math.floor(game.gameTime / 60);
            const seconds = game.gameTime % 60;
            timerEl.textContent = `${minutes}:${seconds < 10 ? '0' : ''}${seconds}`;
        }
        
        function updateTeleportCooldown() {
            if (!game.skills.teleport.isReady) {
                const percent = (game.skills.teleport.cooldownTimer / TELEPORT_COOLDOWN_TIME) * 100;
                teleportCooldownOverlay.style.height = `${100 - percent}%`;
                
                if (game.skills.teleport.cooldownTimer <= 0) {
                    game.skills.teleport.isReady = true;
                    teleportButton.classList.remove('skill-cooldown');
                    teleportButton.classList.add('skill-ready');
                    teleportCooldownOverlay.style.height = '0%';
                }
            }
        }
        
        function updateStealCooldown() {
            if (!game.skills.steal.isReady) {
                const percent = (game.skills.steal.cooldownTimer / STEAL_COOLDOWN_TIME) * 100;
                stealCooldownOverlay.style.height = `${100 - percent}%`;
                
                if (game.skills.steal.cooldownTimer <= 0) {
                    game.skills.steal.isReady = true;
                    stealButton.classList.remove('skill-cooldown');
                    stealButton.classList.add('skill-ready');
                    stealCooldownOverlay.style.height = '0%';
                }
            }
        }
        
        function resetBall() {
            game.ball.x = CANVAS_WIDTH / 2;
            game.ball.y = CANVAS_HEIGHT / 3;
            game.ball.vx = 0;
            game.ball.vy = 0;
            game.ball.owner = null;
        }

        // --- æ¸¸æˆæµç¨‹æ§åˆ¶ ---
        function gameLoop(timestamp) {
            if (!game.lastTime) game.lastTime = timestamp;
            const deltaTime = timestamp - game.lastTime;
            game.lastTime = timestamp;
            
            if (!game.isGameOver) {
                // æ›´æ–°ç©å®¶è¾“å…¥
                handlePlayerInput();
                
                // æ›´æ–°å®ä½“
                updateEntity(game.player);
                updateEntity(game.ai);
                updateBall();
                updateAI(deltaTime);
                
                // æ£€æµ‹ç¢°æ’
                checkCollisions();
                
                // è“„åŠ›æŠ•ç¯®
                if (game.shooting.isCharging) {
                    const elapsedTime = Date.now() - game.shooting.startTime;
                    game.shooting.chargePower = Math.min(elapsedTime / 10, MAX_CHARGE_POWER);
                    chargeBar.style.width = `${game.shooting.chargePower}%`;
                }
                
                // æŠ€èƒ½å†·å´
                if (!game.skills.teleport.isReady) {
                    game.skills.teleport.cooldownTimer -= deltaTime / 1000;
                    updateTeleportCooldown();
                }
                
                if (!game.skills.steal.isReady) {
                    game.skills.steal.cooldownTimer -= deltaTime / 1000;
                    updateStealCooldown();
                }
                
                // æ¸²æŸ“æ¸¸æˆ
                render();
                
                requestAnimationFrame(gameLoop);
            }
        }
        
        function startGame() {
            resetGame();
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            game.isGameOver = true;
            if (gameTimerInterval) {
                clearInterval(gameTimerInterval);
            }
            
            // æ˜¾ç¤ºç»“æŸå¼¹çª—
            const playerWon = game.score.player > game.score.ai;
            const isDraw = game.score.player === game.score.ai;
            
            gameOverTextEl.textContent = isDraw ? 'å¹³å±€ï¼' : (playerWon ? 'ä½ èµ¢äº†ï¼' : 'ä½ è¾“äº†ï¼');
            finalScoreEl.textContent = `${game.score.player} - ${game.score.ai}`;
            gameOverModal.style.display = 'flex';
        }

        // --- äº‹ä»¶ç›‘å¬ ---
        // é”®ç›˜æ§åˆ¶
        window.addEventListener('keydown', (e) => {
            if (game.isGameOver) return;
            
            switch (e.key) {
                case 'a':
                case 'ArrowLeft':
                    game.keys.left = true;
                    game.keys.right = false;
                    break;
                case 'd':
                case 'ArrowRight':
                    game.keys.right = true;
                    game.keys.left = false;
                    break;
                case 'w':
                case 'ArrowUp':
                case ' ':
                    game.keys.jump = true;
                    break;
                case 's':
                case 'ArrowDown':
                    if (game.ball.owner === game.player && !game.shooting.isCharging) {
                        game.shooting.isCharging = true;
                        game.shooting.startTime = Date.now();
                    }
                    break;
                case 'q':
                    useTeleportSkill();
                    break;
                case 'e':
                    useStealSkill();
                    break;
            }
        });
        
        window.addEventListener('keyup', (e) => {
            switch (e.key) {
                case 'a':
                case 'ArrowLeft':
                    game.keys.left = false;
                    break;
                case 'd':
                case 'ArrowRight':
                    game.keys.right = false;
                    break;
                case 'w':
                case 'ArrowUp':
                case ' ':
                    game.keys.jump = false;
                    break;
                case 's':
                case 'ArrowDown':
                    shoot();
                    break;
            }
        });
        
        // ç§»åŠ¨æ§åˆ¶æŒ‰é’®
        leftButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            game.keys.left = true;
            game.keys.right = false;
        });
        
        leftButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            game.keys.left = false;
        });
        
        rightButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            game.keys.right = true;
            game.keys.left = false;
        });
        
        rightButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            game.keys.right = false;
        });
        
        jumpButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            game.keys.jump = true;
        });
        
        jumpButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            game.keys.jump = false;
        });
        
        // æŠ•ç¯®æŒ‰é’®
        shootButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (game.ball.owner === game.player && !game.shooting.isCharging) {
                game.shooting.isCharging = true;
                game.shooting.startTime = Date.now();
            }
        });
        
        shootButton.addEventListener('touchend', (e) => {
            e.preventDefault();
            shoot();
        });
        
        // ç‚¹å‡»äº‹ä»¶ï¼ŒåŒæ—¶æ”¯æŒé¼ æ ‡ç‚¹å‡»å’Œè§¦æ‘¸
        shootButton.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (game.ball.owner === game.player && !game.shooting.isCharging) {
                game.shooting.isCharging = true;
                game.shooting.startTime = Date.now();
            }
        });
        
        shootButton.addEventListener('mouseup', (e) => {
            e.preventDefault();
            shoot();
        });
        
        // æŠ€èƒ½æŒ‰é’®
        teleportButton.addEventListener('click', useTeleportSkill);
        stealButton.addEventListener('click', useStealSkill);
        
        // é‡æ–°å¼€å§‹æ¸¸æˆæŒ‰é’®
        restartButton.addEventListener('click', startGame);
        
        // çª—å£è°ƒæ•´å¤§å°å¤„ç†
        window.addEventListener('resize', () => {
            // ä¿æŒç”»å¸ƒä¸å®¹å™¨å¤§å°ä¸€è‡´
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            render(); // é‡æ–°æ¸²æŸ“
        });

        // --- åˆå§‹åŒ–æ¸¸æˆ ---
        initCanvas(); // ç¡®ä¿Canvasåˆå§‹åŒ–
        startGame();
    </script>
</body>
</html>