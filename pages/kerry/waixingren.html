<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ€åé˜²çº¿: ä¿®å¤ç‰ˆ</title>
    <style>
        /* å¼ºåˆ¶ç¦æ­¢é¡µé¢æ»šåŠ¨å’Œç¼©æ”¾ */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            touch-action: none; -webkit-touch-callout: none;
            font-family: Arial, sans-serif;
        }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UIå±‚ - å¿…é¡»è®¾ç½®z-indexé«˜äºCanvas */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 100; pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ç©ºç™½åŒºåŸŸ */
        }
        
        /* å…è®¸UIå…ƒç´ æ¥æ”¶ç‚¹å‡» */
        .interactive { pointer-events: auto; }

        /* è°ƒè¯•æ—¥å¿— */
        #debug-log {
            position: absolute; top: 50px; left: 20px; color: yellow; 
            font-size: 14px; z-index: 101; pointer-events: none;
            background: rgba(0,0,0,0.5); padding: 5px;
        }

        /* æ‘‡æ†åŒºåŸŸ - åŠé€æ˜èƒŒæ™¯æ–¹ä¾¿è°ƒè¯• */
        .joystick-zone {
            position: absolute; bottom: 40px; width: 140px; height: 140px;
            background: rgba(255, 255, 255, 0.1); border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex; justify-content: center; align-items: center;
        }
        #stick-left { left: 40px; }
        #stick-right { right: 40px; }

        /* æ‘‡æ†å¤´ */
        .stick-knob {
            width: 60px; height: 60px; background: rgba(255, 255, 255, 0.5);
            border-radius: 50%; position: absolute;
            transform: translate(0, 0); /* åˆå§‹ä½ç½® */
        }

        /* æŒ‰é’®ç»„ */
        .btn {
            position: absolute; background: rgba(255, 255, 255, 0.2); 
            border: 2px solid #fff; border-radius: 50%; 
            color: white; font-weight: bold; font-size: 14px;
            display: flex; justify-content: center; align-items: center;
            user-select: none;
        }
        .btn:active, .btn.active { background: rgba(255, 255, 255, 0.6); transform: scale(0.95); }

        /* æŒ‰é’®ä½ç½®è°ƒæ•´ */
        #btn-fire { bottom: 80px; right: 200px; width: 80px; height: 80px; background: rgba(255, 50, 50, 0.4); border-color: red; }
        #btn-reload { bottom: 200px; right: 60px; width: 60px; height: 60px; }
        #btn-switch { bottom: 200px; right: 140px; width: 60px; height: 60px; }
        #btn-scope { display: none; bottom: 280px; right: 40px; width: 70px; height: 70px; background: rgba(0, 255, 255, 0.3); }

        /* HUD */
        #hud-top { 
            position: absolute; top: 10px; left: 10px; width: 100%;
            color: white; font-size: 16px; pointer-events: none;
            text-shadow: 1px 1px 2px #000;
        }

        /* é€‰æªç•Œé¢ */
        #selection-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 200; 
            display: flex; flex-direction: column; align-items: center; 
            overflow-y: auto; padding-top: 20px;
        }
        .weapon-card {
            background: #333; margin: 8px; padding: 15px; border-radius: 8px; width: 80%; 
            border: 2px solid #555; color: white; display: flex; justify-content: space-between;
        }
        .weapon-card.selected { border-color: #0f0; background: #445544; }
        #start-btn {
            margin: 20px; padding: 20px 50px; font-size: 24px; background: #555; 
            color: white; border: none; border-radius: 10px; pointer-events: none;
        }
        #start-btn.active { background: #007aff; pointer-events: auto; }
        
        /* å‡†å¿ƒ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid white; border-radius: 50%; transform: translate(-50%, -50%);
            pointer-events: none; opacity: 0.7;
        }

        #lock-box {
            position: absolute;
            width: 50px;
            height: 50px;
            border: 2px solid red;
            pointer-events: none;
            display: none;
        }

        .enemy-hp {
            position: absolute;
            width: 40px;
            height: 6px;
            background: #400;
            pointer-events: none;
            z-index: 10;
        }
        .enemy-hp .hp-inner {
            height: 100%;
            background: red;
            width: 100%;
        }
    </style>
    <!-- å¼•å…¥ç¨³å®šç‰ˆæœ¬çš„ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>
    
    <!-- UIå±‚ -->
    <div id="ui-layer">
        <div id="debug-log">ç­‰å¾…å¼€å§‹...</div>
        <div id="hud-top">
            HP: <span id="hp">100</span> | <span id="wp-name">--</span> | <span id="ammo">--</span> | Wave: <span id="wave">1</span>
        </div>
        <div id="crosshair"></div>
        <div id="lock-box"></div>

        <!-- æ‘‡æ† -->
        <div id="stick-left" class="joystick-zone interactive">
            <div class="stick-knob"></div>
        </div>
        <div id="stick-right" class="joystick-zone interactive">
            <div class="stick-knob"></div>
        </div>

        <!-- æŒ‰é’® -->
        <div id="btn-fire" class="btn interactive">å°„å‡»</div>
        <div id="btn-reload" class="btn interactive">æ¢å¼¹</div>
        <div id="btn-switch" class="btn interactive">åˆ‡æª</div>
        <div id="btn-scope" class="btn interactive">ç„å‡†</div>
    </div>

    <!-- é€‰æªç•Œé¢ -->
    <div id="selection-screen">
        <h2 style="color:white">é€‰æ‹©2æŠŠæ­¦å™¨ (ç‚¹å‡»é€‰æ‹©)</h2>
        <div class="weapon-card interactive" onclick="selectWeapon(0, this)">
            <div><strong>1. ç‹™å‡»æª</strong><br><small>å°„é€Ÿæ…¢ | é«˜ä¼¤ | æœ‰ç„å…·</small></div>
        </div>
        <div class="weapon-card interactive" onclick="selectWeapon(1, this)">
            <div><strong>2. å†²é”‹æª</strong><br><small>å°„é€Ÿå¿« | ä¼¤å®³ä½ | 60å‘</small></div>
        </div>
        <div class="weapon-card interactive" onclick="selectWeapon(2, this)">
            <div><strong>3. é›·ç”µæª</strong><br><small>é—ªç”µè¿é”ä¼¤å®³</small></div>
        </div>
        <div class="weapon-card interactive" onclick="selectWeapon(3, this)">
            <div><strong>4. åŠ ç‰¹æ—</strong><br><small>è¶…å¿«å°„é€Ÿ | 500å‘</small></div>
        </div>
        <div class="weapon-card interactive" onclick="selectWeapon(4, this)">
            <div><strong>5. ç«ç®­ç‚®</strong><br><small>çˆ†ç‚¸èŒƒå›´ä¼¤å®³</small></div>
        </div>
        <button id="start-btn" class="interactive" onclick="startGame()">å¼€å§‹æˆ˜æ–—</button>
    </div>

<script>
    // --- è°ƒè¯•å·¥å…· ---
    function log(msg) {
        document.getElementById('debug-log').innerText = msg;
        console.log(msg);
    }

    // --- å…¨å±€å˜é‡ ---
    const GAME = {
        scene: null, camera: null, renderer: null,
        player: null,
        bullets: [], enemies: [], allies: [], particles: [],
        lastTime: 0,
        inputs: { move: {x:0, y:0}, aim: {x:0, y:0}, fire: false },
        weapons: [],
        selectedIndices: [],
        currentIdx: 0,
        isScoped: false,
        enemyTimer: 0,
        isPlaying: false,
        hp: 100,
        wave: 1,
        waveEnemies: 0,
        waveTotal: 5
    };

    const WEAPONS_DATA = [
        { name: "ç‹™å‡»æª", dmg: 100, rate: 1.5, mag: 6, type: 'hitscan', sniper: true },
        { name: "å†²é”‹æª", dmg: 10, rate: 0.1, mag: 60, type: 'hitscan' },
        { name: "é›·ç”µæª", dmg: 40, rate: 0.8, mag: 6, type: 'chain' },
        { name: "åŠ ç‰¹æ—", dmg: 5, rate: 0.05, mag: 500, type: 'hitscan' },
        { name: "ç«ç®­ç‚®", dmg: 0, rate: 1.5, mag: 5, type: 'rocket', radius: 20 }
    ];

    // è·å–æœ€è¿‘æ•Œäººçš„å‡½æ•°
    function getNearestEnemy(maxDist = 25) {
        let best = null;
        let min = maxDist;

        GAME.enemies.forEach(en => {
            const d = en.position.distanceTo(GAME.player.position);
            if (d < min) {
                min = d;
                best = en;
            }
        });
        return best;
    }

    // --- é€‰æªé€»è¾‘ ---
    function selectWeapon(id, el) {
        if (GAME.selectedIndices.includes(id)) {
            GAME.selectedIndices = GAME.selectedIndices.filter(i => i !== id);
            el.classList.remove('selected');
        } else {
            if (GAME.selectedIndices.length < 2) {
                GAME.selectedIndices.push(id);
                el.classList.add('selected');
            }
        }
        
        const btn = document.getElementById('start-btn');
        if (GAME.selectedIndices.length === 2) {
            btn.classList.add('active');
            btn.innerText = "ç‚¹å‡»å¼€å§‹";
        } else {
            btn.classList.remove('active');
            btn.innerText = `å·²é€‰ ${GAME.selectedIndices.length}/2`;
        }
    }

    function startGame() {
        if (GAME.selectedIndices.length !== 2) return;
        document.getElementById('selection-screen').style.display = 'none';
        
        // åˆå§‹åŒ–æ­¦å™¨æ•°æ®
        GAME.selectedIndices.forEach(idx => {
            const proto = WEAPONS_DATA[idx];
            GAME.weapons.push({
                ...proto,
                curAmmo: proto.mag,
                lastFire: 0
            });
        });

        initThreeJS();
        log("æ¸¸æˆå·²å¯åŠ¨ - æ»‘åŠ¨æ‘‡æ†ç§»åŠ¨");
    }

    // --- è¾“å…¥æ§åˆ¶ (Pointer Events - å…¼å®¹é¼ æ ‡å’Œè§¦æ‘¸) ---
    function setupJoystick(zoneId, knobClass, inputObjKey) {
        const zone = document.getElementById(zoneId);
        const knob = zone.querySelector('.stick-knob');
        let startX = 0, startY = 0;
        let dragging = false;
        const maxDist = 40; // æ‘‡æ†æœ€å¤§ç§»åŠ¨è·ç¦»

        // æŒ‡é’ˆæŒ‰ä¸‹
        zone.addEventListener('pointerdown', (e) => {
            dragging = true;
            zone.setPointerCapture(e.pointerId); // é”å®šæŒ‡é’ˆ
            const rect = zone.getBoundingClientRect();
            // è®¡ç®—ä¸­å¿ƒç‚¹
            startX = rect.left + rect.width / 2;
            startY = rect.top + rect.height / 2;
            updateStick(e);
        });

        // æŒ‡é’ˆç§»åŠ¨
        zone.addEventListener('pointermove', (e) => {
            if (!dragging) return;
            updateStick(e);
        });

        // æŒ‡é’ˆæ¾å¼€
        zone.addEventListener('pointerup', (e) => {
            dragging = false;
            knob.style.transform = `translate(0px, 0px)`;
            GAME.inputs[inputObjKey] = { x: 0, y: 0 };
        });

        function updateStick(e) {
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const clampedDist = Math.min(dist, maxDist);
            const angle = Math.atan2(dy, dx);
            
            const moveX = Math.cos(angle) * clampedDist;
            const moveY = Math.sin(angle) * clampedDist;

            knob.style.transform = `translate(${moveX}px, ${moveY}px)`;
            
            // è¾“å‡º -1 åˆ° 1 çš„å€¼
            GAME.inputs[inputObjKey] = { 
                x: moveX / maxDist, 
                y: moveY / maxDist 
            };
        }
    }

    // --- æŒ‰é’®ç»‘å®š ---
    function setupButtons() {
        const btnFire = document.getElementById('btn-fire');
        btnFire.addEventListener('pointerdown', (e) => {
            e.preventDefault(); 
            GAME.inputs.fire = true; 
            btnFire.classList.add('active');
            log("å¼€ç«!");
        });
        btnFire.addEventListener('pointerup', (e) => { 
            GAME.inputs.fire = false; 
            btnFire.classList.remove('active');
        });

        document.getElementById('btn-switch').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            GAME.currentIdx = (GAME.currentIdx + 1) % 2;
            GAME.isScoped = false; // åˆ‡æªå…³é•œ
            updateUI();
            log("åˆ‡æ¢æ­¦å™¨: " + GAME.weapons[GAME.currentIdx].name);
        });

        document.getElementById('btn-reload').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            const wp = GAME.weapons[GAME.currentIdx];
            wp.curAmmo = wp.mag;
            updateUI();
            log("è£…å¼¹å®Œæˆ");
        });

        document.getElementById('btn-scope').addEventListener('pointerdown', (e) => {
            e.preventDefault();
            GAME.isScoped = !GAME.isScoped;
            log(GAME.isScoped ? "å¼€é•œ" : "å…³é•œ");
            updateUI();
        });
    }

    // --- Three.js æ ¸å¿ƒé€»è¾‘ ---
    function initThreeJS() {
        GAME.scene = new THREE.Scene();
        GAME.scene.background = new THREE.Color(0x1a1a1a);
        GAME.scene.fog = new THREE.Fog(0x1a1a1a, 10, 80);

        // ç›¸æœº
        GAME.camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // æ¸²æŸ“å™¨
        GAME.renderer = new THREE.WebGLRenderer({ antialias: true });
        GAME.renderer.setSize(window.innerWidth, window.innerHeight);
        GAME.renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(GAME.renderer.domElement);

        // ç¯å…‰ - åˆ›å»ºæ›´ç¬¦åˆå¤–æ˜Ÿåœºæ™¯çš„æ°›å›´
        const amb = new THREE.AmbientLight(0x44ff44, 0.3); // ç»¿è‰²ç¯å¢ƒå…‰
        GAME.scene.add(amb);

        const dir = new THREE.DirectionalLight(0x88ff88, 0.7);
        dir.position.set(20, 50, 20);
        dir.castShadow = true;
        GAME.scene.add(dir);

        // æ·»åŠ ç‚¹å…‰æºä½œä¸ºè¡¥å…‰
        const pointLight = new THREE.PointLight(0x00aaff, 0.5, 30);
        pointLight.position.set(0, 10, 0);
        GAME.scene.add(pointLight);

        // åœ°é¢
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(200, 200),
            new THREE.MeshStandardMaterial({
                color: 0x223322, // æ›´æ·±çš„ç»¿è‰²ï¼Œæ¨¡æ‹Ÿå¤–æ˜Ÿç¯å¢ƒ
                wireframe: false
            })
        );
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        GAME.scene.add(plane);

        // æ·»åŠ ä¸€äº›ç¯å¢ƒè£…é¥° - æ¨¡æ‹Ÿå¤–æ˜Ÿçƒè¡¨é¢
        for (let i = 0; i < 50; i++) {
            const rock = new THREE.Mesh(
                new THREE.DodecahedronGeometry(0.3, 0),
                new THREE.MeshLambertMaterial({ color: 0x556655 })
            );
            rock.position.set(
                (Math.random() - 0.5) * 180,
                0.3,
                (Math.random() - 0.5) * 180
            );
            GAME.scene.add(rock);
        }

        // ç½‘æ ¼è¾…åŠ©
        const gridHelper = new THREE.GridHelper(200, 50, 0x335533, 0x224422);
        GAME.scene.add(gridHelper);

        // ç©å®¶é£èˆ¹
        const playerGroup = new THREE.Group();

        // é£èˆ¹ä¸»ä½“
        const shipBody = new THREE.Mesh(
            new THREE.ConeGeometry(0.8, 2, 8),
            new THREE.MeshLambertMaterial({ color: 0x00aaff })
        );
        shipBody.rotation.x = Math.PI / 2;

        // é£èˆ¹ç¿¼
        const wing = new THREE.Mesh(
            new THREE.BoxGeometry(2, 0.1, 0.5),
            new THREE.MeshLambertMaterial({ color: 0x0088cc })
        );

        // é£èˆ¹é¡¶éƒ¨
        const top = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 16, 16),
            new THREE.MeshLambertMaterial({ color: 0x00ccff })
        );
        top.position.y = 0.8;

        playerGroup.add(shipBody);
        playerGroup.add(wing);
        playerGroup.add(top);

        playerGroup.position.y = 2; // ç¨å¾®é«˜ä¸€ç‚¹
        playerGroup.castShadow = true;
        GAME.scene.add(playerGroup);
        GAME.player = playerGroup;

        // ç”Ÿæˆå†›é˜Ÿ
        for(let i=0; i<10; i++) {
            const angle = (i / 10) * Math.PI * 2;
            const ally = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 1.5, 8),
                new THREE.MeshLambertMaterial({ color: 0x0000ff })
            );
            ally.position.set(Math.cos(angle)*5, 0.75, Math.sin(angle)*5);
            ally.userData = { lastShot: 0, rate: 2.0 }; // å‹å†›æ•°æ®
            GAME.scene.add(ally);
            GAME.allies.push(ally);
        }

        // å¯åŠ¨è¾“å…¥
        setupJoystick('stick-left', 'stick-knob', 'move');
        setupJoystick('stick-right', 'stick-knob', 'aim');
        setupButtons();

        // å¯åŠ¨å¾ªç¯
        GAME.isPlaying = true;

        // æ¸¸æˆå¼€å§‹æ—¶ç”Ÿæˆ3ä¸ªå¤–æ˜Ÿäººä¾¿äºæµ‹è¯•
        for (let i = 0; i < 3; i++) {
            setTimeout(() => spawnEnemy(), i * 1000); // æ¯ç§’ç”Ÿæˆä¸€ä¸ª
        }

        updateUI();
        animate();
    }

    function spawnEnemy() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 12 + Math.random() * 4;
        const x = Math.sin(angle) * dist + GAME.player.position.x;
        const z = Math.cos(angle) * dist + GAME.player.position.z;

        // åˆ›å»ºå¤–æ˜Ÿäººç»„
        const alienGroup = new THREE.Group();

        // èº«ä½“
        const body = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.6, 1.8, 4, 8),
            new THREE.MeshStandardMaterial({
                color: 0x00ff00,
                emissive: 0x00ff00,
                emissiveIntensity: 0.6
            })
        );
        body.position.y = 1.5; // é‡è¦ï¼šå°†èº«ä½“æŠ¬é«˜

        // å¤´éƒ¨
        const head = new THREE.Mesh(
            new THREE.SphereGeometry(0.5, 16, 16),
            new THREE.MeshLambertMaterial({
                color: 0x00cc00,
                emissive: 0x008800
            })
        );
        head.position.y = 2.5; // å¤´éƒ¨ä½ç½®è°ƒæ•´

        // çœ¼ç›
        const eye1 = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 16, 16),
            new THREE.MeshLambertMaterial({
                color: 0xff0000,
                emissive: 0xaa0000
            })
        );
        eye1.position.set(0.2, 2.6, 0.4);

        const eye2 = eye1.clone();
        eye2.position.set(-0.2, 2.6, 0.4);

        // åœ°é¢æ ‡è®°ç¯
        const ring = new THREE.Mesh(
            new THREE.RingGeometry(0.8, 1.0, 32),
            new THREE.MeshBasicMaterial({
                color: 0xff0000,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            })
        );
        ring.rotation.x = -Math.PI / 2;
        ring.position.y = 0.1;

        // æ·»åŠ æ‰€æœ‰éƒ¨ä»¶åˆ°ç»„
        alienGroup.add(body);
        alienGroup.add(head);
        alienGroup.add(eye1);
        alienGroup.add(eye2);
        alienGroup.add(ring);

        // è®¾ç½®ç»„çš„ä½ç½®
        alienGroup.position.set(x, 0, z); // yè®¾ä¸º0ï¼Œå› ä¸ºéƒ¨ä»¶å·²ç»æœ‰é«˜åº¦äº†

        // æ·»åŠ æ•°æ®
        alienGroup.userData = {
            hp: 50,
            maxHp: 50,
            speed: 4,
            type: 'alien'
        };

        // åˆ›å»ºè¡€æ¡
        const hpBar = document.createElement('div');
        hpBar.className = 'enemy-hp';
        hpBar.innerHTML = '<div class="hp-inner"></div>';
        document.body.appendChild(hpBar);
        alienGroup.userData.hpBar = hpBar;

        GAME.scene.add(alienGroup);
        GAME.enemies.push(alienGroup);

        // æ·»åŠ è°ƒè¯•ä¿¡æ¯
        log("å¤–æ˜Ÿäººå‡ºç°! å½“å‰æ•°é‡: " + GAME.enemies.length);
    }

    function animate() {
        requestAnimationFrame(animate);
        if (!GAME.isPlaying) return;

        const now = performance.now() / 1000;
        const dt = 0.016; // ç®€åŒ–dt

        // 1. ç©å®¶ç§»åŠ¨
        const moveSpd = 10 * dt;
        const camDir = new THREE.Vector3();
        GAME.camera.getWorldDirection(camDir);
        camDir.y = 0; camDir.normalize();
        const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0,1,0));

        GAME.player.position.addScaledVector(camRight, GAME.inputs.move.x * moveSpd);
        GAME.player.position.addScaledVector(camDir, -GAME.inputs.move.y * moveSpd);

        // å†›é˜Ÿè·Ÿéš (ä¿æŒæ–¹é˜µ)
        GAME.allies.forEach((ally, i) => {
            const angle = (i / 10) * Math.PI * 2;
            ally.position.x += (GAME.player.position.x + Math.cos(angle)*5 - ally.position.x) * 0.1;
            ally.position.z += (GAME.player.position.z + Math.sin(angle)*5 - ally.position.z) * 0.1;
        });

        // 2. ç©å®¶/æ‘„åƒæœºæ—‹è½¬
        const rotSpd = 2.0 * dt;
        GAME.player.rotation.y -= GAME.inputs.aim.x * rotSpd;

        // æ‘„åƒæœºé€»è¾‘
        if (GAME.isScoped) {
            GAME.camera.fov = 15;
            // ç„å‡†è§†è§’
            const offset = new THREE.Vector3(0.5, 1.8, 1.0).applyMatrix4(GAME.player.matrixWorld);
            GAME.camera.position.lerp(offset, 0.5);
            const target = new THREE.Vector3(0, 1.8, -20).applyMatrix4(GAME.player.matrixWorld);
            GAME.camera.lookAt(target);
        } else {
            GAME.camera.fov = 70;
            // ç¬¬ä¸‰äººç§°
            const targetPos = new THREE.Vector3(0, 5, 8).applyMatrix4(GAME.player.matrixWorld);
            if (targetPos.y < 1) targetPos.y = 1; // é˜²ç©¿åœ°
            GAME.camera.position.lerp(targetPos, 0.2);
            GAME.camera.lookAt(GAME.player.position.x, GAME.player.position.y+2, GAME.player.position.z);
        }
        GAME.camera.updateProjectionMatrix();

        // ğŸ”’ è‡ªåŠ¨é”å®šæœ€è¿‘æ•Œäºº
        const target = getNearestEnemy();
        if (target) {
            const dir = new THREE.Vector3().subVectors(target.position, GAME.player.position);
            const targetAngle = Math.atan2(dir.x, dir.z);
            GAME.player.rotation.y += (targetAngle - GAME.player.rotation.y) * 0.05;

            // UI é”å®šæ¡†
            const pos = target.position.clone();
            pos.y += 2;
            pos.project(GAME.camera);

            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;

            const box = document.getElementById('lock-box');
            box.style.left = `${x - 25}px`;
            box.style.top = `${y - 25}px`;
            box.style.display = 'block';
        } else {
            document.getElementById('lock-box').style.display = 'none';
        }

        // 3. å°„å‡»
        const wp = GAME.weapons[GAME.currentIdx];
        if (GAME.inputs.fire && now - wp.lastFire > wp.rate && wp.curAmmo > 0) {
            wp.lastFire = now;
            wp.curAmmo--;
            shootLogic(wp, GAME.player.position, GAME.player.quaternion, true); // true = isPlayer
            updateUI();
        }

        // 4. å†›é˜Ÿè‡ªåŠ¨æ”»å‡»
        GAME.allies.forEach(ally => {
            if (now - ally.userData.lastShot > ally.userData.rate) {
                // æ‰¾æœ€è¿‘æ•Œäºº
                let closest = null, minDist = 20;
                GAME.enemies.forEach(en => {
                    const d = ally.position.distanceTo(en.position);
                    if (d < minDist) { minDist = d; closest = en; }
                });
                if (closest) {
                    ally.userData.lastShot = now;
                    ally.lookAt(closest.position);
                    shootLogic({ type: 'hitscan', dmg: 20 }, ally.position, ally.quaternion, false);
                    createTracer(ally.position, closest.position);
                }
            }
        });

        // 5. æ•Œäººç”Ÿæˆä¸ç§»åŠ¨
        GAME.enemyTimer += dt;
        if (GAME.enemyTimer > 1.5 && GAME.waveEnemies < GAME.waveTotal) { // 1.5ç§’ç”Ÿä¸€ä¸ªï¼Œé™åˆ¶æ¯æ³¢æ•°é‡
            GAME.enemyTimer = 0;
            spawnEnemy();
            GAME.waveEnemies++;
        }

        // æ³¢æ¬¡ç»“æŸæ£€æµ‹
        if (GAME.enemies.length === 0 && GAME.waveEnemies >= GAME.waveTotal) {
            GAME.wave++;
            GAME.waveEnemies = 0;
            GAME.waveTotal += 3; // æ¯æ³¢æ›´å¤šæ•Œäºº
            log(`ç¬¬ ${GAME.wave} æ³¢å¼€å§‹!`);
        }

        GAME.enemies.forEach((en, i) => {
            // å¤–æ˜Ÿäººç§»åŠ¨AI
            const dir = new THREE.Vector3().subVectors(GAME.player.position, en.position).normalize();
            en.position.addScaledVector(dir, en.userData.speed * dt);

            // å¤–æ˜Ÿäººæœå‘ç©å®¶
            en.lookAt(new THREE.Vector3(GAME.player.position.x, en.position.y, GAME.player.position.z));

            // å¤–æ˜Ÿäººæ”»å‡»AI - æœ‰ä¸€å®šæ¦‚ç‡å‘å°„æ¿€å…‰
            if (Math.random() < 0.01) { // 1%æ¦‚ç‡å°„å‡»
                const laser = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );

                // è®¾ç½®æ¿€å…‰ä½ç½®åœ¨æ•Œäººä½ç½®ï¼Œæ–¹å‘æŒ‡å‘ç©å®¶
                laser.position.copy(en.position);
                laser.position.y += 1; // ç¨å¾®é«˜ä¸€ç‚¹

                // è®¡ç®—æ¿€å…‰çš„æ–¹å‘å’Œé•¿åº¦
                const laserDir = new THREE.Vector3().subVectors(GAME.player.position, en.position).normalize();
                const distanceToPlayer = en.position.distanceTo(GAME.player.position);

                // è®¾ç½®æ¿€å…‰é•¿åº¦ä¸ºåˆ°ç©å®¶çš„è·ç¦»
                laser.scale.set(1, 1, distanceToPlayer);
                laser.lookAt(GAME.player.position);

                GAME.scene.add(laser);

                // æ¿€å…‰ç¢°æ’æ£€æµ‹
                setTimeout(() => {
                    if (laser) {
                        GAME.scene.remove(laser);

                        // å¦‚æœæ¿€å…‰å‡»ä¸­ç©å®¶
                        if (GAME.player.position.distanceTo(en.position) < distanceToPlayer + 1) {
                            GAME.hp -= 5; // æ¯æ¬¡æ¿€å…‰é€ æˆ5ç‚¹ä¼¤å®³
                            updateUI();
                            if (GAME.hp <= 0) alert("ä»»åŠ¡å¤±è´¥! åˆ·æ–°é‡æ¥");
                        }
                    }
                }, 200); // æ¿€å…‰æŒç»­200ms
            }

            // ğŸ©¸ è¡€æ¡æ›´æ–°
            const hpPercent = en.userData.hp / en.userData.maxHp;
            const hpBar = en.userData.hpBar;

            const pos = en.position.clone();
            pos.y += 3;
            pos.project(GAME.camera);

            if (pos.z < 1) {
                hpBar.style.display = 'block';
                hpBar.style.left = `${(pos.x * 0.5 + 0.5) * window.innerWidth - 20}px`;
                hpBar.style.top = `${(-pos.y * 0.5 + 0.5) * window.innerHeight}px`;
                hpBar.querySelector('.hp-inner').style.width = `${hpPercent * 100}%`;
            } else {
                hpBar.style.display = 'none';
            }

            // æ’ç©å®¶
            if (en.position.distanceTo(GAME.player.position) < 1.5) {
                GAME.hp -= 0.5;
                updateUI();
                if (GAME.hp <= 0) alert("ä»»åŠ¡å¤±è´¥! åˆ·æ–°é‡æ¥");
            }

            if (en.userData.hp <= 0) {
                // ç§»é™¤æ•´ä¸ªå¤–æ˜Ÿäººç»„
                GAME.scene.remove(en);
                en.userData.hpBar.remove(); // ç§»é™¤è¡€æ¡DOM
                GAME.enemies.splice(i, 1);
            }
        });

        // 6. å­å¼¹æ›´æ–°(ç«ç®­å¼¹)
        GAME.bullets.forEach((b, i) => {
            b.position.addScaledVector(b.userData.dir, 40 * dt);
            if (b.userData.type === 'rocket' && b.position.y < 0.5) {
                // çˆ†ç‚¸
                createExplosion(b.position);
                GAME.enemies.forEach(en => {
                    if (en.position.distanceTo(b.position) < 20) en.userData.hp -= 30;
                });
                GAME.scene.remove(b);
                GAME.bullets.splice(i, 1);
            } else if (b.position.distanceTo(GAME.player.position) > 100) {
                GAME.scene.remove(b);
                GAME.bullets.splice(i, 1);
            }
        });

        GAME.renderer.render(GAME.scene, GAME.camera);
    }

    function shootLogic(wp, origin, quat, isPlayer) {
        // å°„çº¿æ£€æµ‹
        if (wp.type === 'hitscan' || wp.type === 'chain') {
            const raycaster = new THREE.Raycaster();
            if (isPlayer) {
                raycaster.setFromCamera(new THREE.Vector2(0, 0), GAME.camera); // ç©å®¶æŒ‡å“ªæ‰“å“ª
            } else {
                const fwd = new THREE.Vector3(0,0,1).applyQuaternion(quat);
                raycaster.set(origin, fwd);
            }
            
            const hits = raycaster.intersectObjects(GAME.enemies, true); // å…³é”®ä¿®æ”¹ï¼šæ£€æµ‹å­å¯¹è±¡
            if (hits.length > 0) {
                const hit = hits[0];
                // æ‰¾åˆ°åŒ…å«è¯¥ç½‘æ ¼çš„å¤–æ˜Ÿäººç»„
                let alienGroup = null;
                for (let obj = hit.object; obj; obj = obj.parent) {
                    if (obj.userData && obj.userData.type === 'alien') {
                        alienGroup = obj;
                        break;
                    }
                }

                if (alienGroup) {
                    alienGroup.userData.hp -= wp.dmg;
                    createTracer(origin, hit.point);

                    // é›·ç”µé“¾
                    if (wp.type === 'chain') {
                        GAME.enemies.forEach(en => {
                            if (en !== alienGroup && en.position.distanceTo(alienGroup.position) < 15) {
                                en.userData.hp -= wp.dmg;
                                createLightning(alienGroup.position, en.position);
                            }
                        });
                    }
                }
            } else {
                // æ²¡æ‰“ä¸­ä¹Ÿç”»ä¸ªç‰¹æ•ˆ
                const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(quat);
                if(isPlayer) {
                     // ç®€å•å¤„ç†ï¼šå‘ç›¸æœºå‰æ–¹ç”»
                     const end = new THREE.Vector3(0,0,-50).applyMatrix4(GAME.camera.matrixWorld);
                     createTracer(origin, end);
                }
            }
        } else if (wp.type === 'rocket') {
            const b = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshBasicMaterial({color: 'red'}));
            b.position.copy(origin);
            b.position.y += 2;
            // ç®€å•æ²¿ç›¸æœºæœå‘é£
            const dir = new THREE.Vector3();
            GAME.camera.getWorldDirection(dir);
            b.userData = { dir: dir, type: 'rocket' };
            GAME.scene.add(b);
            GAME.bullets.push(b);
        }
    }

    // --- ç‰¹æ•ˆ ---
    function createTracer(start, end) {
        const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
        const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line);
        setTimeout(() => GAME.scene.remove(line), 100);
    }

    function createLightning(start, end) {
        const mat = new THREE.LineBasicMaterial({ color: 0x00ffff });
        const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line);
        setTimeout(() => GAME.scene.remove(line), 200);
    }

    function createExplosion(pos) {
        const mesh = new THREE.Mesh(
            new THREE.SphereGeometry(3),
            new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 })
        );
        mesh.position.copy(pos);
        GAME.scene.add(mesh);
        let s = 1.0;
        function anim() {
            s += 0.2;
            mesh.scale.set(s,s,s);
            mesh.material.opacity -= 0.1;
            if (mesh.material.opacity > 0) requestAnimationFrame(anim);
            else GAME.scene.remove(mesh);
        }
        anim();
    }

    function updateUI() {
        const wp = GAME.weapons[GAME.currentIdx];
        if(!wp) return;
        document.getElementById('wp-name').innerText = wp.name;
        document.getElementById('ammo').innerText = `${wp.curAmmo}/${wp.mag}`;
        document.getElementById('hp').innerText = Math.floor(GAME.hp);
        document.getElementById('wave').innerText = GAME.wave; // æ›´æ–°æ³¢æ¬¡æ˜¾ç¤º
        document.getElementById('btn-scope').style.display = wp.sniper ? 'flex' : 'none';

        // æŒ‰é’®é«˜äº®
        const btnScope = document.getElementById('btn-scope');
        if(GAME.isScoped) btnScope.style.background = 'rgba(0,255,255,0.8)';
        else btnScope.style.background = 'rgba(0,255,255,0.3)';
    }

</script>
</body>
</html>