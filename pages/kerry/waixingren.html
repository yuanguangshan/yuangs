<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ€åé˜²çº¿: æ˜Ÿé™…æˆ˜åœº</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€è®¾ç½® --- */
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: 'Segoe UI', Arial, sans-serif; user-select: none;
        }

        /* æ¸¸æˆç”»é¢å±‚ */
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* å—ä¼¤çº¢å±ç‰¹æ•ˆ - å¢å¼ºç‰ˆ */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, transparent 30%, rgba(255,0,0,0.4) 100%);
            opacity: 0; pointer-events: none; z-index: 99;
            transition: opacity 0.15s ease-out;
        }

        /* UI å®¹å™¨ */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 100; pointer-events: none; 
        }

        /* æŒ‰é’®ç»„ - ç°ä»£åŒ–è®¾è®¡ */
        .btn {
            position: absolute; z-index: 102; pointer-events: auto; cursor: pointer;
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.85), rgba(10, 20, 40, 0.9)); 
            border: 2px solid rgba(100, 200, 255, 0.6); 
            border-radius: 50%; color: white; font-weight: bold; font-size: 22px;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 15px rgba(0, 150, 255, 0.4), inset 0 1px 2px rgba(255,255,255,0.2);
            transition: all 0.15s ease;
            backdrop-filter: blur(8px);
        }
        .btn:active { 
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.7), rgba(50, 150, 255, 0.8)); 
            transform: scale(0.92); 
            box-shadow: 0 2px 8px rgba(0, 150, 255, 0.6), inset 0 1px 2px rgba(255,255,255,0.3);
        }
        .btn::before {
            content: '';
            position: absolute;
            top: 5px; left: 5px; right: 5px; bottom: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.15), transparent);
            border-radius: 50%;
            pointer-events: none;
        }

        /* æŒ‰é’®ä½ç½® */
        #btn-fire { 
            bottom: 80px; right: 180px; 
            width: 95px; height: 95px; 
            background: linear-gradient(135deg, rgba(255, 50, 50, 0.75), rgba(200, 0, 0, 0.85)); 
            border-color: #ff6666;
            z-index: 110;
            font-size: 32px;
        }
        #btn-fire::after { 
            content: 'FIRE'; 
            font-size: 9px; 
            position: absolute; 
            bottom: 12px; 
            opacity: 0.8;
            letter-spacing: 1px;
        }

        #btn-reload { bottom: 195px; right: 130px; width: 58px; height: 58px; }
        #btn-reload::after { content: 'RELOAD'; font-size: 8px; position: absolute; bottom: 4px; opacity: 0.75; }

        #btn-switch { bottom: 175px; right: 45px; width: 58px; height: 58px; }
        #btn-switch::after { content: 'SWITCH'; font-size: 8px; position: absolute; bottom: 4px; opacity: 0.75; }

        #btn-scope { 
            display: none; 
            bottom: 265px; right: 65px; 
            width: 68px; height: 68px; 
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.3), rgba(0, 200, 200, 0.4)); 
        }
        #btn-scope::after { content: 'SCOPE'; font-size: 8px; position: absolute; bottom: 8px; opacity: 0.75; }
        #btn-scope.active {
            background: linear-gradient(135deg, rgba(0, 255, 255, 0.8), rgba(0, 200, 200, 0.9));
            border-color: #00ffff;
        }

        /* HUD - ç°ä»£åŒ–ä»ªè¡¨ç›˜ */
        #hud {
            position: absolute; top: 20px; left: 20px; z-index: 105;
            color: #00ffff; 
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.85), rgba(0, 10, 30, 0.9)); 
            padding: 18px 20px; 
            border-radius: 12px;
            font-size: 15px; 
            pointer-events: none; 
            border: 2px solid rgba(0, 255, 255, 0.4);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6), inset 0 1px 2px rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            min-width: 200px;
        }
        #hud .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0;
            padding: 4px 0;
        }
        #hud .stat-label {
            color: rgba(255,255,255,0.7);
            font-size: 13px;
            margin-right: 15px;
        }
        #hud .stat-value {
            font-weight: bold; 
            color: white;
            font-size: 16px;
            text-shadow: 0 0 8px rgba(0,255,255,0.6);
        }
        #hud .hp-value {
            color: #00ff88;
        }
        #hud .hp-value.low {
            color: #ff4444;
            animation: pulse-red 0.5s infinite;
        }
        @keyframes pulse-red {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        #log { 
            font-size: 12px; 
            color: #ffcc00; 
            margin-top: 10px; 
            padding-top: 8px;
            border-top: 1px solid rgba(255,255,255,0.15);
            font-style: italic;
        }

        /* å‡†æ˜Ÿ - åŠ¨æ€è®¾è®¡ */
        #crosshair {
            position: absolute; top: 50%; left: 50%; 
            width: 30px; height: 30px;
            transform: translate(-50%, -50%); 
            pointer-events: none; z-index: 105;
            transition: all 0.2s ease;
        }
        #crosshair::before,
        #crosshair::after,
        #crosshair .h-line,
        #crosshair .v-line {
            content: '';
            position: absolute;
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.6);
        }
        #crosshair::before { /* ä¸Š */
            width: 2px; height: 10px;
            top: 0; left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after { /* ä¸‹ */
            width: 2px; height: 10px;
            bottom: 0; left: 50%;
            transform: translateX(-50%);
        }
        #crosshair .h-line { /* å·¦ */
            width: 10px; height: 2px;
            left: 0; top: 50%;
            transform: translateY(-50%);
        }
        #crosshair .v-line { /* å³ */
            width: 10px; height: 2px;
            right: 0; top: 50%;
            transform: translateY(-50%);
        }
        #crosshair .center-dot {
            position: absolute;
            width: 4px; height: 4px;
            background: rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 6px rgba(255, 0, 0, 0.8);
        }
        
        #controls-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 13px; text-align: center;
            text-shadow: 1px 1px 3px #000; width: 100%; pointer-events: none;
            background: linear-gradient(to top, rgba(0,0,0,0.6), transparent);
            padding: 15px 10px 10px;
        }

        /* è™šæ‹Ÿæ‘‡æ†æ ·å¼ - ä¼˜åŒ–ç‰ˆ */
        .joystick {
            position: absolute;
            width: 130px; height: 130px;
            bottom: 70px;
            z-index: 102;
            pointer-events: auto;
        }

        #joystick-left { left: 45px; }
        #joystick-right { right: 45px; }

        .joystick-base {
            position: absolute;
            width: 100%; height: 100%;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(20, 30, 50, 0.7), rgba(10, 20, 40, 0.8));
            border: 3px solid rgba(100, 200, 255, 0.5);
            box-shadow: 0 4px 20px rgba(0, 150, 255, 0.4), inset 0 2px 4px rgba(255,255,255,0.1);
            backdrop-filter: blur(8px);
        }
        .joystick-base::before {
            content: '';
            position: absolute;
            top: 10px; left: 10px; right: 10px; bottom: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.1), transparent);
            border-radius: 50%;
        }

        .joystick-handle {
            position: absolute;
            width: 55px; height: 55px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(100, 200, 255, 0.9), rgba(50, 150, 255, 0.95));
            border: 3px solid rgba(255, 255, 255, 0.9);
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 3px 12px rgba(0, 150, 255, 0.6), inset 0 1px 3px rgba(255,255,255,0.4);
            cursor: move;
            transition: transform 0.1s ease;
        }
        .joystick-handle::before {
            content: '';
            position: absolute;
            top: 5px; left: 5px; right: 5px; bottom: 50%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.4), transparent);
            border-radius: 50%;
        }
        .joystick.active .joystick-handle {
            box-shadow: 0 2px 8px rgba(0, 150, 255, 0.8), inset 0 1px 3px rgba(255,255,255,0.5);
        }

        /* é€‰æªç•Œé¢ - ç²¾ç¾ä¼˜åŒ– */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a1e 0%, #1a1a3e 50%, #0a0a1e 100%); 
            z-index: 200;
            display: flex; flex-direction: column; align-items: center; 
            padding-top: 40px; padding-bottom: 80px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            pointer-events: auto;
        }
        #menu h1 {
            color: #00d4ff; 
            text-shadow: 0 0 20px #00d4ff, 0 0 40px #0088ff; 
            margin-bottom: 5px;
            font-size: 36px;
            letter-spacing: 2px;
        }
        #menu h3 {
            color: #aaa; 
            margin-bottom: 25px;
            font-weight: 400;
            font-size: 16px;
        }
        
        .card {
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02)); 
            border: 2px solid rgba(100, 200, 255, 0.3); 
            width: 85%; max-width: 450px; 
            padding: 20px 22px; 
            margin: 8px; 
            color: #ddd; 
            border-radius: 12px; 
            cursor: pointer; 
            user-select: none;
            transition: all 0.25s ease;
            display: flex; 
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .card:hover { 
            background: linear-gradient(135deg, rgba(255,255,255,0.12), rgba(255,255,255,0.08)); 
            transform: translateX(8px) scale(1.02);
            border-color: rgba(100, 200, 255, 0.6);
            box-shadow: 0 6px 20px rgba(0, 150, 255, 0.3);
        }
        .card.selected { 
            border-color: #00ff88; 
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.15), rgba(0, 200, 100, 0.1)); 
            color: white; 
            box-shadow: 0 6px 25px rgba(0,255,136,0.4);
            transform: translateX(8px) scale(1.03);
        }
        .card .weapon-name {
            font-size: 18px;
            font-weight: 600;
        }
        .card small {
            color: #999;
            font-size: 13px;
        }
        .card.selected small {
            color: #aaffcc;
        }
        
        #start-btn {
            margin-top: 25px; margin-bottom: 20px; 
            padding: 16px 70px; 
            font-size: 22px; 
            background: linear-gradient(135deg, #333, #222); 
            color: #666; 
            font-weight: bold; 
            flex-shrink: 0;
            border: 2px solid #444; 
            border-radius: 50px; 
            pointer-events: none; 
            transition: all 0.3s ease;
            cursor: not-allowed;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        #start-btn.active { 
            background: linear-gradient(135deg, #00ccff, #0088ff); 
            color: white; 
            pointer-events: auto; 
            cursor: pointer; 
            border-color: #00ddff;
            box-shadow: 0 6px 30px rgba(0, 170, 255, 0.6);
            transform: scale(1.05);
        }
        #start-btn.active:hover {
            background: linear-gradient(135deg, #00ddff, #0099ff);
            box-shadow: 0 8px 35px rgba(0, 170, 255, 0.8);
        }
        #start-btn.active:active {
            transform: scale(0.98);
        }
        
        /* iPad / Tablet ä¸“å±ä¼˜åŒ– */
        @media (min-width: 768px) {
            .btn { width: 70px; height: 70px; font-size: 24px; }
            #btn-fire { 
                width: 120px; height: 120px; 
                right: 230px; bottom: 90px;
                font-size: 38px;
            }
            #btn-reload { bottom: 240px; right: 150px; width: 65px; height: 65px; }
            #btn-switch { bottom: 220px; right: 55px; width: 65px; height: 65px; }
            #btn-scope { bottom: 330px; right: 75px; width: 80px; height: 80px; }
            
            .joystick { width: 170px; height: 170px; bottom: 90px; }
            #joystick-left { left: 70px; }
            #joystick-right { right: 70px; }
            .joystick-handle { width: 75px; height: 75px; }
            
            #hud { 
                top: 30px; left: 30px; 
                font-size: 17px; padding: 22px 25px; 
                min-width: 240px;
            }
            #hud .stat-label { font-size: 14px; }
            #hud .stat-value { font-size: 18px; }
            #log { font-size: 14px; }
            
            #menu h1 { font-size: 52px; }
            #menu h3 { font-size: 18px; }
            .card { width: 500px; padding: 25px 28px; }
            .card .weapon-name { font-size: 20px; }
            .card small { font-size: 14px; }
        }

        /* å‘¼å¸ç¯åŠ¨ç”» - æŸ”å’Œç‰ˆ */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 4px 15px rgba(0, 150, 255, 0.4), inset 0 1px 2px rgba(255,255,255,0.2); }
            50% { box-shadow: 0 6px 25px rgba(0, 150, 255, 0.6), inset 0 1px 2px rgba(255,255,255,0.3); }
        }
        .btn { animation: pulse-glow 3s infinite ease-in-out; }
        
        /* æ•Œäººè¡€æ¡ */
        .hp-bar { 
            position: absolute; 
            height: 5px; 
            background: linear-gradient(90deg, #ff3333, #ff6666); 
            z-index: 90; 
            pointer-events: none; 
            display: none; 
            box-shadow: 0 0 10px rgba(255, 50, 50, 0.8); 
            border-radius: 3px;
            border: 1px solid rgba(255, 100, 100, 0.5);
        }

        /* åŠ è½½åŠ¨ç”» */
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300;
            display: none;
            color: white;
            text-align: center;
        }
        #loading.active { display: block; }
        .spinner {
            width: 60px; height: 60px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #00ccff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* å‡»æ€æç¤º */
        #kill-feed {
            position: absolute;
            top: 120px; right: 20px;
            z-index: 105;
            pointer-events: none;
        }
        .kill-msg {
            background: linear-gradient(90deg, transparent, rgba(255, 100, 0, 0.8), transparent);
            color: white;
            padding: 8px 15px;
            margin: 5px 0;
            border-radius: 4px;
            font-size: 14px;
            animation: slideIn 0.3s ease, fadeOut 0.5s ease 2.5s forwards;
            box-shadow: 0 2px 10px rgba(255, 100, 0, 0.5);
        }
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes fadeOut {
            to { opacity: 0; transform: translateY(-10px); }
        }

        /* æ³¢æ¬¡æç¤º */
        #wave-alert {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 150;
            font-size: 48px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 30px #00ffff, 0 0 60px #0088ff;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s;
        }
        #wave-alert.show {
            animation: waveAnnounce 3s ease;
        }
        @keyframes waveAnnounce {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>
    <div id="damage-overlay"></div>
    <div id="loading"><div class="spinner"></div><div>åŠ è½½ä¸­...</div></div>

    <!-- UI -->
    <div id="ui-layer">
        <div id="hud">
            <div class="stat-row">
                <span class="stat-label">è£…ç”²</span>
                <span class="stat-value hp-value" id="ui-hp">100</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">æ­¦å™¨</span>
                <span class="stat-value" id="ui-wp">--</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">å¼¹è¯</span>
                <span class="stat-value" id="ui-ammo">--</span>
            </div>
            <div id="log">ç­‰å¾…éƒ¨ç½²æŒ‡ä»¤...</div>
        </div>
        
        <div id="crosshair">
            <div class="h-line"></div>
            <div class="v-line"></div>
            <div class="center-dot"></div>
        </div>

        <div id="kill-feed"></div>
        <div id="wave-alert"></div>

        <!-- å·¦ä¾§è™šæ‹Ÿæ‘‡æ† -->
        <div id="joystick-left" class="joystick">
            <div class="joystick-base"></div>
            <div class="joystick-handle"></div>
        </div>

        <!-- å³ä¾§è™šæ‹Ÿæ‘‡æ† -->
        <div id="joystick-right" class="joystick">
            <div class="joystick-base"></div>
            <div class="joystick-handle"></div>
        </div>

        <div id="btn-fire" class="btn" 
             onpointerdown="event.preventDefault(); GAME.inputs.fire=true" 
             onpointerup="GAME.inputs.fire=false"
             onpointercancel="GAME.inputs.fire=false">ğŸ”¥</div>
        <div id="btn-reload" class="btn" onclick="doReload()">â™»ï¸</div>
        <div id="btn-switch" class="btn" onclick="doSwitch()">âš”ï¸</div>
        <div id="btn-scope" class="btn" onclick="doScope()">ğŸ¯</div>

        <div id="controls-hint">
            PC: [WASD] ç§»åŠ¨ | [æ–¹å‘é”®] ç„å‡† | [Space] å¼€ç« | [R] æ¢å¼¹ | [Q] åˆ‡æª | [Shift] ç„å‡†é•œ
        </div>
    </div>

    <!-- èœå• -->
    <div id="menu">
        <h1>âš”ï¸ è¡Œæ˜Ÿé˜²å«å†› âš”ï¸</h1>
        <h3>é€‰æ‹© 2 æŠŠä¸»æ­¦å™¨å¼€å§‹æˆ˜æ–—</h3>
        <div class="card" onclick="selectWp(0, this)">
            <span class="weapon-name">ğŸ¯ æ­»ç¥ç‹™å‡»</span>
            <small>8å€é•œ | é«˜ä¼¤å®³</small>
        </div>
        <div class="card" onclick="selectWp(1, this)">
            <span class="weapon-name">âš¡ ç–¾é£å†²é”‹æª</span>
            <small>é«˜å°„é€Ÿ | å‹åˆ¶åŠ›</small>
        </div>
        <div class="card" onclick="selectWp(2, this)">
            <span class="weapon-name">âš¡ é›·éœ†ç”µæª</span>
            <small>è¿é”é—ªç”µ | èŒƒå›´æ€ä¼¤</small>
        </div>
        <div class="card" onclick="selectWp(3, this)">
            <span class="weapon-name">ğŸ”« åŠ ç‰¹æ—æœºç‚®</span>
            <small>å¼¹é›¨å‹åˆ¶ | è¶…å¤§å¼¹åŒ£</small>
        </div>
        <div class="card" onclick="selectWp(4, this)">
            <span class="weapon-name">ğŸš€ æ¯ç­ç«ç®­ç­’</span>
            <small>èŒƒå›´çˆ†ç‚¸ | ç¾¤ä½“ä¼¤å®³</small>
        </div>
        <button id="start-btn" onclick="startGame()">ğŸš€ å¯åŠ¨ä½œæˆ˜å¼•æ“</button>
    </div>

<script>
    // --- å…¨å±€çŠ¶æ€ ---
    const GAME = {
        scene: null, camera: null, renderer: null, player: null, 
        ground: null, groundGrid: null,
        inputs: { w:false, a:false, s:false, d:false, up:false, down:false, left:false, right:false, fire: false },
        camPitch: 0,
        weapons: [], selected: [], curIdx: 0,
        bullets: [], enemies: [], allies: [], particles: [], decor: [],
        isScoped: false, hp: 100, wave: 1, killCount: 0,
        isPlaying: false
    };

    const WEAPONS = [
        { name: "æ­»ç¥ç‹™å‡»", dmg: 100, rate: 1.5, mag: 6, type: 'hitscan', sniper: true },
        { name: "å†²é”‹æª", dmg: 12, rate: 0.1, mag: 60, type: 'hitscan' },
        { name: "é›·ç”µæª", dmg: 40, rate: 0.8, mag: 6, type: 'chain' },
        { name: "åŠ ç‰¹æ—", dmg: 8, rate: 0.05, mag: 500, type: 'hitscan' },
        { name: "ç«ç®­ç‚®", dmg: 0, rate: 1.5, mag: 5, type: 'rocket' }
    ];

    // --- èœå• ---
    function selectWp(id, el) {
        if(GAME.selected.includes(id)) {
            GAME.selected = GAME.selected.filter(i=>i!==id);
            el.classList.remove('selected');
        } else if(GAME.selected.length < 2) {
            GAME.selected.push(id);
            el.classList.add('selected');
        }
        const btn = document.getElementById('start-btn');
        if(GAME.selected.length===2) btn.classList.add('active');
        else btn.classList.remove('active');
    }

    function startGame() {
        if(GAME.selected.length !== 2) return;
        document.getElementById('menu').style.display = 'none';
        document.getElementById('loading').classList.add('active');
        
        GAME.selected.forEach(id => {
            const w = WEAPONS[id];
            GAME.weapons.push({...w, curAmmo: w.mag, lastFire: 0});
        });
        
        setTimeout(() => {
            initThree();
            initJoysticks();
            document.getElementById('loading').classList.remove('active');
            showWaveAlert(1);
        }, 500);
    }

    // --- é”®ç›˜ç›‘å¬ ---
    window.addEventListener('keydown', (e) => {
        if(!GAME.isPlaying) return;
        switch(e.code) {
            case 'KeyW': GAME.inputs.w = true; break;
            case 'KeyS': GAME.inputs.s = true; break;
            case 'KeyA': GAME.inputs.a = true; break;
            case 'KeyD': GAME.inputs.d = true; break;
            case 'ArrowUp': GAME.inputs.up = true; break;
            case 'ArrowDown': GAME.inputs.down = true; break;
            case 'ArrowLeft': GAME.inputs.left = true; break;
            case 'ArrowRight': GAME.inputs.right = true; break;
            case 'Space': GAME.inputs.fire = true; break;
            case 'KeyR': doReload(); break;
            case 'KeyQ': doSwitch(); break;
            case 'ShiftLeft': case 'ShiftRight': doScope(); break;
        }
    });

    window.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'KeyW': GAME.inputs.w = false; break;
            case 'KeyS': GAME.inputs.s = false; break;
            case 'KeyA': GAME.inputs.a = false; break;
            case 'KeyD': GAME.inputs.d = false; break;
            case 'ArrowUp': GAME.inputs.up = false; break;
            case 'ArrowDown': GAME.inputs.down = false; break;
            case 'ArrowLeft': GAME.inputs.left = false; break;
            case 'ArrowRight': GAME.inputs.right = false; break;
            case 'Space': GAME.inputs.fire = false; break;
        }
    });

    function doReload() { 
        const w = GAME.weapons[GAME.curIdx];
        if(w.curAmmo < w.mag) {
            w.curAmmo = w.mag; 
            updateUI();
            showLog('å¼¹è¯å·²è¡¥å……');
        }
    }
    function doSwitch() { 
        GAME.curIdx = (GAME.curIdx + 1) % 2; 
        GAME.isScoped = false; 
        updateUI();
        showLog(`åˆ‡æ¢è‡³ ${GAME.weapons[GAME.curIdx].name}`);
    }
    function doScope() { 
        const w = GAME.weapons[GAME.curIdx];
        if(w.sniper) {
            GAME.isScoped = !GAME.isScoped; 
            updateUI();
            showLog(GAME.isScoped ? 'ç„å‡†é•œå¯åŠ¨' : 'ç„å‡†é•œå…³é—­');
        }
    }

    // --- Three.js ---
    function initThree() {
        GAME.scene = new THREE.Scene();
        const bgColor = new THREE.Color(0x1a1a2e); 
        GAME.scene.background = bgColor;
        GAME.scene.fog = new THREE.Fog(bgColor, 30, 90);

        GAME.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 2000);
        
        GAME.renderer = new THREE.WebGLRenderer({ antialias: true });
        GAME.renderer.setSize(window.innerWidth, window.innerHeight);
        GAME.renderer.shadowMap.enabled = true;
        GAME.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.getElementById('game-container').appendChild(GAME.renderer.domElement);

        const hemiLight = new THREE.HemisphereLight(0x444488, 0x442200, 0.6);
        GAME.scene.add(hemiLight);
        const dir = new THREE.DirectionalLight(0xffeeb1, 1.2);
        dir.position.set(50, 80, 50); dir.castShadow = true;
        dir.shadow.mapSize.width = 2048; dir.shadow.mapSize.height = 2048;
        GAME.scene.add(dir);

        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x222225, 
            roughness: 0.9,
            metalness: 0.1
        });
        GAME.ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), planeMat);
        GAME.ground.rotation.x = -Math.PI/2; GAME.ground.receiveShadow = true;
        GAME.scene.add(GAME.ground);

        GAME.groundGrid = new THREE.GridHelper(2000, 200, 0x333344, 0x1a1a20);
        GAME.scene.add(GAME.groundGrid);

        const pGeo = new THREE.ConeGeometry(0.5, 1.5, 8); pGeo.rotateX(Math.PI/2);
        GAME.player = new THREE.Mesh(pGeo, new THREE.MeshLambertMaterial({color: 0x00ccff, emissive: 0x004488}));
        GAME.player.position.y = 1; GAME.player.castShadow = true;
        
        const playerLight = new THREE.PointLight(0x00aaff, 1, 20);
        playerLight.position.set(0, 2, 0);
        GAME.player.add(playerLight);
        GAME.scene.add(GAME.player);

        for(let i=0; i<10; i++) {
            const ally = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshLambertMaterial({color: 0x0055ff}));
            ally.castShadow = true; ally.userData = { lastFire: 0, offsetAngle: (i/10)*Math.PI*2 };
            GAME.scene.add(ally); GAME.allies.push(ally);
        }

        initDecorations();

        GAME.isPlaying = true;
        updateUI();
        spawnEnemy(); spawnEnemy(); spawnEnemy();
        
        requestAnimationFrame(loop);
    }

    function initDecorations() {
        const rockGeo = new THREE.DodecahedronGeometry(0.4, 0);
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.8 });
        
        const grassGeo = new THREE.ConeGeometry(0.2, 0.6, 4);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x33aa33 });
        
        const flowerGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const flowerMat = new THREE.MeshBasicMaterial({ color: 0xff00ff });

        for(let i=0; i<300; i++) {
            let type = Math.random();
            let mesh;
            
            if(type < 0.5) {
                mesh = new THREE.Mesh(rockGeo, rockMat);
                mesh.scale.setScalar(0.5 + Math.random());
                mesh.position.y = 0.2;
            } else if(type < 0.9) {
                mesh = new THREE.Mesh(grassGeo, grassMat);
                mesh.position.y = 0.3;
            } else {
                mesh = new THREE.Mesh(flowerGeo, flowerMat);
                mesh.position.y = 0.5;
            }
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 10 + Math.random() * 80;
            mesh.position.x = Math.cos(angle) * dist;
            mesh.position.z = Math.sin(angle) * dist;
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.rotation.y = Math.random() * Math.PI;
            
            GAME.scene.add(mesh);
            GAME.decor.push(mesh);
        }
    }

    function updateDecorations() {
        GAME.decor.forEach(obj => {
            const dist = obj.position.distanceTo(GAME.player.position);
            if(dist > 70) {
                const angle = GAME.player.rotation.y + (Math.random()-0.5) * Math.PI;
                const newDist = 60 + Math.random() * 10;
                obj.position.x = GAME.player.position.x - Math.sin(angle) * newDist;
                obj.position.z = GAME.player.position.z - Math.cos(angle) * newDist;
            }
        });
    }

    function spawnEnemy() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 30 + Math.random() * 20;
        const group = new THREE.Group();
        group.position.set(GAME.player.position.x + Math.sin(angle)*dist, 0, GAME.player.position.z + Math.cos(angle)*dist);
        
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.4,1.8,6), new THREE.MeshStandardMaterial({color:0x88ee44, roughness:0.5}));
        body.position.y = 0.9;
        const head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5), new THREE.MeshStandardMaterial({color:0x66aa44}));
        head.position.y = 2.0;
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color:0xff0000}));
        eye.position.set(0, 2.0, 0.4);
        
        group.add(body); group.add(head); group.add(eye);
        group.userData = { hp: 50, maxHp: 50, speed: 4 + GAME.wave*0.5 };

        const bar = document.createElement('div');
        bar.className = 'hp-bar';
        bar.style.width = '30px';
        document.body.appendChild(bar);
        group.userData.bar = bar;

        GAME.scene.add(group); GAME.enemies.push(group);
    }

    function loop(time) {
        requestAnimationFrame(loop);
        if(!GAME.isPlaying) return;
        const dt = 0.016; const now = time/1000;

        const moveSpd = 12;
        const camDir = new THREE.Vector3(); GAME.camera.getWorldDirection(camDir); camDir.y=0; camDir.normalize();
        const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0,1,0));
        
        if(GAME.inputs.w) GAME.player.position.addScaledVector(camDir, moveSpd * dt);
        if(GAME.inputs.s) GAME.player.position.addScaledVector(camDir, -moveSpd * dt);
        if(GAME.inputs.d) GAME.player.position.addScaledVector(camRight, moveSpd * dt);
        if(GAME.inputs.a) GAME.player.position.addScaledVector(camRight, -moveSpd * dt);

        GAME.ground.position.x = GAME.player.position.x;
        GAME.ground.position.z = GAME.player.position.z;
        GAME.groundGrid.position.x = Math.floor(GAME.player.position.x / 10) * 10;
        GAME.groundGrid.position.z = Math.floor(GAME.player.position.z / 10) * 10;
        
        updateDecorations();

        const rotSpd = 2.5 * dt;
        if(GAME.inputs.left) GAME.player.rotation.y += rotSpd;
        if(GAME.inputs.right) GAME.player.rotation.y -= rotSpd;
        if(GAME.inputs.up) GAME.camPitch += rotSpd * 10;
        if(GAME.inputs.down) GAME.camPitch -= rotSpd * 10;
        GAME.camPitch = Math.max(-10, Math.min(20, GAME.camPitch));

        const targetPos = new THREE.Vector3(0, GAME.isScoped?1.5:5, GAME.isScoped?1.5:8).applyMatrix4(GAME.player.matrixWorld);
        const lookOff = new THREE.Vector3(0, 1 + GAME.camPitch*0.2, GAME.isScoped?-50:-20); 
        
        GAME.camera.fov = GAME.isScoped ? 15 : 70;
        GAME.camera.position.lerp(targetPos, 0.15);
        GAME.camera.lookAt(lookOff.applyMatrix4(GAME.player.matrixWorld));
        GAME.camera.updateProjectionMatrix();

        GAME.allies.forEach(a => {
            const tX = GAME.player.position.x + Math.cos(a.userData.offsetAngle)*3;
            const tZ = GAME.player.position.z + Math.sin(a.userData.offsetAngle)*3;
            a.position.x += (tX - a.position.x)*0.1;
            a.position.z += (tZ - a.position.z)*0.1;
            a.position.y = 0.6 + Math.sin(now*5 + a.userData.offsetAngle)*0.1;

            if(now - a.userData.lastFire > 1.0) {
                let near = null, minDist = 6;
                GAME.enemies.forEach(e => { const d=a.position.distanceTo(e.position); if(d<minDist){minDist=d; near=e;} });
                if(near) {
                    a.userData.lastFire = now; a.lookAt(near.position);
                    near.userData.hp -= 10;
                    createSparkle(near.position, 0x00aaff, 3);
                }
            }
        });

        const wp = GAME.weapons[GAME.curIdx];
        if(GAME.inputs.fire && now - wp.lastFire > wp.rate && wp.curAmmo > 0) {
            wp.lastFire = now; wp.curAmmo--; updateUI();
            
            const gunPos = GAME.player.position.clone().add(new THREE.Vector3(0,1,0));
            const origin = GAME.isScoped ? GAME.camera.position.clone() : gunPos;

            if(wp.type === 'rocket') {
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:'red'}));
                b.position.copy(gunPos);
                const dir = new THREE.Vector3(); GAME.camera.getWorldDirection(dir);
                b.userData = { vel: dir.multiplyScalar(30), type: 'rocket' };
                GAME.scene.add(b); GAME.bullets.push(b);
            } else {
                const ray = new THREE.Raycaster();
                ray.setFromCamera(new THREE.Vector2(0,0), GAME.camera);
                const hits = ray.intersectObjects(GAME.enemies, true);
                const endPoint = hits.length ? hits[0].point : ray.ray.at(100, new THREE.Vector3());
                
                createTracer(gunPos, endPoint);
                if(hits.length) {
                    const group = hits[0].object.parent;
                    if(group && group.userData.hp) {
                        group.userData.hp -= wp.dmg;
                        createSparkle(endPoint, 0xffaa00, 8);
                        if(wp.type === 'chain') {
                            GAME.enemies.forEach(e => {
                                if(e!==group && e.position.distanceTo(group.position)<10) {
                                    e.userData.hp -= wp.dmg;
                                    createLightning(group.position, e.position);
                                }
                            });
                        }
                    }
                }
            }
        }

        if(Math.random()<0.015) spawnEnemy();
        GAME.enemies.forEach((e, i) => {
            const dir = new THREE.Vector3().subVectors(GAME.player.position, e.position).normalize();
            e.position.addScaledVector(dir, e.userData.speed*dt);
            const targetRotation = Math.atan2(
                GAME.player.position.x - e.position.x,
                GAME.player.position.z - e.position.z
            );
            e.rotation.y += (targetRotation - e.rotation.y) * 0.05;

            const bar = e.userData.bar;
            const screen = e.position.clone().add(new THREE.Vector3(0,2.5,0)).project(GAME.camera);
            if(screen.z < 1) {
                bar.style.display = 'block';
                bar.style.left = ((screen.x * 0.5 + 0.5) * window.innerWidth - 15) + 'px';
                bar.style.top = ((-screen.y * 0.5 + 0.5) * window.innerHeight) + 'px';
                bar.style.width = (e.userData.hp / e.userData.maxHp * 30) + 'px';
            } else bar.style.display = 'none';

            if(e.position.distanceTo(GAME.player.position) < 2.5) {
                GAME.hp -= 0.5; updateUI();
                const overlay = document.getElementById('damage-overlay');
                overlay.style.opacity = 0.6; setTimeout(() => overlay.style.opacity = 0, 150);
                if(GAME.hp <= 0) { 
                    GAME.isPlaying = false;
                    setTimeout(() => {
                        alert('é˜²çº¿å¤±å®ˆ! ä½ åšæŒäº† ' + GAME.wave + ' æ³¢ï¼Œå‡»æ€ ' + GAME.killCount + ' æ•Œäºº');
                        location.reload();
                    }, 500);
                }
            }
            if(e.userData.hp <= 0) {
                createExplosion(e.position, 0x00ff00);
                bar.remove(); GAME.scene.remove(e); GAME.enemies.splice(i, 1);
                GAME.killCount++;
                showKillFeed();
            }
        });

        for(let i=GAME.bullets.length-1; i>=0; i--) {
            const b = GAME.bullets[i]; b.position.addScaledVector(b.userData.vel, dt);
            if(b.userData.type==='rocket' && b.position.y < 0) {
                createExplosion(b.position, 0xff5500); 
                GAME.enemies.forEach(e => { if(e.position.distanceTo(b.position)<15) e.userData.hp-=30; });
                GAME.scene.remove(b); GAME.bullets.splice(i,1);
            } else if(b.position.distanceTo(GAME.player.position)>100) {
                GAME.scene.remove(b); GAME.bullets.splice(i,1);
            }
        }
        updateParticles(dt);

        GAME.renderer.render(GAME.scene, GAME.camera);
    }

    function createTracer(start, end) {
        const mat = new THREE.LineBasicMaterial({color: 0xffaa00, transparent:true, opacity:0.8});
        const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line); setTimeout(() => GAME.scene.remove(line), 50);
    }
    function createLightning(start, end) {
        const mid = new THREE.Vector3().lerpVectors(start, end, 0.5).add(new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5));
        const mat = new THREE.LineBasicMaterial({color: 0x00ffff});
        const geo = new THREE.BufferGeometry().setFromPoints([start, mid, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line); setTimeout(() => GAME.scene.remove(line), 100);
    }
    function createExplosion(pos, color) {
        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color: color}));
            p.position.copy(pos);
            const vel = new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5).multiplyScalar(10);
            GAME.particles.push({mesh:p, vel:vel, life:1.0}); GAME.scene.add(p);
        }
    }
    function createSparkle(pos, color, count) { createExplosion(pos, color); }
    function updateParticles(dt) {
        for(let i=GAME.particles.length-1; i>=0; i--) {
            const p = GAME.particles[i]; p.life -= dt;
            p.mesh.position.addScaledVector(p.vel, dt); p.vel.y -= 20*dt; p.mesh.scale.setScalar(p.life);
            if(p.life<=0 || p.mesh.position.y<0) { GAME.scene.remove(p.mesh); GAME.particles.splice(i,1); }
        }
    }

    // UI è¾…åŠ©å‡½æ•°
    function showLog(msg) {
        document.getElementById('log').textContent = msg;
    }

    function showKillFeed() {
        const feed = document.getElementById('kill-feed');
        const msg = document.createElement('div');
        msg.className = 'kill-msg';
        msg.textContent = `ğŸ’¥ æ•Œäººæ¶ˆç­ +1 (${GAME.killCount})`;
        feed.appendChild(msg);
        setTimeout(() => msg.remove(), 3000);
    }

    function showWaveAlert(wave) {
        const alert = document.getElementById('wave-alert');
        alert.textContent = `ç¬¬ ${wave} æ³¢æ¥è¢­!`;
        alert.classList.add('show');
        setTimeout(() => alert.classList.remove('show'), 3000);
    }

    // è™šæ‹Ÿæ‘‡æ†ç±»
    class VirtualJoystick {
        constructor(containerId, callback) {
            this.container = document.getElementById(containerId);
            this.base = this.container.querySelector('.joystick-base');
            this.handle = this.container.querySelector('.joystick-handle');
            this.callback = callback;

            this.active = false;
            this.centerX = 0;
            this.centerY = 0;
            this.maxDistance = 55;

            this.init();
        }

        init() {
            const rect = this.base.getBoundingClientRect();
            this.centerX = rect.left + rect.width / 2;
            this.centerY = rect.top + rect.height / 2;

            this.container.addEventListener('touchstart', this.start.bind(this));
            this.container.addEventListener('touchmove', this.move.bind(this));
            this.container.addEventListener('touchend', this.end.bind(this));
            this.container.addEventListener('touchcancel', this.end.bind(this));

            this.container.addEventListener('mousedown', this.start.bind(this));
            document.addEventListener('mousemove', this.move.bind(this));
            document.addEventListener('mouseup', this.end.bind(this));
        }

        start(e) {
            e.preventDefault();
            this.active = true;
            this.container.classList.add('active');
            this.updatePosition(e);
        }

        move(e) {
            if (!this.active) return;
            e.preventDefault();
            this.updatePosition(e);
        }

        end(e) {
            if (!this.active) return;
            e.preventDefault();
            this.active = false;
            this.container.classList.remove('active');

            this.handle.style.transform = 'translate(-50%, -50%)';

            if (this.callback) {
                this.callback(0, 0);
            }
        }

        updatePosition(e) {
            const touch = e.touches && e.touches[0] ? e.touches[0] : e;
            const x = touch.clientX - this.centerX;
            const y = touch.clientY - this.centerY;

            const distance = Math.min(Math.sqrt(x * x + y * y), this.maxDistance);
            const angle = Math.atan2(y, x);

            const normalizedX = Math.min(Math.max(x / this.maxDistance, -1), 1);
            const normalizedY = Math.min(Math.max(y / this.maxDistance, -1), 1);

            const clampedX = Math.cos(angle) * distance;
            const clampedY = Math.sin(angle) * distance;

            this.handle.style.transform = `translate(calc(-50% + ${clampedX}px), calc(-50% + ${clampedY}px))`;

            if (this.callback) {
                this.callback(normalizedX, normalizedY);
            }
        }
    }

    let movementJoystick;
    let rotationJoystick;

    function initJoysticks() {
        movementJoystick = new VirtualJoystick('joystick-left', (x, y) => {
            GAME.inputs.w = y < -0.3;
            GAME.inputs.s = y > 0.3;
            GAME.inputs.a = x < -0.3;
            GAME.inputs.d = x > 0.3;
        });

        rotationJoystick = new VirtualJoystick('joystick-right', (x, y) => {
            GAME.inputs.left = x < -0.3;
            GAME.inputs.right = x > 0.3;
            GAME.inputs.up = y < -0.3;
            GAME.inputs.down = y > 0.3;
        });
    }

    function updateUI() {
        const w = GAME.weapons[GAME.curIdx];
        document.getElementById('ui-wp').innerText = w.name;
        document.getElementById('ui-ammo').innerText = w.curAmmo + '/' + w.mag;
        const hpEl = document.getElementById('ui-hp');
        hpEl.innerText = Math.floor(GAME.hp);
        if(GAME.hp < 30) {
            hpEl.classList.add('low');
        } else {
            hpEl.classList.remove('low');
        }
        
        const scopeBtn = document.getElementById('btn-scope');
        scopeBtn.style.display = w.sniper ? 'flex':'none';
        if(GAME.isScoped) {
            scopeBtn.classList.add('active');
        } else {
            scopeBtn.classList.remove('active');
        }
    }

    window.addEventListener('resize', () => {
        GAME.camera.aspect = window.innerWidth / window.innerHeight;
        GAME.camera.updateProjectionMatrix();
        GAME.renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>