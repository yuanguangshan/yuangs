<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æœ€åé˜²çº¿: é”®ç›˜æ“æ§ç‰ˆ</title>
    <style>
        /* --- æ ¸å¿ƒåŸºç¡€è®¾ç½® --- */
        body { 
            margin: 0; overflow: hidden; background-color: #000; 
            font-family: Arial, sans-serif; user-select: none;
        }

        /* æ¸¸æˆç”»é¢å±‚ */
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* å—ä¼¤çº¢å±ç‰¹æ•ˆ */
        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; z-index: 99;
            transition: opacity 0.1s;
        }

        /* UI å®¹å™¨ */
        #ui-layer { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            z-index: 100; pointer-events: none; 
        }

        /* æŒ‰é’®ç»„ (é¼ æ ‡å¯ç‚¹ï¼Œä¹Ÿå¯ä»¥ç”¨é”®ç›˜) */
        .btn {
            position: absolute; z-index: 102; pointer-events: auto; cursor: pointer;
            background: rgba(0, 0, 0, 0.5); border: 2px solid #fff; border-radius: 50%;
            color: white; font-weight: bold; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 0 5px #000; transition: 0.1s;
        }
        .btn:active { background: rgba(255, 255, 255, 0.5); transform: scale(0.9); }

        #btn-fire { bottom: 50px; right: 50px; width: 80px; height: 80px; background: rgba(255, 50, 50, 0.5); border-color: #ff5555; }
        #btn-fire::after { content: 'SPACE'; font-size: 10px; position: absolute; bottom: 15px; }
        
        #btn-reload { bottom: 150px; right: 60px; width: 50px; height: 50px; }
        #btn-reload::after { content: 'R'; font-size: 10px; position: absolute; bottom: 5px; }

        #btn-switch { bottom: 150px; right: 130px; width: 50px; height: 50px; }
        #btn-switch::after { content: 'Q'; font-size: 10px; position: absolute; bottom: 5px; }

        #btn-scope { display: none; bottom: 220px; right: 60px; width: 60px; height: 60px; background: rgba(0, 255, 255, 0.3); }
        #btn-scope::after { content: 'SHIFT'; font-size: 10px; position: absolute; bottom: 10px; }

        /* HUD */
        #hud {
            position: absolute; top: 10px; left: 10px; z-index: 105;
            color: #0f0; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px;
            font-size: 16px; pointer-events: none; border: 1px solid #0f0;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 24px; height: 24px;
            transform: translate(-50%, -50%); pointer-events: none; z-index: 105;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="lime" stroke-width="2"/><line x1="12" y1="2" x2="12" y2="22" stroke="lime"/><line x1="2" y1="12" x2="22" y2="12" stroke="lime"/></svg>');
        }
        
        #controls-hint {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); font-size: 14px; text-align: center;
            text-shadow: 1px 1px 0 #000; width: 100%;
        }

        /* é€‰æªç•Œé¢ */
        #menu {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10,10,10,0.95); z-index: 200;
            display: flex; flex-direction: column; align-items: center; padding-top: 50px;
            pointer-events: auto;
        }
        .card {
            background: #222; border: 1px solid #444; width: 400px; padding: 15px; margin: 10px;
            color: #ccc; border-radius: 5px; cursor: pointer; user-select: none;
        }
        .card:hover { background: #333; }
        .card.selected { border-color: #0f0; background: #003300; color: white; }
        #start-btn {
            margin-top: 30px; padding: 15px 50px; font-size: 24px; background: #444; color: #888;
            border: none; border-radius: 5px; pointer-events: none; transition: 0.2s;
        }
        #start-btn.active { background: #0f0; color: #000; pointer-events: auto; cursor: pointer; }
        
        .hp-bar { position: absolute; height: 4px; background: red; z-index: 90; pointer-events: none; display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>
    <div id="damage-overlay"></div>

    <!-- UI -->
    <div id="ui-layer">
        <div id="hud">
            HP: <span id="ui-hp">100</span> | <span id="ui-wp">--</span> | <span id="ui-ammo">--</span>
            <div id="log" style="font-size:12px; color:yellow; margin-top:5px;">WSADç§»åŠ¨ Â· ç®­å¤´ç„å‡† Â· ç©ºæ ¼å°„å‡»</div>
        </div>
        <div id="crosshair"></div>

        <!-- æŒ‰é’® (ä¿ç•™ä½œä¸ºè§†è§‰åé¦ˆï¼Œä¹Ÿå¯ç‚¹å‡») -->
        <div id="btn-fire" class="btn" onmousedown="GAME.inputs.fire=true" onmouseup="GAME.inputs.fire=false">ğŸ”¥</div>
        <div id="btn-reload" class="btn" onclick="doReload()">â™»ï¸</div>
        <div id="btn-switch" class="btn" onclick="doSwitch()">âš”ï¸</div>
        <div id="btn-scope" class="btn" onclick="doScope()">ğŸ¯</div>
        
        <div id="controls-hint">
            [W/A/S/D] ç§»åŠ¨ &nbsp; [â†‘/â†“/â†/â†’] ç„å‡† &nbsp; [Space] å¼€ç« &nbsp; [R] æ¢å¼¹ &nbsp; [Q] åˆ‡æª &nbsp; [Shift] ç„å‡†é•œ
        </div>
    </div>

    <!-- èœå• -->
    <div id="menu">
        <h2 style="color:#0f0">é€‰æ‹© 2 æŠŠæ­¦å™¨</h2>
        <div class="card" onclick="selectWp(0, this)">1. æ­»ç¥ç‹™å‡» (8å€é•œ)</div>
        <div class="card" onclick="selectWp(1, this)">2. å†²é”‹æª (å°„é€Ÿå¿«)</div>
        <div class="card" onclick="selectWp(2, this)">3. é›·ç”µæª (è¿é”é—ªç”µ)</div>
        <div class="card" onclick="selectWp(3, this)">4. åŠ ç‰¹æ— (å¼¹é›¨)</div>
        <div class="card" onclick="selectWp(4, this)">5. ç«ç®­ç‚® (çˆ†ç‚¸AOE)</div>
        <button id="start-btn" onclick="startGame()">å¼€å§‹æˆ˜æ–—</button>
    </div>

<script>
    // --- å…¨å±€çŠ¶æ€ ---
    const GAME = {
        scene: null, camera: null, renderer: null, player: null, ground: null, groundGrid: null,
        // è¾“å…¥çŠ¶æ€
        inputs: { 
            w:false, a:false, s:false, d:false, 
            up:false, down:false, left:false, right:false,
            fire: false 
        },
        camPitch: 0, // æ‘„åƒæœºä¿¯ä»°è§’
        weapons: [], selected: [], curIdx: 0,
        bullets: [], enemies: [], allies: [], particles: [],
        isScoped: false, hp: 100, wave: 1, lastTime: 0,
        isPlaying: false
    };

    const WEAPONS = [
        { name: "æ­»ç¥ç‹™å‡»", dmg: 100, rate: 1.5, mag: 6, type: 'hitscan', sniper: true },
        { name: "å†²é”‹æª", dmg: 12, rate: 0.1, mag: 60, type: 'hitscan' },
        { name: "é›·ç”µæª", dmg: 40, rate: 0.8, mag: 6, type: 'chain' },
        { name: "åŠ ç‰¹æ—", dmg: 8, rate: 0.05, mag: 500, type: 'hitscan' },
        { name: "ç«ç®­ç‚®", dmg: 0, rate: 1.5, mag: 5, type: 'rocket' }
    ];

    // --- èœå•é€»è¾‘ ---
    function selectWp(id, el) {
        if(GAME.selected.includes(id)) {
            GAME.selected = GAME.selected.filter(i=>i!==id);
            el.classList.remove('selected');
        } else if(GAME.selected.length < 2) {
            GAME.selected.push(id);
            el.classList.add('selected');
        }
        const btn = document.getElementById('start-btn');
        if(GAME.selected.length===2) btn.classList.add('active');
        else btn.classList.remove('active');
    }

    function startGame() {
        if(GAME.selected.length !== 2) return;
        document.getElementById('menu').style.display = 'none';
        GAME.selected.forEach(id => {
            const w = WEAPONS[id];
            GAME.weapons.push({...w, curAmmo: w.mag, lastFire: 0});
        });
        initThree();
    }

    // --- é”®ç›˜äº‹ä»¶ç›‘å¬ ---
    window.addEventListener('keydown', (e) => {
        if(!GAME.isPlaying) return;
        switch(e.code) {
            case 'KeyW': GAME.inputs.w = true; break;
            case 'KeyS': GAME.inputs.s = true; break;
            case 'KeyA': GAME.inputs.a = true; break;
            case 'KeyD': GAME.inputs.d = true; break;
            
            case 'ArrowUp': GAME.inputs.up = true; break;
            case 'ArrowDown': GAME.inputs.down = true; break;
            case 'ArrowLeft': GAME.inputs.left = true; break;
            case 'ArrowRight': GAME.inputs.right = true; break;
            
            case 'Space': GAME.inputs.fire = true; break;
            
            case 'KeyR': doReload(); break;
            case 'KeyQ': doSwitch(); break;
            case 'ShiftLeft': 
            case 'ShiftRight': doScope(); break;
        }
    });

    window.addEventListener('keyup', (e) => {
        switch(e.code) {
            case 'KeyW': GAME.inputs.w = false; break;
            case 'KeyS': GAME.inputs.s = false; break;
            case 'KeyA': GAME.inputs.a = false; break;
            case 'KeyD': GAME.inputs.d = false; break;
            
            case 'ArrowUp': GAME.inputs.up = false; break;
            case 'ArrowDown': GAME.inputs.down = false; break;
            case 'ArrowLeft': GAME.inputs.left = false; break;
            case 'ArrowRight': GAME.inputs.right = false; break;
            
            case 'Space': GAME.inputs.fire = false; break;
        }
    });

    // --- æ“ä½œå‡½æ•° ---
    function doReload() {
        GAME.weapons[GAME.curIdx].curAmmo = GAME.weapons[GAME.curIdx].mag;
        updateUI();
        // ç®€å•åŠ¨ç”»åé¦ˆ
        document.getElementById('btn-reload').style.transform = "scale(0.8)";
        setTimeout(()=>document.getElementById('btn-reload').style.transform = "scale(1)", 100);
    }
    function doSwitch() {
        GAME.curIdx = (GAME.curIdx + 1) % 2;
        GAME.isScoped = false;
        updateUI();
        document.getElementById('btn-switch').style.transform = "scale(0.8)";
        setTimeout(()=>document.getElementById('btn-switch').style.transform = "scale(1)", 100);
    }
    function doScope() {
        GAME.isScoped = !GAME.isScoped;
        updateUI();
    }

    // --- Three.js é€»è¾‘ ---
    function initThree() {
        GAME.scene = new THREE.Scene();
        GAME.scene.background = new THREE.Color(0x050508);
        GAME.scene.fog = new THREE.Fog(0x050508, 40, 100);

        GAME.camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 2000);
        
        GAME.renderer = new THREE.WebGLRenderer({ antialias: true });
        GAME.renderer.setSize(window.innerWidth, window.innerHeight);
        GAME.renderer.shadowMap.enabled = true;
        document.getElementById('game-container').appendChild(GAME.renderer.domElement);

        GAME.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(50, 100, 50); dir.castShadow = true;
        GAME.scene.add(dir);

        // æ— é™åœ°é¢
        GAME.ground = new THREE.Mesh(new THREE.PlaneGeometry(2000, 2000), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 }));
        GAME.ground.rotation.x = -Math.PI/2; GAME.ground.receiveShadow = true;
        GAME.scene.add(GAME.ground);
        GAME.groundGrid = new THREE.GridHelper(2000, 200, 0x333333, 0x111111);
        GAME.scene.add(GAME.groundGrid);

        // ç©å®¶
        const pGeo = new THREE.ConeGeometry(0.5, 1.5, 8); pGeo.rotateX(Math.PI/2);
        GAME.player = new THREE.Mesh(pGeo, new THREE.MeshLambertMaterial({color: 0x00ccff}));
        GAME.player.position.y = 1; GAME.player.castShadow = true;
        GAME.scene.add(GAME.player);

        // å†›é˜Ÿ
        for(let i=0; i<10; i++) {
            const ally = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), new THREE.MeshLambertMaterial({color: 0x0044ff}));
            ally.castShadow = true; ally.userData = { lastFire: 0, offsetAngle: (i/10)*Math.PI*2 };
            GAME.scene.add(ally); GAME.allies.push(ally);
        }

        GAME.isPlaying = true;
        updateUI();
        spawnEnemy(); spawnEnemy(); spawnEnemy();
        
        requestAnimationFrame(loop);
    }

    function spawnEnemy() {
        const angle = Math.random() * Math.PI * 2;
        const dist = 30 + Math.random() * 20;
        const group = new THREE.Group();
        group.position.set(GAME.player.position.x + Math.sin(angle)*dist, 0, GAME.player.position.z + Math.cos(angle)*dist);
        
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,1.8,8), new THREE.MeshLambertMaterial({color:0x00ff00}));
        body.position.y = 0.9;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.7,0.7), new THREE.MeshLambertMaterial({color:0x005500}));
        head.position.y = 2.1;
        const eye = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color:0xff0000}));
        eye.position.set(0, 2.1, 0.4);
        
        group.add(body); group.add(head); group.add(eye);
        group.userData = { hp: 50, maxHp: 50, speed: 4 + GAME.wave*0.5 };

        const bar = document.createElement('div');
        bar.className = 'hp-bar';
        bar.style.width = '30px';
        document.body.appendChild(bar);
        group.userData.bar = bar;

        GAME.scene.add(group); GAME.enemies.push(group);
    }

    function loop(time) {
        requestAnimationFrame(loop);
        if(!GAME.isPlaying) return;
        const dt = 0.016; const now = time/1000;

        // 1. WASD ç§»åŠ¨
        const moveSpd = 12; // é”®ç›˜ç§»åŠ¨ç¨å¿«ä¸€ç‚¹
        const camDir = new THREE.Vector3(); GAME.camera.getWorldDirection(camDir); camDir.y=0; camDir.normalize();
        const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Vector3(0,1,0));
        
        if(GAME.inputs.w) GAME.player.position.addScaledVector(camDir, moveSpd * dt);
        if(GAME.inputs.s) GAME.player.position.addScaledVector(camDir, -moveSpd * dt);
        if(GAME.inputs.d) GAME.player.position.addScaledVector(camRight, moveSpd * dt);
        if(GAME.inputs.a) GAME.player.position.addScaledVector(camRight, -moveSpd * dt);

        // æ— é™åœ°é¢é€»è¾‘
        GAME.ground.position.x = GAME.player.position.x;
        GAME.ground.position.z = GAME.player.position.z;
        GAME.groundGrid.position.x = Math.floor(GAME.player.position.x / 10) * 10;
        GAME.groundGrid.position.z = Math.floor(GAME.player.position.z / 10) * 10;

        // 2. ç®­å¤´é”® ç„å‡†
        const rotSpd = 2.5 * dt;
        // å·¦å³æ—‹è½¬äººç‰©
        if(GAME.inputs.left) GAME.player.rotation.y += rotSpd;
        if(GAME.inputs.right) GAME.player.rotation.y -= rotSpd;
        
        // ä¸Šä¸‹è°ƒæ•´è§†è§’ (Cam Pitch)
        if(GAME.inputs.up) GAME.camPitch += rotSpd * 10;
        if(GAME.inputs.down) GAME.camPitch -= rotSpd * 10;
        // é™åˆ¶ä¿¯ä»°è§’
        GAME.camPitch = Math.max(-10, Math.min(20, GAME.camPitch));

        // 3. ç›¸æœºè·Ÿéš
        const targetHeight = GAME.isScoped ? 1.5 : 5;
        const targetDist = GAME.isScoped ? 1.5 : 8;
        
        // åŸºç¡€è·Ÿéšç‚¹
        const targetPos = new THREE.Vector3(0, targetHeight, targetDist).applyMatrix4(GAME.player.matrixWorld);
        
        // è§†çº¿ç‚¹ (LookAt)
        // é»˜è®¤çœ‹å‰æ–¹ï¼Œæ ¹æ® camPitch ä¸Šä¸‹åç§»
        const lookOff = new THREE.Vector3(0, 1 + GAME.camPitch*0.2, -20); 
        if(GAME.isScoped) lookOff.z = -50;
        
        GAME.camera.fov = GAME.isScoped ? 15 : 70;
        GAME.camera.position.lerp(targetPos, 0.1); // é”®ç›˜æ¨¡å¼å¯ä»¥è·Ÿç´§ä¸€ç‚¹
        GAME.camera.lookAt(lookOff.applyMatrix4(GAME.player.matrixWorld));
        GAME.camera.updateProjectionMatrix();

        // 4. å†›é˜Ÿ
        GAME.allies.forEach(a => {
            const tX = GAME.player.position.x + Math.cos(a.userData.offsetAngle)*3;
            const tZ = GAME.player.position.z + Math.sin(a.userData.offsetAngle)*3;
            a.position.x += (tX - a.position.x)*0.1;
            a.position.z += (tZ - a.position.z)*0.1;

            if(now - a.userData.lastFire > 1.0) {
                let near = null, minDist = 6;
                GAME.enemies.forEach(e => { const d=a.position.distanceTo(e.position); if(d<minDist){minDist=d; near=e;} });
                if(near) {
                    a.userData.lastFire = now; a.lookAt(near.position);
                    near.userData.hp -= 10;
                    createSparkle(near.position, 0x0000ff, 3);
                }
            }
        });

        // 5. å°„å‡»
        const wp = GAME.weapons[GAME.curIdx];
        if(GAME.inputs.fire && now - wp.lastFire > wp.rate && wp.curAmmo > 0) {
            wp.lastFire = now; wp.curAmmo--; updateUI();
            
            const gunPos = GAME.player.position.clone().add(new THREE.Vector3(0,1,0));
            // å¦‚æœåœ¨å¼€é•œæ¨¡å¼ï¼Œå­å¼¹ä»ç›¸æœºä½ç½®å‘å°„æ›´å‡†
            const origin = GAME.isScoped ? GAME.camera.position.clone() : gunPos;

            if(wp.type === 'rocket') {
                const b = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:'red'}));
                b.position.copy(gunPos);
                // æ–¹å‘ï¼šç›¸æœºæ­£å‰æ–¹
                const dir = new THREE.Vector3(); GAME.camera.getWorldDirection(dir);
                b.userData = { vel: dir.multiplyScalar(30), type: 'rocket' };
                GAME.scene.add(b); GAME.bullets.push(b);
            } else {
                const ray = new THREE.Raycaster();
                // é”®ç›˜æ“ä½œæ—¶ç›´æ¥æ‰“å‘å±å¹•ä¸­å¿ƒ
                ray.setFromCamera(new THREE.Vector2(0,0), GAME.camera);
                
                const hits = ray.intersectObjects(GAME.enemies, true);
                const endPoint = hits.length ? hits[0].point : ray.ray.at(100, new THREE.Vector3());
                
                createTracer(gunPos, endPoint);
                if(hits.length) {
                    const group = hits[0].object.parent;
                    if(group && group.userData.hp) {
                        group.userData.hp -= wp.dmg;
                        createSparkle(endPoint, 0xffff00, 8);
                        if(wp.type === 'chain') {
                            GAME.enemies.forEach(e => {
                                if(e!==group && e.position.distanceTo(group.position)<10) {
                                    e.userData.hp -= wp.dmg;
                                    createLightning(group.position, e.position);
                                }
                            });
                        }
                    }
                }
            }
        }

        // 6. æ•Œäººé€»è¾‘
        if(Math.random()<0.015) spawnEnemy();
        GAME.enemies.forEach((e, i) => {
            const dir = new THREE.Vector3().subVectors(GAME.player.position, e.position).normalize();
            e.position.addScaledVector(dir, e.userData.speed*dt);
            e.lookAt(GAME.player.position);

            const bar = e.userData.bar;
            const screen = e.position.clone().add(new THREE.Vector3(0,2.5,0)).project(GAME.camera);
            if(screen.z < 1) {
                bar.style.display = 'block';
                bar.style.left = ((screen.x * 0.5 + 0.5) * window.innerWidth - 15) + 'px';
                bar.style.top = ((-screen.y * 0.5 + 0.5) * window.innerHeight) + 'px';
                bar.style.width = (e.userData.hp / e.userData.maxHp * 30) + 'px';
            } else bar.style.display = 'none';

            if(e.position.distanceTo(GAME.player.position) < 2.5) {
                GAME.hp -= 0.5; updateUI();
                const overlay = document.getElementById('damage-overlay');
                overlay.style.opacity = 0.5; setTimeout(() => overlay.style.opacity = 0, 100);
                if(GAME.hp <= 0) { alert('ä»»åŠ¡å¤±è´¥'); location.reload(); }
            }
            if(e.userData.hp <= 0) {
                createExplosion(e.position, 0x00ff00);
                bar.remove(); GAME.scene.remove(e); GAME.enemies.splice(i, 1);
            }
        });

        // 7. å­å¼¹ç²’å­
        for(let i=GAME.bullets.length-1; i>=0; i--) {
            const b = GAME.bullets[i]; b.position.addScaledVector(b.userData.vel, dt);
            if(b.userData.type==='rocket' && b.position.y < 0) {
                createExplosion(b.position, 0xff5500); 
                GAME.enemies.forEach(e => { if(e.position.distanceTo(b.position)<15) e.userData.hp-=30; });
                GAME.scene.remove(b); GAME.bullets.splice(i,1);
            } else if(b.position.distanceTo(GAME.player.position)>100) {
                GAME.scene.remove(b); GAME.bullets.splice(i,1);
            }
        }
        updateParticles(dt);

        GAME.renderer.render(GAME.scene, GAME.camera);
    }

    // --- ç‰¹æ•ˆ ---
    function createTracer(start, end) {
        const mat = new THREE.LineBasicMaterial({color: 0xffaa00, transparent:true, opacity:0.8});
        const geo = new THREE.BufferGeometry().setFromPoints([start, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line); setTimeout(() => GAME.scene.remove(line), 50);
    }
    function createLightning(start, end) {
        const mid = new THREE.Vector3().lerpVectors(start, end, 0.5).add(new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5));
        const mat = new THREE.LineBasicMaterial({color: 0x00ffff});
        const geo = new THREE.BufferGeometry().setFromPoints([start, mid, end]);
        const line = new THREE.Line(geo, mat);
        GAME.scene.add(line); setTimeout(() => GAME.scene.remove(line), 100);
    }
    function createExplosion(pos, color) {
        for(let i=0; i<15; i++) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshBasicMaterial({color: color}));
            p.position.copy(pos);
            const vel = new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5).multiplyScalar(15);
            GAME.particles.push({mesh:p, vel:vel, life:1.0}); GAME.scene.add(p);
        }
    }
    function createSparkle(pos, color, count) { createExplosion(pos, color); }
    function updateParticles(dt) {
        for(let i=GAME.particles.length-1; i>=0; i--) {
            const p = GAME.particles[i]; p.life -= dt;
            p.mesh.position.addScaledVector(p.vel, dt); p.vel.y -= 20*dt; p.mesh.scale.setScalar(p.life);
            if(p.life<=0 || p.mesh.position.y<0) { GAME.scene.remove(p.mesh); GAME.particles.splice(i,1); }
        }
    }
    function updateUI() {
        const w = GAME.weapons[GAME.curIdx];
        document.getElementById('ui-wp').innerText = w.name;
        document.getElementById('ui-ammo').innerText = w.curAmmo + '/' + w.mag;
        document.getElementById('ui-hp').innerText = Math.floor(GAME.hp);
        document.getElementById('btn-scope').style.display = w.sniper ? 'flex':'none';
        document.getElementById('btn-scope').style.background = GAME.isScoped?'rgba(0,255,255,0.8)':'rgba(0,255,255,0.3)';
    }

    // çª—å£è°ƒæ•´
    window.addEventListener('resize', () => {
        GAME.camera.aspect = window.innerWidth / window.innerHeight;
        GAME.camera.updateProjectionMatrix();
        GAME.renderer.setSize(window.innerWidth, window.innerHeight);
    });

</script>
</body>
</html>