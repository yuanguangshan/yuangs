<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ËØóËØç ¬∑ Â∞èÁ∫¢‰π¶È£éÊ†º</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Light theme variables - Xiaohongshu Style */
            --xhs-pink: #FE2C55;
            --xhs-pink-light: #FF6B8A;
            --xhs-pink-lighter: #FFE5EB;
            --xhs-pink-pale: #FFF5F7;
            --bg-gradient-start: #FFFFFF;
            --bg-gradient-end: #FFF5F7;
            --bg-gradient-mid: #FFFAFC;
            --container-bg: rgba(255, 255, 255, 0.98);
            --container-shadow: rgba(254, 44, 85, 0.08);
            --header-gradient-start: #FE2C55;
            --header-gradient-end: #FF6B8A;
            --header-gradient-mid: #FE4569;
            --header-color: white;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-tertiary: #999999;
            --text-light: #BBBBBB;
            --bg-light: #FAFAFA;
            --bg-lighter: #F5F5F5;
            --border-color: #EEEEEE;
            --filter-bg: rgba(255, 255, 255, 0.95);
            --poem-desc-bg: rgba(255, 255, 255, 0.98);
            --poem-desc-border: #FE2C55;
            --search-result-bg: #FAFAFA;
            --search-result-hover: #FFF5F7;
            --refresh-btn-gradient-start: #FE2C55;
            --refresh-btn-gradient-end: #FF6B8A;
            --refresh-btn-color: white;
            --clear-btn-bg: #999999;
            --clear-btn-hover: #666666;
            --search-btn-bg: #FE2C55;
            --search-btn-hover: #E02548;
            --footer-color: #999999;
            --accent-glow: rgba(254, 44, 85, 0.2);
            --card-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            --card-shadow-hover: 0 4px 20px rgba(254, 44, 85, 0.15);
        }

        .dark-mode {
            /* Dark theme variables - Xiaohongshu Dark Style with improved contrast */
            --xhs-pink: #FF6B8A;
            --xhs-pink-light: #FF8FA8;
            --xhs-pink-lighter: #FFB3C6;
            --xhs-pink-pale: #3A1A25;
            --bg-gradient-start: #0A0A0A;
            --bg-gradient-end: #1A0F1F;
            --bg-gradient-mid: #120C16;
            --container-bg: rgba(30, 30, 30, 0.97);
            --container-shadow: rgba(0, 0, 0, 0.7);
            --header-gradient-start: #E02548;
            --header-gradient-end: #FF6B8A;
            --header-gradient-mid: #F23669;
            --header-color: #FFFFFF;
            --text-primary: #FFFFFF;
            --text-secondary: #E0E0E0;
            --text-tertiary: #C0C0C0;
            --text-light: #A0A0A0;
            --bg-light: #1F1F1F;
            --bg-lighter: #262626;
            --border-color: #555555;
            --filter-bg: rgba(30, 30, 30, 0.95);
            --poem-desc-bg: rgba(25, 25, 25, 0.98);
            --poem-desc-border: #FF6B8A;
            --search-result-bg: #262626;
            --search-result-hover: #3A2A3A;
            --refresh-btn-gradient-start: #E02548;
            --refresh-btn-gradient-end: #FF6B8A;
            --refresh-btn-color: #FFFFFF;
            --clear-btn-bg: #666666;
            --clear-btn-hover: #777777;
            --search-btn-bg: #E02548;
            --search-btn-hover: #C01830;
            --footer-color: #B0B0B0;
            --accent-glow: rgba(255, 107, 138, 0.4);
            --card-shadow: 0 2px 12px rgba(0, 0, 0, 0.5);
            --card-shadow-hover: 0 4px 20px rgba(255, 107, 138, 0.3);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 0;
            color: var(--text-primary);
            transition: background 0.5s ease;
        }

        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            overflow: visible;
            margin: 0 auto;
            padding: 0 15px;
        }

        @media (min-width: 768px) {
            .container {
                margin: 20px auto;
            }
        }

        header {
            text-align: center;
            padding: 20px 15px;
            background: var(--container-bg);
            color: var(--text-primary);
            position: relative;
            box-shadow: var(--card-shadow);
            border-radius: 20px;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            header {
                padding: 30px 20px;
            }
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            text-shadow: none;
            letter-spacing: 0.02em;
            font-weight: 600;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            color: var(--xhs-pink);
        }

        .subtitle {
            font-size: 0.95rem;
            opacity: 0.75;
            font-weight: 400;
            letter-spacing: 0.01em;
            color: var(--text-secondary);
        }

        .dark-mode-toggle {
            position: absolute;
            top: 15px;
            right: 15px;
            background: var(--bg-lighter);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1.1rem;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: var(--card-shadow);
        }

        .dark-mode-toggle:hover {
            background: var(--xhs-pink-lighter);
            transform: scale(1.05);
            box-shadow: var(--card-shadow-hover);
        }

        .header-search-btn {
            position: absolute;
            top: 10px;
            right: 60px;
            /* Position to the left of the dark mode toggle */
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--header-color);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header-search-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        @media (min-width: 768px) {
            .dark-mode-toggle {
                top: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }

            .header-search-btn {
                top: 20px;
                right: 75px;
                /* Adjust for larger screen */
                width: 45px;
                height: 45px;
            }
        }

        .poem-content {
            display: flex;
            flex-direction: column;
            padding: 0;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .poem-content {
                flex-direction: row;
                padding: 20px;
                min-height: 600px;
            }
        }

        @media (max-width: 767px) {
            .poem-content {
                padding: 5px;
            }
        }

        .poem-section {
            background: var(--container-bg);
            border-radius: 15px;
            box-shadow: var(--card-shadow);
            padding: 0px;
            transition: box-shadow 0.3s ease;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .poem-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        @media (min-width: 768px) {
            .poem-section {
                padding: 0px;
                /* Reduced from 20px to 10px */
            }
        }

        .image-section {
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 280px;
            max-height: 380px;
        }

        @media (min-width: 768px) {
            .image-section {
                padding: 0;
                margin: 0;
                min-height: 380px;
                max-height: 380px;
            }
        }

        .poem-image {
            width: 100%;
            max-width: 100%;
            height: 100%;
            aspect-ratio: 4/3;
            border-radius: 15px 15px 0 0;
            object-fit: cover;
            box-shadow: none;
            transition: transform 0.3s ease;
            border: none;
            margin: 0;
            padding: 0;
        }

        .poem-image:hover {
            transform: scale(1.01);
            box-shadow: none;
        }

        .text-section {
            position: relative;
            /* For placing seals */
            background-color: #fffdf7;
            /* Rice paper yellow background */
            background-image:
                radial-gradient(at 20% 30%, rgba(245, 240, 220, 0.7) 0px, transparent 50%),
                radial-gradient(at 80% 70%, rgba(240, 235, 210, 0.6) 0px, transparent 50%);
            padding: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1;
            border-radius: 0 0 15px 15px;
            /* Match the image section's top border radius */
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
            /* Subtle inner shadow for depth */
        }

        /* Dark mode text-section - use better contrasting background */
        .dark-mode .text-section {
            background-color: #2a2a2a;
            background-image:
                radial-gradient(at 20% 30%, rgba(70, 70, 70, 0.5) 0px, transparent 50%),
                radial-gradient(at 80% 70%, rgba(60, 60, 60, 0.4) 0px, transparent 50%);
            color: var(--text-primary);
        }

        /* Ensure poem text colors in dark mode have good contrast */
        .dark-mode .poem-verse {
            color: var(--text-secondary);
        }

        .dark-mode .poem-verse.vertical-mode,
        .dark-mode .poem-verse.horizontal-mode {
            color: var(--text-primary);
        }

        /* Vertical text layout for regular poems (shi) */
        .text-section.vertical-text {
            align-items: center;
        }

        .poem-verse.vertical-layout {
            display: flex;
            flex-direction: column;
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            font-size: 1.4rem;
            letter-spacing: 0.4em;
            line-height: 1.7;
            color: var(--text-secondary);
            text-align: center;
            margin: 0 auto;
            height: auto;
            white-space: nowrap;
        }

        .vertical-line {
            display: inline-flex;
            flex-direction: column;
        }

        .vertical-char {
            margin: 2px 0;
        }

        /* Enhanced styles for improved default mode */

        /* Dynasty tag styling */
        .poem-author-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
            justify-content: center;
        }

        .dynasty-tag {
            background-color: var(--xhs-pink);
            color: white;
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: sans-serif;
            /* Ë°¨Á∫ø‰ΩìÈÖçÊó†Ë°¨Á∫øÊ†áÁ≠æ */
            vertical-align: middle;
        }

        .dark-mode .dynasty-tag {
            background-color: var(--xhs-pink-light);
            color: #ffffff;
        }

        /* Ê≠£ÊñáÊéíÁâàÂÆπÂô® */
        .poem-verse-container {
            position: relative;
            padding: 10px;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Á´ñÊéíÊ®°Âºè (ÂÖ≥ÈîÆ‰ºòÂåñ) */
        .poem-verse.vertical-mode {
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-size: 1.6rem;
            letter-spacing: 0.4em;
            line-height: 2.1;
            /* Reduced from 2.5 */
            height: auto;
            max-height: 500px;
            /* Èò≤Ê≠¢ËøáÈ´ò */
            text-align: justify;
            margin: 0 auto;
            font-family: 'Noto Serif SC', serif;
        }

        .dark-mode .poem-verse.vertical-mode {
            color: var(--text-primary);
        }

        /* Ê®™ÊéíÊ®°Âºè‰ºòÂåñ */
        .poem-verse.horizontal-mode {
            font-size: 1.6rem;
            line-height: 1.9;
            text-align: center;
            max-width: 95%;
        }

        .dark-mode .poem-verse.horizontal-mode {
            color: var(--text-primary);
        }

        /* Couplets for 7-character poems - display two lines together */
        /* Á°Æ‰øùËøôÊòØÊúÄÊñ∞ÁöÑÊ†∑Âºè */
        .couplet-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            /* ÂÖ≥ÈîÆÔºöÂéªÊéâÂ§ñËæπË∑ù */
            padding: 10px 0;
            /* ÂÖ≥ÈîÆÔºöÂè™Áî®ÂÜÖËæπË∑ùÊéßÂà∂Ôºå10px-12px ÊØîËæÉÂêàÈÄÇ */
            border-bottom: 1px dashed rgba(128, 128, 128, 0.15);
            width: 100%;
        }

        /* Á®çÂæÆÂ¢ûÂä†‰∏ÄÁÇπË°åÂÜÖÊñáÂ≠óÁöÑÁ¥ßÂáëÂ∫¶ÔºåËÆ©‰∏§Ë°åËØóÈù†ËøëÔºåËøôÊ†∑ÁªÑ‰∏éÁªÑÁöÑÂå∫ÂàÜÂ∫¶Êõ¥Â•Ω */
        .horizontal-mode .couplet-row {
            line-height: 1.6;
        }

        .dark-mode .couplet-row {
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        /* This seal will be used in the main display */
        .main-seal {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 40px;
            height: 40px;
            font-size: 18px;
            border: 2px solid #d44c4c;
            color: #d44c4c;
            background: rgba(255, 255, 255, 0.8);
            opacity: 0.8;
            transform: rotate(-5deg);
            pointer-events: none;
            /* ‰∏çÊå°Èº†Ê†á */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
        }

        .dark-mode .main-seal {
            background: rgba(40, 40, 40, 0.9);
            color: #FF6B8A;
            border-color: #FF6B8A;
        }

        /* Adjusted description section styling */
        .desc-section {
            /* ÂèòÊàê‰∏Ä‰∏™Á®çÂæÆÊ∑±‰∏ÄÁÇπÁöÑËÉåÊôØÔºåÂÉè‰π¶ÁöÑÂ∞ÅÂ∫ï */
            background: #fdfdfd;
            border-left: 4px solid var(--xhs-pink-lighter);
            /* Â∑¶‰æßË£ÖÈ•∞Á∫ø */
        }

        .dark-mode .desc-section {
            background: #222222;
            border-left: 4px solid var(--xhs-pink-light);
            /* Â∑¶‰æßË£ÖÈ•∞Á∫ø in dark mode */
        }

        .poem-desc {
            font-size: 1rem;
            color: #555;
            text-align: justify;
            /* ‰∏§Á´ØÂØπÈΩêÊõ¥ÂÉè‰π¶ */
        }

        .dark-mode .poem-desc {
            color: var(--text-tertiary);
        }

        /* È¶ñÂ≠ó‰∏ãÊ≤âÊïàÊûú (ÂèØÈÄâ) */
        .poem-desc::first-letter {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--xhs-pink);
            float: left;
            margin-right: 4px;
            line-height: 1;
        }

        .dark-mode .poem-desc::first-letter {
            color: var(--xhs-pink-light);
        }

        /* Seal decoration for default mode */
        .seal-default-mode {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background-color: rgba(180, 30, 30, 0.7);
            color: white;
            border-radius: 50%;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: serif;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 11;
            opacity: 0.8;
        }

        @media (min-width: 768px) {
            .text-section {
                padding: 10px;
            }
        }

        .poem-title {
            font-size: 2.0rem;
            /* Reduced from 2.2rem to 2.0rem */
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 12px;
            font-weight: 700;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            letter-spacing: 0.05em;
            line-height: 1.3;
            padding: 0 10px;
            position: relative;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .inline-search-btn {
            background: rgba(99, 102, 241, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .inline-search-btn.absolute-position {
            position: absolute;
            top: 20px;
            /* Adjust to align with title */
            right: 10px;
            /* Position to the right */
        }

        .inline-search-btn:hover {
            background: rgba(107, 114, 128, 0.3);
            transform: scale(1.15);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .ai-interpret-btn {
            background: rgba(99, 102, 241, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .ai-interpret-btn.absolute-position {
            position: absolute;
            top: 20px;
            /* Align with title text */
            right: 10px;
            /* Position to the right of the title */
        }

        .ai-interpret-btn:hover {
            background: rgba(107, 114, 128, 0.3);
            transform: scale(1.15);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .positioned-title {
            position: relative;
        }

        .poem-author {
            font-size: 1.3rem;
            /* Increased from 1.1rem to 1.3rem */
            color: var(--text-tertiary);
            text-align: center;
            margin-bottom: 12px;
            font-style: normal;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            letter-spacing: 0.02em;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .poem-type {
            font-size: 1.1rem;
            /* Increased from 0.9rem to 1.1rem */
            color: var(--xhs-pink);
            text-align: center;
            margin-bottom: 18px;
            background: var(--xhs-pink-lighter);
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            align-self: center;
            font-weight: 500;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .poem-verse {
            font-size: 1.6rem;
            /* Increased from 1.2rem to 1.6rem for larger text */
            line-height: 1.9;
            /* Adjusted line height for better readability */
            color: var(--text-secondary);
            text-align: center;
            margin: 0;
            font-weight: 400;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            letter-spacing: 0.03em;
            white-space: normal;
            /* Allow line breaks */
            word-wrap: break-word;
            /* Break long words if needed */
        }

        /* Ensure <br> tags create line breaks */
        .poem-verse br {
            display: block;
        }

        /* Make sure poem verse allows line breaks */
        .poem-verse {
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        /* Paragraph breaks between sections of poems */
        .poem-paragraph-break {
            display: block;
            height: 1.5em;
            /* Create visual separation between poem sections */
        }

        .desc-section {
            background: var(--container-bg);
            border-radius: 20px;
            box-shadow: var(--card-shadow);
            padding: 10px;
            /* Reduced from 20px to 10px */
            transition: box-shadow 0.3s ease;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .desc-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        @media (min-width: 768px) {
            .desc-section {
                padding: 15px;
                /* Reduced from 20px to 15px */
            }
        }

        .poem-desc {
            font-size: 1.1rem;
            /* Increased from 0.95rem to 1.1rem */
            line-height: 1.7;
            /* Reduced from 1.8 to 1.7 */
            color: var(--text-tertiary);
            padding: 0;
            background: transparent;
            border-radius: 0;
            border-left: none;
            height: 100%;
            overflow-y: auto;
            flex: 1;
        }

        .poem-desc a {
            color: #4da6ff;
            text-decoration: underline;
        }

        .poem-desc a:hover {
            color: #66b3ff;
        }

        @media (min-width: 768px) {
            .poem-desc {
                padding: 20px;
            }
        }

        .poem-desc h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .controls {
            text-align: center;
            padding: 0;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .controls {
                padding: 30px;
            }
        }

        .refresh-btn {
            background: linear-gradient(135deg, var(--refresh-btn-gradient-start) 0%, var(--refresh-btn-gradient-end) 100%);
            color: var(--refresh-btn-color);
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--card-shadow);
            font-weight: 600;
            letter-spacing: 0.01em;
            position: relative;
            overflow: hidden;
        }

        .refresh-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .refresh-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--card-shadow-hover);
        }

        .refresh-btn:active {
            transform: translateY(0);
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2rem;
            color: #666;
        }

        .poem-meta {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .poem-meta span {
            background: #e9ecef;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
            color: #555;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: var(--footer-color);
            font-size: 0.85rem;
            margin-top: 20px;
        }

        @media (min-width: 768px) {
            footer {
                padding: 20px;
            }
        }

        /* Animation for content loading */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.8s ease forwards;
        }

        .filter-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            padding: 18px;
            background: var(--container-bg);
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            transition: box-shadow 0.3s ease;
        }

        .filter-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        .filter-section label {
            font-weight: bold;
            color: var(--text-primary);
            white-space: nowrap;
            display: flex;
            align-items: center;
            min-height: 40px;
            /* Consistent height */
            padding: 0 5px;
            /* Uniform padding */
            box-sizing: border-box;
            /* Include padding in height calculation */
        }

        .filter-section select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--container-bg);
            color: var(--text-primary);
            font-size: 1rem;
            min-width: 120px;
            flex: 1;
            min-width: 0;
            /* Allow it to shrink below min-width */
            height: 40px;
            /* Fixed height to ensure consistency */
            min-height: 40px;
            /* Consistent height */
            box-sizing: border-box;
            /* Include padding in height calculation */
            line-height: 1.2;
            /* Control text alignment inside the select */
        }

        .filter-section button {
            padding: 8px 16px;
            background: var(--clear-btn-bg);
            color: var(--refresh-btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-height: 40px;
            /* Consistent height */
            box-sizing: border-box;
            /* Include padding in height calculation */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .filter-section button:hover {
            background: var(--clear-btn-hover);
        }

        .search-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            padding: 18px;
            background: var(--container-bg);
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            transition: box-shadow 0.3s ease;
        }

        .search-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        .search-section.show {
            display: flex;
        }

        .search-section input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 1rem;
            min-width: 200px;
            flex: 1;
            background: var(--container-bg);
            color: var(--text-primary);
        }

        .search-section button {
            padding: 8px 16px;
            background: var(--search-btn-bg);
            color: var(--refresh-btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .search-section button:nth-child(3) {
            background: var(--clear-btn-bg);
            /* Different color for clear button */
        }

        .search-section button:hover {
            background: var(--search-btn-hover);
        }

        .search-section button:nth-child(3):hover {
            background: var(--clear-btn-hover);
            /* Different hover for clear button */
        }



        .search-toggle-btn {
            background: #17a2b8 !important;
            /* Override default button color */
            display: flex !important;
            align-items: center !important;
            gap: 4px !important;
        }

        .search-toggle-btn:hover {
            background: #138496 !important;
        }

        .search-results {
            margin-bottom: 20px;
            padding: 20px;
            background: var(--container-bg);
            border-radius: 20px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
        }

        .search-results h3 {
            margin-top: 0;
            color: var(--text-primary);
            text-align: center;
        }

        .search-results ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .search-results li {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            color: var(--text-tertiary);
        }

        .search-results li:hover {
            background-color: var(--search-result-hover);
        }

        .search-results .result-title {
            font-weight: bold;
            color: #4da6ff;
        }

        .search-results .result-author {
            font-style: italic;
            color: var(--text-light);
            font-size: 0.9em;
        }

        .search-results .result-preview {
            margin-top: 4px;
            color: var(--text-tertiary);
            font-size: 0.9em;
        }

        /* Mobile-specific styles for filter section */
        @media (max-width: 767px) {
            .filter-section {
                flex-direction: row;
                flex-wrap: nowrap;
                /* Keep items in a single line */
                align-items: center;
                padding: 8px;
                margin: 5px;
                gap: 3px;
                min-height: 40px;
            }

            .filter-section label {
                font-size: 0.65rem;
                white-space: nowrap;
                margin: 0;
                flex-shrink: 0;
                min-height: 34px;
                /* Consistent height for mobile */
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0 2px;
                /* Uniform padding for mobile */
            }

            .filter-section select {
                min-width: 0;
                font-size: 0.65rem;
                padding: 2px 4px;
                /* Adjusted padding for better height consistency */
                flex: 1 1 auto;
                height: 34px;
                /* Fixed height to ensure consistency */
                min-height: 34px;
                /* Consistent height for mobile */
                max-width: 70px;
                /* Further reduce width to fit all elements */
                flex-basis: 70px;
                box-sizing: border-box;
                /* Include padding in height calculation */
                line-height: 1.2;
                /* Control text alignment inside the select */
            }

            .filter-section button {
                font-size: 0.65rem;
                padding: 2px 4px;
                min-height: 34px;
                /* Consistent height for mobile */
                white-space: nowrap;
                flex: 0 0 auto;
                /* Prevent button from shrinking */
                min-width: 50px;
                /* Ensure minimum button width for tap targets */
                box-sizing: border-box;
                /* Include padding in height calculation */
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .search-toggle-btn {
                min-width: 45px !important;
                /* Smaller width for search button on mobile */
                padding: 2px 3px !important;
                /* Smaller padding on mobile */
                font-size: 0.6rem !important;
                /* Smaller font on mobile */
            }
        }

        /* Stack elements on very narrow screens */
        @media (max-width: 400px) {
            .filter-section {
                flex-wrap: wrap;
                /* Allow wrapping if too narrow */
                flex-direction: row;
                align-content: center;
            }
        }

        /* Mobile-specific styles for search section */
        @media (max-width: 767px) {
            .search-section {
                flex-direction: row;
                flex-wrap: wrap;
                padding: 8px;
                margin: 5px;
                gap: 4px;
            }

            .search-section input {
                font-size: 0.8rem;
                padding: 5px;
                min-width: 100px;
                flex: 2;
                min-height: 30px;
            }

            .search-section button {
                font-size: 0.8rem;
                padding: 5px 8px;
                min-height: 30px;
                flex: 1;
            }
        }

        @media (max-width: 480px) {
            .search-section {
                flex-direction: column;
            }

            .search-section input {
                width: 100%;
            }

            .search-section button {
                width: 100%;
            }
        }

        /* Poetry-specific styling */
        strong {
            color: #667eea;
            font-weight: bold;
        }

        p {
            margin: 10px 0;
        }

        mark {
            background-color: #ffeb3b;
            padding: 0 2px;
            border-radius: 2px;
        }

        .floating-refresh-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--refresh-btn-gradient-start) 0%, var(--refresh-btn-gradient-end) 100%);
            color: white;
            border: none;
            font-size: 22px;
            cursor: pointer;
            box-shadow: var(--card-shadow-hover);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
            animation: float 3s ease-in-out infinite;
            pointer-events: auto;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-8px);
            }
        }

        .floating-refresh-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px rgba(254, 44, 85, 0.4);
            animation: none;
        }

        /* Mobile-specific styles for floating button */
        @media (max-width: 767px) {
            .floating-refresh-btn {
                bottom: 20px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* Waterfall Flow Layout */
        .waterfall-container {
            display: none;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px 5px;
            /* Reduced from 20px 10px to save space */
        }

        .waterfall-container.active {
            display: block;
        }

        .waterfall-content {
            column-count: 2;
            column-gap: 12px;
            /* Reduced from 20px to save space */
        }

        @media (max-width: 1024px) {
            .waterfall-content {
                column-count: 2;
            }
        }

        @media (max-width: 767px) {
            .waterfall-content {
                column-count: 1;
            }
        }

        /* On very wide screens, allow 3 columns */
        @media (min-width: 1400px) {
            .waterfall-content {
                column-count: 3;
            }
        }

        .waterfall-card {
            display: block;
            background: var(--container-bg);
            border-radius: 20px;
            overflow: hidden;
            margin-bottom: 15px;
            /* Increased from 12px for better spacing */
            break-inside: avoid;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
            cursor: pointer;
            height: 340px;
            /* Increased from 300px for better proportions */
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(254, 44, 85, 0.08);
            /* Subtle border for depth */
        }

        .waterfall-card:hover {
            transform: translateY(-5px) scale(1.02);
            /* Added subtle scale */
            box-shadow: var(--card-shadow-hover);
        }

        .color-block {
            width: 100%;
            height: 200px;
            /* Increased from 170px for better text visibility */
            display: block;
            position: relative;
            /* Add subtle gradient overlay for depth */
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.05) 0%, rgba(255, 255, 255, 0.05) 100%);
        }

        .overlay-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 20px;
        }

        .dark-mode .overlay-text {
            color: #ffffff;
        }

        /* Mode 1: Vertical layout (suitable for 5/7-character poems) */
        .layout-vertical {
            flex-direction: row-reverse;
            /* Ancient Chinese reads from right to left */
            gap: 12px;
        }

        .layout-vertical .poem-line {
            writing-mode: vertical-rl;
            /* Vertical text */
            text-orientation: upright;
            font-family: 'Noto Serif SC', serif;
            font-size: 1.4rem;
            /* Vertical text can be larger */
            letter-spacing: 0.3em;
            /* Increase letter spacing for more breathing room */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            /* Decorative line */
            padding-left: 8px;
        }

        .layout-vertical .poem-line:last-child {
            border-left: none;
        }

        .dark-mode .layout-vertical .poem-line {
            color: rgba(255, 255, 255, 0.98);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        /* Mode 2: Horizontal center layout (suitable for ci/named phrases) */
        .layout-horizontal-center {
            flex-direction: column;
            gap: 16px;
        }

        .layout-horizontal-center .poem-line {
            font-family: 'Noto Serif SC', serif;
            font-size: 1.3rem;
            letter-spacing: 0.1em;
            color: white;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
            position: relative;
        }

        .dark-mode .layout-horizontal-center .poem-line {
            color: #ffffff;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        /* Add decoration like quotes for horizontal quotes */
        .layout-horizontal-center::before {
            content: "" ";
 font-family: serif;
            font-size: 4rem;
            position: absolute;
            top: 10px;
            left: 15px;
            opacity: 0.3;
            color: white;
        }

        /* Fallback for default layout - keep the original styling */
        .layout-horizontal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            /* Increased from 1rem for better readability */
            font-weight: 500;
            text-align: center;
            width: 98%;
            /* Reduced from 85% for better centering */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            /* Enhanced shadow for better contrast */
            z-index: 10;
            /* Allow text to wrap to multiple lines */
            white-space: normal;
            word-wrap: break-word;
            overflow: hidden;
            /* Keep text within bounds */
            line-height: 1.8;
            /* Increased from 1.6 for seven-character poems */
            letter-spacing: 0.05em;
            /* Better spacing for Chinese characters */
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            /* Use Chinese typography for proper character alignment */
        }

        .seal-decoration {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 28px;
            height: 28px;
            background-color: rgba(200, 30, 30, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: serif;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 11;
            opacity: 0.8;
        }

        .color-block-container {
            position: relative;
            width: 100%;
            height: 200px;
            /* Increased from 170px for better text visibility */
            border-radius: 20px 20px 0 0;
            overflow: hidden;
        }

        .waterfall-content-section {
            padding: 12px 15px;
            /* Increased from 4px 6px for better spacing */
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            /* Add gap between title and author */
        }

        .waterfall-title {
            font-size: 1rem;
            /* Increased from 0.9rem for better readability */
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .waterfall-author {
            font-size: 0.8rem;
            /* Increased from 0.75rem for better readability */
            color: var(--text-tertiary);
            margin: 0;
            /* Removed margin, using gap in parent instead */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .poem-content.symmetric-layout {
            display: flex;
        }

        .poem-content.waterfall-layout {
            display: none;
        }

        .poem-content.waterfall-active {
            display: none;
        }

        .poem-content.symmetric-active {
            display: flex;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>Âè§ÂÖ∏ËØóËØç</h1>
            <div class="subtitle">ÂìÅÂë≥ÂçÉÂπ¥ÊñáÂåñÔºåÊÑüÂèóËØóËØç‰πãÁæé</div>
            <button id="darkModeToggle" class="dark-mode-toggle" title="ÂàáÊç¢Ê∑±Ëâ≤Ê®°Âºè">
                üåô
            </button>
        </header>

        <div class="controls">
            <div class="filter-section">
                <label for="authorFilter"></label>
                <select id="authorFilter" onchange="filterByAuthor()">
                    <option value="">‰ΩúËÄÖ</option>
                </select>
                <label for="poemList"></label>
                <select id="poemList" onchange="selectPoem()">
                    <option value="">‰ΩúÂìÅ</option>
                </select>
                <button class="refresh-btn" onclick="clearFilter()">Ê∏ÖÈô§</button>
                <button class="refresh-btn search-toggle-btn" onclick="toggleSearch()">üîç ÊêúËØóËØç</button>
                <button class="refresh-btn" id="layoutToggle" onclick="toggleLayout()">ÁÄëÂ∏ÉÊµÅ</button>
            </div>

            <!-- Search Section (Initially Hidden) -->
            <div id="searchSection" class="search-section" style="display: none;">
                <input type="text" id="searchInput" placeholder="ÊêúÁ¥¢ËØóÊ≠åÊ†áÈ¢òÊàñÊ≠£Êñá..." onkeypress="handleSearchKeyPress(event)">
                <button class="refresh-btn" onclick="performSearch()">ÊêúÁ¥¢</button>
                <button class="refresh-btn" onclick="hideSearch()">Êî∂Ëµ∑</button>
            </div>

            <!-- Search Results Section -->
            <div id="searchResults" class="search-results" style="display: none;">
                <h3>ÊêúÁ¥¢ÁªìÊûú</h3>
                <ul id="searchResultsList"></ul>
            </div>
        </div>

        <div class="poem-content">
            <div class="poem-section">
                <div class="image-section">
                    <img id="poemImage" class="poem-image fade-in" src="" alt="ËØóËØçÈÖçÂõæ">
                </div>
                <div class="text-section">
                    <div id="loading" class="loading">ËØóËØçÂä†ËΩΩ‰∏≠...</div>

                    <div id="poemTextContent"
                        style="display: none; width: 100%; display: flex; flex-direction: column; align-items: center;">

                        <!-- Â§¥ÈÉ®ÁªÑÂêàÔºöÊ†áÈ¢ò+‰ΩúËÄÖ -->
                        <div class="poem-header-group">
                            <div class="poem-meta"
                                style="margin-bottom: 10px; display: flex; justify-content: center; gap: 10px;">
                                <!-- ÊêúÁ¥¢ÊåâÈíÆ‰øùÁïô -->
                                <button id="inlineSearchBtn" class="inline-search-btn" title="ÊêúÁ¥¢ËØóËØçËµèÊûê">üîç</button>
                                <button onclick="copyPoemToClipboard()" class="inline-search-btn"
                                    title="Â§çÂà∂ËØóËØç">üìã</button>
                                <button id="ai-interpret-btn" class="ai-interpret-btn" title="AIËß£ËØªËØóËØç">
                                    üí°
                                </button>
                            </div>
                            <div style="position: relative; width: 100%; min-height: 60px;">
                                <h2 id="poemTitle" class="poem-title positioned-title"></h2>
                            </div>
                            <div class="poem-author-badge">
                                <span id="poemDynasty" class="dynasty-tag">Âîê</span> <!-- Âä®ÊÄÅÂπ¥‰ªΩ -->
                                <span id="poemAuthor"></span>
                            </div>
                        </div>

                        <!-- Ê≠£ÊñáÂÆπÂô® -->
                        <div class="poem-verse-container">
                            <div id="poemVerse" class="poem-verse"></div>
                            <!-- Â§ßÂç∞Á´† (will be updated dynamically) -->
                            <div class="seal-decoration main-seal" id="mainTypeSeal">ËØó</div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="desc-section">
                <div id="poemDescContent" style="display: none;">
                    <div class="poem-desc" id="poemDesc"></div>
                </div>
            </div>
        </div>

        <!-- Waterfall Flow Container -->
        <div id="waterfallContainer" class="waterfall-container">
            <div id="waterfallContent" class="waterfall-content">
                <!-- Waterfall cards will be dynamically generated here -->
            </div>
        </div>

        <!-- Floating Refresh Button -->
        <button class="floating-refresh-btn" onclick="refreshContent()" title="Âà∑Êñ∞ÂÜÖÂÆπ">
            ‚ôªÔ∏è
        </button>

        <footer>
            <p>Powered by yuangs| ÈöèÊú∫Â±ïÁ§∫ÁªèÂÖ∏ËØóËØç</p>
        </footer>

        <script>
            // Store all poems and ci globally after first fetch
            let allPoems = null;
            let allCi = null;
            let allCombined = null; // Combined poems and ci
            let filteredPoems = null; // Store currently filtered poems

            // Image cache to store latest 20 images
            let imageCache = [];
            const MAX_CACHE_SIZE = 20;

            // Function to add image to cache
            function addToImageCache(imgUrl) {
                // Check if image is already in cache
                const existingIndex = imageCache.indexOf(imgUrl);
                if (existingIndex !== -1) {
                    // Move to front if already in cache
                    imageCache.splice(existingIndex, 1);
                } else if (imageCache.length >= MAX_CACHE_SIZE) {
                    // Remove oldest item if cache is full
                    imageCache.pop();
                }
                // Add to front of cache
                imageCache.unshift(imgUrl);
            }

            // Function to get a random cached image
            function getRandomCachedImage() {
                if (imageCache.length === 0) {
                    return null;
                }
                // Return a random image from the cache
                return imageCache[Math.floor(Math.random() * imageCache.length)];
            }

            // Define color palettes with enhanced color schemes
            const colorPalettes = [
                // First color group - based on #00695B teal green
                ['#00695B', '#2F9C8D', '#148374', '#005045', '#00362F', '#006927', '#004269', '#5B0069', '#695B00', '#69000E', '#260069', '#426900', '#692700', '#690043', '#88485e', '#316742', '#006771', '#635587', '#7c5233', '#405e8d', '#685b2a', '#7c4c75', '#874b46'],
                // Second color group - based on #88485E purple pink
                ['#88485E', '#BB96A2', '#A26E80', '#6F2A41', '#55142A', '#88487E', '#885248', '#5E8848', '#485E88', '#7E8848', '#488872', '#524888', '#488852', '#487E88', '#7c4c76', '#316743', '#006771', '#4f6330', '#0d6586', '#685b2a', '#02695b', '#415e8d', '#316743', '#006771'],
                // Third color group - based on #AF52DE purple blue
                ['#AF52DE', '#CC9AE5', '#D081F7', '#912BC5', '#760CAB', '#6952DE', '#DE52C7', '#DEAF52', '#52DEAF', '#DE6952', '#81DE52', '#52C7DE', '#C7DE52', '#52DE69', '#3f75ff', '#e121a2', '#a57000', '#008b89', '#d8481d', '#009001', '#0088a4', '#778200', '#008d66'],
                // Fourth color group - based on #657786 blue gray
                ['#657786', '#867465', '#658684', '#656686', '#866577', '#778665', '#846586', '#678665', '#94A8B9', '#9098A0', '#42596D', '#263E53', '#877466', '#777561', '#876f69'],
                // Additional LCH color groups
                ['#8fe4d2', '#65b9a9', '#3b9081', '#00695B', '#88485e', '#316742', '#006771', '#635587', '#7c5233', '#405e8d', '#685b2a', '#7c4c75', '#874b46'],
                ['#ffc4d5', '#dd95ac', '#b26e84', '#88485E', '#02695b', '#7c4c76', '#316743', '#4f6330', '#0d6586', '#685b2a', '#02695b', '#415e8d', '#316743', '#006771'],
                ['#f2d2ff', '#e3a4ff', '#d174ff', '#AF52DE', '#009001', '#778200', '#008d66', '#a57000', '#008b89', '#d8481d', '#009001', '#0088a4', '#778200', '#008d66'],
                ['#cadeee', '#a7baca', '#8598a8', '#657786', '#817263', '#5e7980', '#707487', '#886e72', '#6d7865', '#846e7c', '#817263', '#637a6d', '#876f69', '#777561']
            ];

            // Function to get a random color from the defined palettes
            function getRandomColor() {
                // Select a random palette
                const palette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];
                // Select a random color from that palette
                return palette[Math.floor(Math.random() * palette.length)];
            }

            // Function to fetch and cache Tang poems
            async function fetchAndCachePoems() {
                if (allPoems !== null) {
                    return allPoems;
                }

                const CACHE_KEY = 'tang_poems_cache_v2'; // Updated cache key to force refresh
                const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

                // Check if we have cached data and it's still valid
                const cachedData = localStorage.getItem(CACHE_KEY);
                if (cachedData) {
                    const { data, timestamp } = JSON.parse(cachedData);
                    const now = Date.now();

                    if (now - timestamp < CACHE_DURATION) {
                        // Cache is still valid - store in memory for subsequent requests
                        allPoems = data;
                        console.log("Using cached Tang poem data");
                        return allPoems;
                    }
                }

                // Fetch new data from the XML file
                try {
                    console.log("Fetching fresh Tang poem data from API...");
                    const response = await fetch('https://wealth.want.biz/pages/poem.xml');
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");

                    // Extract poem data from XML
                    const poemNodes = xmlDoc.querySelectorAll('node');
                    const poems = [];

                    poemNodes.forEach(node => {
                        const title = node.querySelector('title')?.textContent || '';
                        const auth = node.querySelector('auth')?.textContent || '';
                        const type = node.querySelector('type')?.textContent || '';
                        const content = node.querySelector('content')?.textContent || '';
                        const desc = node.querySelector('desc')?.textContent || '';

                        // Create a search link for analysis if no description is available
                        const searchQuery = encodeURIComponent(`${auth || ''} ${title || ''}`);
                        const searchLink = `https://chat.baidu.com/search?word=${searchQuery}&setype=csaitab`;

                        let finalDesc = desc;
                        if (!desc || desc.trim() === '') {
                            // If no description exists, create one with the AI search link
                            finalDesc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">üîç ÁÇπÂáªÊêúÁ¥¢ËØóËØçËµèÊûê</a></div>`;
                        } else {
                            // If description exists, prepend the AI search link above the description
                            finalDesc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">üîç ÁÇπÂáªÊêúÁ¥¢ËØóËØçËµèÊûê</a></div><br><br>${desc}`;
                        }

                        poems.push({
                            title: title,
                            auth: auth,
                            type: type,
                            content: content,
                            desc: finalDesc,
                            source: 'poem' // Mark as poem
                        });
                    });

                    // Cache the fetched data
                    const cacheData = {
                        data: poems,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));

                    // Store in memory for subsequent requests
                    allPoems = poems;

                    console.log(`Fetched and cached ${poems.length} Tang poems`);
                    return allPoems;
                } catch (error) {
                    console.error('Error fetching Tang poem data:', error);

                    // If fetching failed, try to return cached data even if it's expired
                    if (cachedData) {
                        const { data } = JSON.parse(cachedData);
                        console.warn("Using expired cached Tang poem data due to fetch error");
                        // Store expired data in memory temporarily
                        allPoems = data;
                        return allPoems;
                    }

                    // If no cached data is available, return an empty array
                    allPoems = [];
                    return allPoems;
                }
            }

            // Function to fetch and cache Song ci
            async function fetchAndCacheCi() {
                if (allCi !== null) {
                    return allCi;
                }

                const CACHE_KEY = 'song_ci_cache_v2'; // Updated cache key to force refresh
                const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

                // Check if we have cached data and it's still valid
                const cachedData = localStorage.getItem(CACHE_KEY);
                if (cachedData) {
                    const { data, timestamp } = JSON.parse(cachedData);
                    const now = Date.now();

                    if (now - timestamp < CACHE_DURATION) {
                        // Cache is still valid - store in memory for subsequent requests
                        allCi = data;
                        console.log("Using cached Song ci data");
                        return allCi;
                    }
                }

                // Fetch new data from the JSON file
                try {
                    console.log("Fetching fresh Song ci data from API...");
                    const response = await fetch('https://wealth.want.biz/pages/songci.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    const ciData = await response.json();

                    // Process ci data to match poem structure
                    const processedCi = ciData.map(ci => {
                        // Create a search link for analysis if no description is available
                        const searchQuery = encodeURIComponent(`${ci.author || ''} ${ci.rhythmic || ''}`);
                        const searchLink = `https://chat.baidu.com/search?word=${searchQuery}&setype=csaitab`;

                        let desc = '';
                        if (ci.tags && ci.tags.length > 0) {
                            // Place the search link above the tags
                            desc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">üîç ÁÇπÂáªÊêúÁ¥¢ËØóËØçËµèÊûê</a></div><br><br>Ê†áÁ≠æ: ${ci.tags.join(', ')}`;
                        } else {
                            desc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">üîç ÁÇπÂáªÊêúÁ¥¢ËØóËØçËµèÊûê</a></div>`;
                        }

                        return {
                            title: ci.rhythmic || 'Êú™Áü•ËØçÁâå', // Use rhythmic as title
                            auth: ci.author || 'Êú™Áü•‰ΩúËÄÖ',
                            type: 'ÂÆãËØç', // Mark as Song ci
                            content: ci.paragraphs ? ci.paragraphs.join('<br>') : 'Êó†ÂÜÖÂÆπ',
                            desc: desc,
                            source: 'ci' // Mark as ci
                        };
                    });

                    // Cache the fetched data
                    const cacheData = {
                        data: processedCi,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));

                    // Store in memory for subsequent requests
                    allCi = processedCi;

                    console.log(`Fetched and cached ${processedCi.length} Song ci`);
                    return allCi;
                } catch (error) {
                    console.error('Error fetching Song ci data:', error);

                    // If fetching failed, try to return cached data even if it's expired
                    if (cachedData) {
                        const { data } = JSON.parse(cachedData);
                        console.warn("Using expired cached Song ci data due to fetch error");
                        // Store expired data in memory temporarily
                        allCi = data;
                        return allCi;
                    }

                    // If no cached data is available, return an empty array
                    allCi = [];
                    return allCi;
                }
            }

            // Function to fetch and combine both poems and ci
            async function fetchAndCombineAll() {
                if (allCombined !== null) {
                    return allCombined;
                }

                // Fetch both poems and ci in parallel
                const [poems, ci] = await Promise.all([
                    fetchAndCachePoems(),
                    fetchAndCacheCi()
                ]);

                // Combine both arrays
                allCombined = [...poems, ...ci];
                console.log(`Combined ${poems.length} Tang poems and ${ci.length} Song ci, total ${allCombined.length} entries`);

                return allCombined;
            }

            // Function to get a random poem from cached data
            async function getRandomPoem() {
                const poems = await fetchAndCachePoems();
                if (poems.length === 0) {
                    console.warn("No poems available");
                    return null;
                }
                const randomIndex = Math.floor(Math.random() * poems.length);
                return poems[randomIndex];
            }

            // Function to get a random image URL from various sources with fallbacks
            function getRandomImageUrl(fallbackNum = 1) {
                const timestamp = Date.now();
                switch (fallbackNum) {
                    case 1:
                        // Primary source: picsum with random seed
                        return `https://picsum.photos/seed/${timestamp}/400/300`;
                    case 2:
                        // Fallback 1: picsum without seed (random image)
                        return `https://picsum.photos/400/300?random=${timestamp}`;
                    case 3:
                        // Fallback 2: Unsplash source with random seed
                        return `https://source.unsplash.com/400x300/?nature,random&ts=${timestamp}`;
                    case 4:
                        // Fallback 3: Pexel source with random seed
                        return `https://images.pexels.com/photos/3225517/pexels-photo-3225517.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=400&h=300&ts=${timestamp}`;
                    case 5:
                        // Local fallback: base64 encoded placeholder image
                        return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjY2NjIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkPDpXNpIFBvaWN0cnkgUGxhY2Vob2xkZXI8L3RleHQ+PC9zdmc+`;
                    default:
                        // Last resort: simple placeholder if all other sources fail
                        return `https://placehold.co/400x300/cccccc/666666?text=ËØóËØçÈÖçÂõæ`;
                }
            }

            // Function to get a random poem from filtered data
            async function getRandomPoem() {
                // Use filtered poems if available, otherwise use combined poems and ci
                if (filteredPoems && filteredPoems.length > 0) {
                    const randomIndex = Math.floor(Math.random() * filteredPoems.length);
                    return filteredPoems[randomIndex];
                } else {
                    // Use combined poems and ci
                    const allItems = await fetchAndCombineAll();
                    if (allItems.length === 0) {
                        console.warn("No poems or ci available");
                        return null;
                    }
                    const randomIndex = Math.floor(Math.random() * allItems.length);
                    return allItems[randomIndex];
                }
            }

            // Function to determine if poem is suitable for vertical layout
            function isVerticalLayoutPoem(poem) {
                const content = poem.content.replace(/\s+/g, ''); // Remove whitespace
                const sentences = content.split(/[„ÄÇÔºÅÔºü!?]/).filter(s => s.trim() !== '');

                // Check if it's a 5-character or 7-character regulated verse
                const firstLineLen = sentences[0] ? sentences[0].replace(/[Ôºå,]/g, '').length : 0;
                const isRegular = (firstLineLen === 5 || firstLineLen === 7) &&
                    sentences.every(s => {
                        const cleanLen = s.replace(/[Ôºå,]/g, '').length;
                        return cleanLen === firstLineLen * 2 || cleanLen === firstLineLen;
                    });

                // Suitable for vertical layout if it's a regular 5/7 character poem and not too long
                return isRegular && content.length <= 64;
            }

            // Function to determine if poem is a 7-character regulated verse (‰∏ÉË®ÄËØó)
            function isRegularPoem(poem) {
                const content = poem.content.replace(/\s+/g, ''); // Remove whitespace
                const sentences = content.split(/[„ÄÇÔºÅÔºü!?]/).filter(s => s.trim() !== '');

                // Ëé∑ÂèñÁ¨¨‰∏ÄÂè•ÈïøÂ∫¶ÔºàÈÄöÂ∏∏ÊòØ 5 Êàñ 7Ôºâ
                const firstLineLen = sentences[0] ? sentences[0].replace(/[Ôºå,]/g, '').length : 0;

                // ÂÖÅËÆ∏ 5Ë®Ä Êàñ 7Ë®ÄÔºå‰∏îÊØèÂè•ÈïøÂ∫¶Ë¶Å‰∏ÄËá¥
                const isRegular = (firstLineLen === 5 || firstLineLen === 7) &&
                    sentences.every(s => {
                        const cleanLen = s.replace(/[Ôºå,]/g, '').length;
                        // ‰∏ÄÂè•ÂèØËÉΩÊòØ5/7Â≠óÔºåÊàñËÄÖÊòØ‰∏ÄËÅî10/14Â≠ó
                        return cleanLen === firstLineLen * 2 || cleanLen === firstLineLen;
                    });

                return isRegular;
            }

            // „Äê‰øÆÊîπ 2„Äë ÈÄöÁî®ÁöÑÊàêÂØπÊ†ºÂºèÂåñÂáΩÊï∞ (Âéü formatSevenCharacterPoem)
            function formatCoupletPoem(poem) {
                // ÂÖ≥ÈîÆÁÇπÔºöfilter(line => line !== '') ‰ºöËá™Âä®ÊääÈÄ†ÊàêÂ§ßÈó¥Ë∑ùÁöÑÁ©∫Ë°åËøáÊª§ÊéâÔºÅ
                const lines = poem.content.split('\n').map(line => line.trim()).filter(line => line !== '');

                const formattedLines = [];
                for (let i = 0; i < lines.length; i += 2) {
                    if (i + 1 < lines.length) {
                        // ÊàêÂØπËæìÂá∫
                        formattedLines.push(`<div class="couplet-row">${lines[i]}<br>${lines[i + 1]}</div>`);
                    } else {
                        // ËêΩÂçïÁöÑÊúÄÂêé‰∏ÄÂè•
                        formattedLines.push(`<div class="couplet-row">${lines[i]}</div>`);
                    }
                }
                return formattedLines.join('');
            }

            // Function to insert line breaks at commas and periods for better layout
            function insertLineBreaksAtPunctuation(content) {
                // ÂÖàËßÑËåÉÂåñÊç¢Ë°åÁ¨¶ÔºåËøáÊª§Á©∫Ë°åÔºåÂÜçÂ§ÑÁêÜÊ†áÁÇπÁ¨¶Âè∑
                // È¶ñÂÖàÔºåÂ∞ÜÂÜÖÂÆπÊåâÊç¢Ë°åÁ¨¶ÂàÜÂâ≤Âπ∂ËøáÊª§Á©∫Ë°å
                const lines = content.split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '');

                // ÈáçÊñ∞ÁªÑÂêàÂÜÖÂÆπÔºå‰ΩÜÁ°Æ‰øùÊ†ºÂºèÊï¥Ê¥Å
                let processed = lines.join('\n');

                // ÁÑ∂ÂêéÊ∑ªÂä†Ê†áÁÇπÁ¨¶Âè∑ÂêéÁöÑÊç¢Ë°å
                processed = processed
                    .replace(/([Ôºå,])(?!\n)/g, '$1\n') // Âú®ÈÄóÂè∑ÂêéÊ∑ªÂä†Êç¢Ë°åÔºàÂ¶ÇÊûúÊ≤°ÊúâÂ∑≤ÁªèÂ≠òÂú®ÁöÑÊç¢Ë°åÔºâ
                    .replace(/([Ôºü?])(?!\n)/g, '$1\n'); // Âú®Âè•Âè∑ÂêéÊ∑ªÂä†Êç¢Ë°åÔºàÂ¶ÇÊûúÊ≤°ÊúâÂ∑≤ÁªèÂ≠òÂú®ÁöÑÊç¢Ë°åÔºâ

                // ÊúÄÂêéÔºåÂ∞ÜÊâÄÊúâÊç¢Ë°åÁ¨¶Áªü‰∏ÄËΩ¨Êç¢‰∏∫ <br> Ê†áÁ≠æ
                processed = processed.replace(/\n/g, '<br>');

                // Â§ÑÁêÜÂèØËÉΩÂá∫Áé∞ÁöÑÂ§ö‰∏™ËøûÁª≠ <br> Ê†áÁ≠æ
                processed = processed
                    .replace(/(<br>\s*){3,}/g, '<br><div class="poem-paragraph-break"></div><br>') // 3+ brs to br + paragraph break + br
                    .replace(/(<br>\s*){2}/g, '<br>'); // 2 brs to single br to avoid double spacing

                return processed;
            }

            // Function to load a random poem and image
            async function loadRandomPoem() {
                // Show loading
                document.getElementById('loading').style.display = 'block';
                document.getElementById('poemTextContent').style.display = 'none';
                document.getElementById('poemDescContent').style.display = 'none';

                // Get random poem
                const poem = await getRandomPoem();

                if (!poem) {
                    document.getElementById('loading').innerHTML = 'ËØóËØçÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÂÜçËØï';
                    return;
                }

                // 1. ËÆæÁΩÆÂü∫Êú¨‰ø°ÊÅØ
                document.getElementById('poemTitle').textContent = poem.title;
                document.getElementById('poemAuthor').textContent = poem.auth;

                // ‰ºòÂåñÔºöÂ∞ùËØï‰ªé type ‰∏≠ÊèêÂèñÊúù‰ª£ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÈªòËÆ§ÊòæÁ§∫ËØóËØçÁ±ªÂûã
                const dynastyElement = document.getElementById('poemDynasty');
                const typeSealElement = document.getElementById('mainTypeSeal');
                if (poem.source === 'ci') {
                    dynastyElement.textContent = 'ÂÆã';
                    dynastyElement.style.backgroundColor = '#88485E'; // ÂÆãËØçÁî®Á¥´Á∫¢Ëâ≤
                    typeSealElement.textContent = 'ËØç'; // ËØçÁ±ªÂûã
                } else {
                    dynastyElement.textContent = 'Âîê'; // ‰Ω†ÁöÑÊï∞ÊçÆÊ∫ê‰∏ªË¶ÅÊòØÂîêËØó
                    dynastyElement.style.backgroundColor = '#FE2C55'; // ÂîêËØóÁî®Â∞èÁ∫¢‰π¶Á∫¢
                    typeSealElement.textContent = 'ËØó'; // ËØóÁ±ªÂûã
                }

                // 2. Êô∫ËÉΩÊéíÁâàÈÄªËæë (Â§çÁî® analyzePoemLayout)
                // Ê≥®ÊÑèÔºöËøôÈáåÊàë‰ª¨Á®çÂæÆÊîπ‰∏Ä‰∏ãÔºåÂ¶ÇÊûúÊòØ analyzePoemLayout ËøîÂõû verticalÔºåÊàë‰ª¨Â∞±Áî®Á´ñÊéí
                // ‰ΩÜÂØπ‰∫é‰∏ªÂ±ïÁ§∫Âå∫ÔºåÊàë‰ª¨ÂèØ‰ª•Á®çÂæÆÊîæÂÆΩÁ´ñÊéíÁöÑÊù°‰ª∂ÔºàÊØîÂ¶ÇÂè™Ë¶ÅÊòØÂæãËØóÁªùÂè•ÈÉΩÁ´ñÊéíÔºå‰∏çÂèó32Â≠óÈôêÂà∂ÔºåÂõ†‰∏∫Á©∫Èó¥Â§ßÔºâ

                const content = poem.content;
                const verseElement = document.getElementById('poemVerse');

                // Ê∏ÖÈô§‰πãÂâçÁöÑÁ±ª
                verseElement.className = 'poem-verse';

                // ÁÆÄÂçïÂà§Êñ≠Ôºö‰∏çÂåÖÂê´ÈÄóÂè∑‰∏îÂè•Â≠êÈïøÂ∫¶Êï¥ÈΩêÁöÑÔºåÊàñËÄÖ‰Ω†ÊòØÁî® analyzePoemLayout
                const layoutInfo = analyzePoemLayout(poem);

                if (layoutInfo.mode === 'vertical') {
                    verseElement.classList.add('vertical-mode');
                    // Á´ñÊéíÊó∂ÔºåÊç¢Ë°åÁ¨¶‰øùÁïôÔºå‰∏îÊ†áÁÇπÁ¨¶Âè∑ÂèØËÉΩ‰ºöÂΩ±ÂìçÁæéËßÇÔºåÂèØ‰ª•ËÄÉËôëÁî®Á©∫Ê†ºÊõøÊç¢Ê†áÁÇπÔºåÊàñËÄÖ‰øùÁïô
                    // ËøôÈáåÁõ¥Êé•‰øùÁïôÂéüÊñáÊéíÁâà but add line breaks at punctuation
                    verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                } else {
                    verseElement.classList.add('horizontal-mode');
                    // Ê®™ÊéíÂ±Ö‰∏≠ÔºåÈÄÇÂêàÈïøÁü≠Âè•
                    // „Äê‰øÆÊîπ 3„Äë Âè™Ë¶ÅÊòØÊ†ºÂæãËØóÔºà‰∫îË®ÄÊàñ‰∏ÉË®ÄÔºâÔºå‰∏îË°åÊï∞Ë∂≥Â§üÔºåÂ∞±‰ΩøÁî®ÊàêÂØπÂ∏ÉÂ±Ä
                    // ËøôÊ†∑Â∞±ËÉΩÂà©Áî® .couplet-row ÁöÑ CSS Êù•ÊéßÂà∂Èó¥Ë∑ùÔºåÊ∂àÁÅ≠Â§ßÁ©∫Ë°å
                    if (isRegularPoem(poem) && poem.content.split('\n').length >= 2) {
                        verseElement.innerHTML = formatCoupletPoem(poem);
                    } else {
                        // ÂÖ∂‰ªñÈïøÁü≠Âè•ÔºàËØçÔºâÁªßÁª≠‰ΩøÁî®ÈªòËÆ§ÊéíÁâà
                        verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                    }
                }

                // 3. ËµèÊûêÂÜÖÂÆπÂ§ÑÁêÜ (‰ºòÂÖàÊòæÁ§∫ÁºìÂ≠òÁöÑ AI ËµèÊûê)
                const cachedInterpretation = getInterpretationFromCache(poem.title, poem.auth);
                const descElement = document.getElementById('poemDesc');

                if (cachedInterpretation) {
                    // Â¶ÇÊûúÊúâÁºìÂ≠òÔºåÊòæÁ§∫ AI ËµèÊûê
                    const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">‚ú® AI Ê∑±Â∫¶ËµèÊûê <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="ÈáçÊñ∞ÁîüÊàêËß£ËØª">üîÑ ÈáçÊñ∞ÁîüÊàê</span></div>';
                    descElement.innerHTML = poem.desc + separator + aiBadge + markdownToHtml(cachedInterpretation);
                } else {
                    // Âê¶ÂàôÊòæÁ§∫ÈªòËÆ§Ê≥®Èáä
                    descElement.innerHTML = poem.desc;
                }

                // Update image with multiple fallbacks and timeout
                const img = document.getElementById('poemImage');
                let currentFallback = 1;
                const maxFallbacks = 6; // Primary + 4 fallbacks + 1 local fallback
                let timeoutId;

                // Function to try loading next fallback image
                function tryNextFallback() {
                    if (currentFallback < maxFallbacks) {
                        currentFallback++;
                        // Clear previous timeout
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        // Set a new timeout for this fallback
                        timeoutId = setTimeout(() => {
                            console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                            if (currentFallback < maxFallbacks) {
                                tryNextFallback();
                            } else {
                                // All fallbacks exhausted, show content without image and indicate failure
                                handleImageFailure();
                            }
                        }, 15000); // 5 seconds timeout for each fallback

                        img.src = getRandomImageUrl(currentFallback);
                    } else {
                        // All fallbacks exhausted, show content without image and indicate failure
                        handleImageFailure();
                    }
                }

                // Function to handle the case when all image sources fail
                function handleImageFailure() {
                    console.warn("All image loading attempts failed, displaying content without image");

                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';

                    // Show poem content
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';

                    // Apply fade-in animation and add seal
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');


                    // Optionally, add a visual indicator that image loading failed
                    const img = document.getElementById('poemImage');
                    img.onerror = null; // Remove error handler to prevent loops
                    img.onload = null;  // Remove load handler
                }

                // Set up image event handlers
                img.onload = function () {
                    // Add loaded image to cache
                    addToImageCache(img.src);
                    // Clear timeout on successful load
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    // Show content once image is loaded
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');

                };

                img.onerror = function () {
                    console.log(`Image loading error for fallback ${currentFallback}, trying next...`);
                    // If we have cached images, try using one as a fallback
                    const cachedImage = getRandomCachedImage();
                    if (cachedImage && currentFallback >= maxFallbacks - 1) { // Only try cached on last attempt
                        console.log(`Using cached image as final fallback: ${cachedImage}`);
                        img.src = cachedImage;
                        return; // Don't try next fallback, try the cached image instead
                    }
                    // Try next fallback image
                    tryNextFallback();
                };

                // Set the new image source with primary URL
                img.src = getRandomImageUrl(currentFallback);

                // Set timeout for primary image
                timeoutId = setTimeout(() => {
                    console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                    if (currentFallback < maxFallbacks) {
                        tryNextFallback();
                    } else {
                        // Try cached image if available before showing content without image
                        const cachedImage = getRandomCachedImage();
                        if (cachedImage) {
                            console.log(`Using cached image as final fallback due to timeout: ${cachedImage}`);
                            img.src = cachedImage;
                        } else {
                            // All fallbacks exhausted, show content without image and indicate failure
                            handleImageFailure();
                        }
                    }
                }, 5000); // 5 seconds timeout for primary image

                // Show content immediately if this is the first load (image might take time)
                setTimeout(() => {
                    if (document.getElementById('loading').style.display === 'block') {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('poemTextContent').style.display = 'block';
                        document.getElementById('poemDescContent').style.display = 'block';
                        document.getElementById('poemTextContent').classList.add('fade-in');
                        document.getElementById('poemDescContent').classList.add('fade-in');

                    }
                }, 300); // Show content after 300ms if image hasn't loaded yet
            }

            // Function to populate author filter dropdown
            async function populateAuthorFilter() {
                const authorsWithCount = await getAllAuthors();
                const authorFilter = document.getElementById('authorFilter');

                // Clear existing options except the first one
                authorFilter.innerHTML = '<option value="">ÂÖ®ÈÉ®‰ΩúËÄÖ</option>';

                // Add authors with poem counts to the dropdown
                authorsWithCount.forEach(authorObj => {
                    const option = document.createElement('option');
                    option.value = authorObj.name;
                    option.textContent = `${authorObj.name} (${authorObj.count})`;
                    authorFilter.appendChild(option);
                });
            }

            // Function to get all authors sorted by poem count
            async function getAllAuthors() {
                // Use combined poems and ci for author list
                const allItems = await fetchAndCombineAll();

                // Count items per author
                const authorCount = {};
                allItems.forEach(item => {
                    if (authorCount[item.auth]) {
                        authorCount[item.auth]++;
                    } else {
                        authorCount[item.auth] = 1;
                    }
                });

                // Create array of {name, count} objects and sort by count (descending)
                const authorsWithCount = Object.entries(authorCount).map(([name, count]) => ({
                    name: name,
                    count: count
                }));

                // Sort by poem count (descending), then by name (ascending) for ties
                authorsWithCount.sort((a, b) => {
                    if (b.count !== a.count) {
                        return b.count - a.count; // Sort by count descending
                    }
                    return a.name.localeCompare(b.name); // Sort by name ascending for ties
                });

                return authorsWithCount;
            }

            // Function to filter poems by author
            async function filterByAuthor() {
                const selectedAuthor = document.getElementById('authorFilter').value;
                const allItems = await fetchAndCombineAll();

                if (selectedAuthor === '') {
                    filteredPoems = allItems;
                } else {
                    // Extract just the author name (before the parentheses)
                    const authorName = selectedAuthor.split(' (')[0];
                    filteredPoems = allItems.filter(item => item.auth === authorName);
                }

                // Update poem list dropdown
                updatePoemListDropdown();
            }

            // Function to update poem list dropdown based on filtered poems
            function updatePoemListDropdown() {
                const poemList = document.getElementById('poemList');

                // Clear existing options except the first one
                poemList.innerHTML = '<option value="">ÈÄâÊã©‰ΩúÂìÅ</option>';

                if (filteredPoems && filteredPoems.length > 0) {
                    filteredPoems.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item.title;
                        option.textContent = item.title;
                        poemList.appendChild(option);
                    });
                }
            }

            // Function to select a specific poem
            async function selectPoem() {
                const selectedTitle = document.getElementById('poemList').value;

                if (selectedTitle) {
                    // Find the selected poem in the filtered poems
                    const poem = filteredPoems.find(p => p.title === selectedTitle);
                    if (poem) {
                        displayPoem(poem);
                    }
                }
            }

            // Function to display a specific poem
            function displayPoem(poem) {
                // Show loading
                document.getElementById('loading').style.display = 'block';
                document.getElementById('poemTextContent').style.display = 'none';
                document.getElementById('poemDescContent').style.display = 'none';

                // 1. ËÆæÁΩÆÂü∫Êú¨‰ø°ÊÅØ
                document.getElementById('poemTitle').textContent = poem.title;
                document.getElementById('poemAuthor').textContent = poem.auth;

                // ‰ºòÂåñÔºöÂ∞ùËØï‰ªé type ‰∏≠ÊèêÂèñÊúù‰ª£ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÈªòËÆ§ÊòæÁ§∫ËØóËØçÁ±ªÂûã
                const dynastyElement = document.getElementById('poemDynasty');
                const typeSealElement = document.getElementById('mainTypeSeal');
                if (poem.source === 'ci') {
                    dynastyElement.textContent = 'ÂÆã';
                    dynastyElement.style.backgroundColor = '#88485E'; // ÂÆãËØçÁî®Á¥´Á∫¢Ëâ≤
                    typeSealElement.textContent = 'ËØç'; // ËØçÁ±ªÂûã
                } else {
                    dynastyElement.textContent = 'Âîê'; // ‰Ω†ÁöÑÊï∞ÊçÆÊ∫ê‰∏ªË¶ÅÊòØÂîêËØó
                    dynastyElement.style.backgroundColor = '#FE2C55'; // ÂîêËØóÁî®Â∞èÁ∫¢‰π¶Á∫¢
                    typeSealElement.textContent = 'ËØó'; // ËØóÁ±ªÂûã
                }

                // 2. Êô∫ËÉΩÊéíÁâàÈÄªËæë (Â§çÁî® analyzePoemLayout)
                // Ê≥®ÊÑèÔºöËøôÈáåÊàë‰ª¨Á®çÂæÆÊîπ‰∏Ä‰∏ãÔºåÂ¶ÇÊûúÊòØ analyzePoemLayout ËøîÂõû verticalÔºåÊàë‰ª¨Â∞±Áî®Á´ñÊéí
                // ‰ΩÜÂØπ‰∫é‰∏ªÂ±ïÁ§∫Âå∫ÔºåÊàë‰ª¨ÂèØ‰ª•Á®çÂæÆÊîæÂÆΩÁ´ñÊéíÁöÑÊù°‰ª∂ÔºàÊØîÂ¶ÇÂè™Ë¶ÅÊòØÂæãËØóÁªùÂè•ÈÉΩÁ´ñÊéíÔºå‰∏çÂèó32Â≠óÈôêÂà∂ÔºåÂõ†‰∏∫Á©∫Èó¥Â§ßÔºâ

                const content = poem.content;
                const verseElement = document.getElementById('poemVerse');

                // Ê∏ÖÈô§‰πãÂâçÁöÑÁ±ª
                verseElement.className = 'poem-verse';

                // ÁÆÄÂçïÂà§Êñ≠Ôºö‰∏çÂåÖÂê´ÈÄóÂè∑‰∏îÂè•Â≠êÈïøÂ∫¶Êï¥ÈΩêÁöÑÔºåÊàñËÄÖ‰Ω†ÊòØÁî® analyzePoemLayout
                const layoutInfo = analyzePoemLayout(poem);

                if (layoutInfo.mode === 'vertical') {
                    verseElement.classList.add('vertical-mode');
                    // Á´ñÊéíÊó∂ÔºåÊç¢Ë°åÁ¨¶‰øùÁïôÔºå‰∏îÊ†áÁÇπÁ¨¶Âè∑ÂèØËÉΩ‰ºöÂΩ±ÂìçÁæéËßÇÔºåÂèØ‰ª•ËÄÉËôëÁî®Á©∫Ê†ºÊõøÊç¢Ê†áÁÇπÔºåÊàñËÄÖ‰øùÁïô
                    // ËøôÈáåÁõ¥Êé•‰øùÁïôÂéüÊñáÊéíÁâà but add line breaks at punctuation
                    verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                } else {
                    verseElement.classList.add('horizontal-mode');
                    // Ê®™ÊéíÂ±Ö‰∏≠ÔºåÈÄÇÂêàÈïøÁü≠Âè•
                    // „Äê‰øÆÊîπ 3„Äë Âè™Ë¶ÅÊòØÊ†ºÂæãËØóÔºà‰∫îË®ÄÊàñ‰∏ÉË®ÄÔºâÔºå‰∏îË°åÊï∞Ë∂≥Â§üÔºåÂ∞±‰ΩøÁî®ÊàêÂØπÂ∏ÉÂ±Ä
                    // ËøôÊ†∑Â∞±ËÉΩÂà©Áî® .couplet-row ÁöÑ CSS Êù•ÊéßÂà∂Èó¥Ë∑ùÔºåÊ∂àÁÅ≠Â§ßÁ©∫Ë°å
                    if (isRegularPoem(poem) && poem.content.split('\n').length >= 2) {
                        verseElement.innerHTML = formatCoupletPoem(poem);
                    } else {
                        // ÂÖ∂‰ªñÈïøÁü≠Âè•ÔºàËØçÔºâÁªßÁª≠‰ΩøÁî®ÈªòËÆ§ÊéíÁâà
                        verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                    }
                }

                // Debug: Log the desc content to console
                console.log("Poem desc content:", poem.desc);
                console.log("Poem source:", poem.source);

                // 3. ËµèÊûêÂÜÖÂÆπÂ§ÑÁêÜ (‰ºòÂÖàÊòæÁ§∫ÁºìÂ≠òÁöÑ AI ËµèÊûê)
                const cachedInterpretation = getInterpretationFromCache(poem.title, poem.auth);
                const descElement = document.getElementById('poemDesc');

                if (cachedInterpretation) {
                    // Â¶ÇÊûúÊúâÁºìÂ≠òÔºåÊòæÁ§∫ AI ËµèÊûê
                    const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">‚ú® AI Ê∑±Â∫¶ËµèÊûê <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="ÈáçÊñ∞ÁîüÊàêËß£ËØª">üîÑ ÈáçÊñ∞ÁîüÊàê</span></div>';
                    descElement.innerHTML = poem.desc + separator + aiBadge + markdownToHtml(cachedInterpretation);
                } else {
                    // Âê¶ÂàôÊòæÁ§∫ÈªòËÆ§Ê≥®Èáä
                    descElement.innerHTML = poem.desc;
                }

                // Update image with multiple fallbacks and timeout
                const img = document.getElementById('poemImage');
                let currentFallback = 1;
                const maxFallbacks = 6; // Primary + 4 fallbacks + 1 local fallback
                let timeoutId;

                // Function to try loading next fallback image
                function tryNextFallback() {
                    if (currentFallback < maxFallbacks) {
                        currentFallback++;
                        // Clear previous timeout
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        // Set a new timeout for this fallback
                        timeoutId = setTimeout(() => {
                            console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                            if (currentFallback < maxFallbacks) {
                                tryNextFallback();
                            } else {
                                // All fallbacks exhausted, show content without image and indicate failure
                                handleImageFailure();
                            }
                        }, 5000); // 5 seconds timeout for each fallback

                        img.src = getRandomImageUrl(currentFallback);
                    } else {
                        // All fallbacks exhausted, show content without image and indicate failure
                        handleImageFailure();
                    }
                }

                // Function to handle the case when all image sources fail
                function handleImageFailure() {
                    console.warn("All image loading attempts failed, displaying content without image");

                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';

                    // Show poem content
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';

                    // Apply fade-in animation and add seal
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');


                    // Optionally, add a visual indicator that image loading failed
                    const img = document.getElementById('poemImage');
                    img.onerror = null; // Remove error handler to prevent loops
                    img.onload = null;  // Remove load handler
                }

                // Set up image event handlers
                img.onload = function () {
                    // Add loaded image to cache
                    addToImageCache(img.src);
                    // Clear timeout on successful load
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    // Show content once image is loaded
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');

                };

                img.onerror = function () {
                    console.log(`Image loading error for fallback ${currentFallback}, trying next...`);
                    // If we have cached images, try using one as a fallback
                    const cachedImage = getRandomCachedImage();
                    if (cachedImage && currentFallback >= maxFallbacks - 1) { // Only try cached on last attempt
                        console.log(`Using cached image as final fallback: ${cachedImage}`);
                        img.src = cachedImage;
                        return; // Don't try next fallback, try the cached image instead
                    }
                    // Try next fallback image
                    tryNextFallback();
                };

                // Set the new image source with primary URL
                img.src = getRandomImageUrl(currentFallback);

                // Set timeout for primary image
                timeoutId = setTimeout(() => {
                    console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                    if (currentFallback < maxFallbacks) {
                        tryNextFallback();
                    } else {
                        // Try cached image if available before showing content without image
                        const cachedImage = getRandomCachedImage();
                        if (cachedImage) {
                            console.log(`Using cached image as final fallback due to timeout: ${cachedImage}`);
                            img.src = cachedImage;
                        } else {
                            // All fallbacks exhausted, show content without image and indicate failure
                            handleImageFailure();
                        }
                    }
                }, 5000); // 5 seconds timeout for primary image

                // Show content immediately if this is the first load (image might take time)
                setTimeout(() => {
                    if (document.getElementById('loading').style.display === 'block') {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('poemTextContent').style.display = 'block';
                        document.getElementById('poemDescContent').style.display = 'block';
                        document.getElementById('poemTextContent').classList.add('fade-in');
                        document.getElementById('poemDescContent').classList.add('fade-in');

                    }
                }, 300); // Show content after 300ms if image hasn't loaded yet
            }

            // Function to clear filters
            function clearFilter() {
                document.getElementById('authorFilter').value = '';
                document.getElementById('poemList').value = '';
                filteredPoems = allCombined; // Reset to all combined data (poems and ci)
                updatePoemListDropdown();
            }

            // Function to perform search
            async function performSearch() {
                const searchTerm = document.getElementById('searchInput').value.trim();
                if (!searchTerm) {
                    alert('ËØ∑ËæìÂÖ•ÊêúÁ¥¢ÂÖ≥ÈîÆËØç');
                    return;
                }

                const allItems = await fetchAndCombineAll();
                const searchResults = [];

                // Search in title and content
                allItems.forEach(item => {
                    const title = item.title.toLowerCase();
                    const content = item.content.toLowerCase();
                    const auth = item.auth.toLowerCase();
                    const desc = item.desc.toLowerCase();

                    if (title.includes(searchTerm.toLowerCase()) ||
                        content.includes(searchTerm.toLowerCase()) ||
                        auth.includes(searchTerm.toLowerCase()) ||
                        desc.includes(searchTerm.toLowerCase())) {
                        // Create a preview of where the match occurred
                        let preview = '';
                        if (content.includes(searchTerm.toLowerCase())) {
                            const matchIndex = content.indexOf(searchTerm.toLowerCase());
                            const start = Math.max(0, matchIndex - 20);
                            const end = Math.min(content.length, matchIndex + searchTerm.length + 20);
                            preview = '...' + content.substring(start, end) + '...';
                        } else {
                            preview = content.substring(0, 60) + '...';
                        }

                        searchResults.push({
                            ...item,
                            preview: preview
                        });
                    }
                });

                displaySearchResults(searchResults, searchTerm);
            }

            // Function to handle Enter key in search input
            function handleSearchKeyPress(event) {
                if (event.key === 'Enter') {
                    performSearch();
                }
            }

            // Function to display search results
            function displaySearchResults(results, searchTerm) {
                const resultsContainer = document.getElementById('searchResults');
                const resultsList = document.getElementById('searchResultsList');

                if (results.length === 0) {
                    resultsList.innerHTML = '<li>Êú™ÊâæÂà∞ÂåπÈÖçÁöÑËØóÊ≠å</li>';
                } else {
                    resultsList.innerHTML = '';

                    results.forEach((poem, index) => {
                        const li = document.createElement('li');
                        li.innerHTML = `
            <div class="result-title">${highlightText(poem.title, searchTerm)}</div>
            <div class="result-author">‰ΩúËÄÖ: ${highlightText(poem.auth, searchTerm)}</div>
            <div class="result-preview">${highlightText(poem.preview, searchTerm)}</div>
          `;
                        li.onclick = () => selectSearchResult(poem);
                        resultsList.appendChild(li);
                    });
                }

                resultsContainer.style.display = 'block';
            }

            // Function to highlight search term in text
            function highlightText(text, searchTerm) {
                if (!searchTerm) return text;

                const regex = new RegExp(`(${searchTerm})`, 'gi');
                return text.replace(regex, '<mark>$1</mark>');
            }

            // Function to select a search result
            function selectSearchResult(poem) {
                displayPoem(poem);

                // Close search results and search section
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('searchSection').style.display = 'none';
                document.getElementById('searchInput').value = '';
            }

            // Function to clear search
            function clearSearch() {
                document.getElementById('searchInput').value = '';
                document.getElementById('searchResults').style.display = 'none';
            }

            // Function to toggle search section
            function toggleSearch() {
                const searchSection = document.getElementById('searchSection');
                const isCurrentlyVisible = searchSection.style.display !== 'none';

                if (isCurrentlyVisible) {
                    hideSearch();
                } else {
                    searchSection.style.display = 'flex';
                    // Focus on the search input when showing
                    document.getElementById('searchInput').focus();
                }
            }

            // Function to hide search section
            function hideSearch() {
                document.getElementById('searchSection').style.display = 'none';
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('searchInput').value = '';
            }

            // Load a random poem when the page loads
            window.onload = async function () {
                // Preload both poems and ci data
                await fetchAndCombineAll();
                // Initialize filteredPoems to all combined data
                filteredPoems = allCombined;
                await loadRandomPoem();
                await populateAuthorFilter(); // Populate the author filter after poems are loaded

                console.log("Page loaded. Combined data count:", allCombined ? allCombined.length : 0);
                console.log("Tang poem count:", allPoems ? allPoems.length : 0);
                console.log("Song ci count:", allCi ? allCi.length : 0);
            };

            // Add keyboard support (press spacebar for next poem)
            document.addEventListener('keydown', function (event) {
                if (event.code === 'Space') {
                    event.preventDefault();
                    loadRandomPoem();
                }
            });

            // Function to open Baidu search for current poem
            function openCurrentPoemSearch() {
                const titleElement = document.getElementById('poemTitle');
                const authorElement = document.getElementById('poemAuthor');

                let title = '';
                let author = '';

                if (titleElement) {
                    title = titleElement.textContent || titleElement.innerText;
                }

                if (authorElement) {
                    author = authorElement.textContent || authorElement.innerText;
                }

                // Create search query
                const searchQuery = encodeURIComponent(`${author} ${title}`);
                const searchUrl = `https://chat.baidu.com/search?word=${searchQuery}&setype=csaitab`;

                // Open search in a new tab/window
                window.open(searchUrl, '_blank');
            }

            document.addEventListener('DOMContentLoaded', function () {
                // Add event listener for inline search button
                const inlineSearchBtn = document.getElementById('inlineSearchBtn');
                if (inlineSearchBtn) {
                    inlineSearchBtn.addEventListener('click', openCurrentPoemSearch);
                }

                const darkModeToggle = document.getElementById('darkModeToggle');
                const body = document.body;

                // Check for saved theme preference or respect system preference
                const currentTheme = localStorage.getItem('theme');
                if (currentTheme === 'dark') {
                    body.classList.add('dark-mode');
                    darkModeToggle.textContent = '‚òÄÔ∏è'; // Sun icon when in dark mode
                } else if (currentTheme === 'light') {
                    body.classList.remove('dark-mode');
                    darkModeToggle.textContent = 'üåô'; // Moon icon when in light mode
                } else {
                    // Check system preference
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        body.classList.add('dark-mode');
                        darkModeToggle.textContent = '‚òÄÔ∏è';
                    } else {
                        body.classList.remove('dark-mode');
                        darkModeToggle.textContent = 'üåô';
                    }
                }

                darkModeToggle.addEventListener('click', function () {
                    body.classList.toggle('dark-mode');

                    if (body.classList.contains('dark-mode')) {
                        darkModeToggle.textContent = '‚òÄÔ∏è';
                        localStorage.setItem('theme', 'dark');
                    } else {
                        darkModeToggle.textContent = 'üåô';
                        localStorage.setItem('theme', 'light');
                    }
                });
            });

            // Toggle layout between symmetric and waterfall
            function toggleLayout() {
                const symmetricContainer = document.querySelector('.poem-content');
                const waterfallContainer = document.getElementById('waterfallContainer');
                const layoutToggle = document.getElementById('layoutToggle');

                if (symmetricContainer.style.display === 'none') {
                    // Switch to symmetric layout
                    symmetricContainer.style.display = 'flex';
                    waterfallContainer.classList.remove('active');
                    layoutToggle.textContent = 'ÁÄëÂ∏ÉÊµÅ';
                    generateWaterfallContent(); // Generate waterfall content if needed
                } else {
                    // Switch to waterfall layout
                    symmetricContainer.style.display = 'none';
                    waterfallContainer.classList.add('active');
                    layoutToggle.textContent = 'ÈªòËÆ§Â∏ÉÂ±Ä';
                    generateWaterfallContent(); // Generate waterfall content
                }
            }


            // Generate waterfall content from poem data
            function generateWaterfallContent() {
                const waterfallContent = document.getElementById('waterfallContent');
                // Only generate if content is not already there or if we want to refresh
                if (allCombined && allCombined.length > 0) {
                    waterfallContent.innerHTML = ''; // Clear existing content

                    // Select 12 random poems from allCombined (increased from 10)
                    const randomPoems = getRandomPoems(allCombined, 12);

                    randomPoems.forEach((poem, index) => {
                        const card = document.createElement('div');
                        card.className = 'waterfall-card';
                        card.onclick = function () {
                            showPoemDetail(poem);
                        };

                        // Analyze layout for the poem
                        const layoutInfo = analyzePoemLayout(poem);

                        // Generate lines HTML
                        let linesHtml = '';
                        layoutInfo.lines.forEach(line => {
                            if (line) linesHtml += `<div class="poem-line">${line}</div>`;
                        });

                        // Generate a random color for the background
                        const backgroundColor = getRandomColor();

                        // Limit title and author length to prevent overflow
                        let title = layoutInfo.title;
                        if (title.length > 12) {
                            title = title.substring(0, 12) + '...';
                        }

                        let author = layoutInfo.author;
                        if (author.length > 8) {
                            author = author.substring(0, 8) + '...';
                        }

                        // Determine the appropriate seal based on poem type
                        const sealText = poem.source === 'ci' ? 'ËØç' : 'ËØó';

                        card.innerHTML = `
            <div class="color-block-container">
              <div class="color-block" style="background-color: ${backgroundColor};">
                 <!-- This class changes based on mode dynamically -->
                 <div class="overlay-text layout-${layoutInfo.mode}">
                   ${linesHtml}
                 </div>

                 <!-- Add seal decoration for aesthetic enhancement (with type-specific character) -->
                 <div class="seal-decoration">${sealText}</div>
              </div>
            </div>
            <div class="waterfall-content-section">
              <h3 class="waterfall-title">${title}</h3>
              <p class="waterfall-author">${author}</p>
            </div>
          `;
                        waterfallContent.appendChild(card);
                    });
                }
            }

            // Function to get a specified number of random poems from an array
            function getRandomPoems(poemsArray, count) {
                // Create a copy of the array to avoid modifying the original
                const arrayCopy = [...poemsArray];
                const shuffled = arrayCopy.sort(() => 0.5 - Math.random());
                // Return the first 'count' elements or all elements if array is smaller
                return shuffled.slice(0, Math.min(count, shuffled.length));
            }

            // Break text into lines with maximum specified length
            function breakTextIntoLines(text, maxLength) {
                if (!text) return '';

                // First, split by periods to ensure sentences end at periods
                const sentences = text.split('„ÄÇ');
                const result = [];

                for (let i = 0; i < sentences.length; i++) {
                    // Only add the period back if it wasn't the last element from a text that ended with a period
                    let sentence = sentences[i];

                    // Check if this is not the last segment or if the original text didn't end with a period
                    const isLastSegment = (i === sentences.length - 1);
                    const originalTextEndedWithPeriod = (i === sentences.length - 1 && sentence === '');

                    if (!originalTextEndedWithPeriod) {
                        sentence += '„ÄÇ';
                    } else {
                        // If it's an empty string because text ended with a period, skip it
                        continue;
                    }

                    // Special handling for Chinese poetry (especially 7-character verses) and long sentences
                    if (sentence.length > maxLength) {
                        // For Chinese poetry, try to break at natural boundaries
                        // If we have a ‰∏ÉË®ÄËØó (7-character verse), keep it as one line if possible
                        if (sentence.includes('„ÄÇ') && sentence.length <= maxLength + 2) {
                            // If the sentence with period is only slightly over the limit, include it
                            result.push(sentence);
                        } else {
                            // For very long sentences, break them into smaller chunks
                            let start = 0;
                            while (start < sentence.length) {
                                const chunk = sentence.substring(start, Math.min(start + maxLength, sentence.length));
                                result.push(chunk);
                                start += maxLength;
                            }
                        }
                    } else {
                        // Check if we can add this sentence to the current line without exceeding maxLength
                        if (result.length === 0) {
                            // First sentence goes directly to result
                            result.push(sentence);
                        } else {
                            const currentLine = result[result.length - 1];
                            if ((currentLine + sentence).length <= maxLength) {
                                // Add to current line if it doesn't exceed maxLength
                                result[result.length - 1] += sentence;
                            } else {
                                // Start a new line
                                result.push(sentence);
                            }
                        }
                    }
                }

                return result.join('<br>');
            }

            // Show detailed poem view when clicking a card
            function showPoemDetail(poem) {
                // 1. ËÆæÁΩÆÂü∫Êú¨‰ø°ÊÅØ
                document.getElementById('poemTitle').textContent = poem.title;
                document.getElementById('poemAuthor').textContent = poem.auth;

                // ‰ºòÂåñÔºöÂ∞ùËØï‰ªé type ‰∏≠ÊèêÂèñÊúù‰ª£ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÈªòËÆ§ÊòæÁ§∫ËØóËØçÁ±ªÂûã
                const dynastyElement = document.getElementById('poemDynasty');
                const typeSealElement = document.getElementById('mainTypeSeal');
                if (poem.source === 'ci') {
                    dynastyElement.textContent = 'ÂÆã';
                    dynastyElement.style.backgroundColor = '#88485E'; // ÂÆãËØçÁî®Á¥´Á∫¢Ëâ≤
                    typeSealElement.textContent = 'ËØç'; // ËØçÁ±ªÂûã
                } else {
                    dynastyElement.textContent = 'Âîê'; // ‰Ω†ÁöÑÊï∞ÊçÆÊ∫ê‰∏ªË¶ÅÊòØÂîêËØó
                    dynastyElement.style.backgroundColor = '#FE2C55'; // ÂîêËØóÁî®Â∞èÁ∫¢‰π¶Á∫¢
                    typeSealElement.textContent = 'ËØó'; // ËØóÁ±ªÂûã
                }

                // 2. Êô∫ËÉΩÊéíÁâàÈÄªËæë (Â§çÁî® analyzePoemLayout)
                // Ê≥®ÊÑèÔºöËøôÈáåÊàë‰ª¨Á®çÂæÆÊîπ‰∏Ä‰∏ãÔºåÂ¶ÇÊûúÊòØ analyzePoemLayout ËøîÂõû verticalÔºåÊàë‰ª¨Â∞±Áî®Á´ñÊéí
                // ‰ΩÜÂØπ‰∫é‰∏ªÂ±ïÁ§∫Âå∫ÔºåÊàë‰ª¨ÂèØ‰ª•Á®çÂæÆÊîæÂÆΩÁ´ñÊéíÁöÑÊù°‰ª∂ÔºàÊØîÂ¶ÇÂè™Ë¶ÅÊòØÂæãËØóÁªùÂè•ÈÉΩÁ´ñÊéíÔºå‰∏çÂèó32Â≠óÈôêÂà∂ÔºåÂõ†‰∏∫Á©∫Èó¥Â§ßÔºâ

                const content = poem.content;
                const verseElement = document.getElementById('poemVerse');

                // Ê∏ÖÈô§‰πãÂâçÁöÑÁ±ª
                verseElement.className = 'poem-verse';

                // ÁÆÄÂçïÂà§Êñ≠Ôºö‰∏çÂåÖÂê´ÈÄóÂè∑‰∏îÂè•Â≠êÈïøÂ∫¶Êï¥ÈΩêÁöÑÔºåÊàñËÄÖ‰Ω†ÊòØÁî® analyzePoemLayout
                const layoutInfo = analyzePoemLayout(poem);

                if (layoutInfo.mode === 'vertical') {
                    verseElement.classList.add('vertical-mode');
                    // Á´ñÊéíÊó∂ÔºåÊç¢Ë°åÁ¨¶‰øùÁïôÔºå‰∏îÊ†áÁÇπÁ¨¶Âè∑ÂèØËÉΩ‰ºöÂΩ±ÂìçÁæéËßÇÔºåÂèØ‰ª•ËÄÉËôëÁî®Á©∫Ê†ºÊõøÊç¢Ê†áÁÇπÔºåÊàñËÄÖ‰øùÁïô
                    // ËøôÈáåÁõ¥Êé•‰øùÁïôÂéüÊñáÊéíÁâà but add line breaks at punctuation
                    verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                } else {
                    verseElement.classList.add('horizontal-mode');
                    // Ê®™ÊéíÂ±Ö‰∏≠ÔºåÈÄÇÂêàÈïøÁü≠Âè•
                    // „Äê‰øÆÊîπ 3„Äë Âè™Ë¶ÅÊòØÊ†ºÂæãËØóÔºà‰∫îË®ÄÊàñ‰∏ÉË®ÄÔºâÔºå‰∏îË°åÊï∞Ë∂≥Â§üÔºåÂ∞±‰ΩøÁî®ÊàêÂØπÂ∏ÉÂ±Ä
                    // ËøôÊ†∑Â∞±ËÉΩÂà©Áî® .couplet-row ÁöÑ CSS Êù•ÊéßÂà∂Èó¥Ë∑ùÔºåÊ∂àÁÅ≠Â§ßÁ©∫Ë°å
                    if (isRegularPoem(poem) && poem.content.split('\n').length >= 2) {
                        verseElement.innerHTML = formatCoupletPoem(poem);
                    } else {
                        // ÂÖ∂‰ªñÈïøÁü≠Âè•ÔºàËØçÔºâÁªßÁª≠‰ΩøÁî®ÈªòËÆ§ÊéíÁâà
                        verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                    }
                }

                // 3. ËµèÊûêÂÜÖÂÆπÂ§ÑÁêÜ (‰ºòÂÖàÊòæÁ§∫ÁºìÂ≠òÁöÑ AI ËµèÊûê)
                const cachedInterpretation = getInterpretationFromCache(poem.title, poem.auth);
                const descElement = document.getElementById('poemDesc');

                if (cachedInterpretation) {
                    // Â¶ÇÊûúÊúâÁºìÂ≠òÔºåÊòæÁ§∫ AI ËµèÊûê
                    const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">‚ú® AI Ê∑±Â∫¶ËµèÊûê <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="ÈáçÊñ∞ÁîüÊàêËß£ËØª">üîÑ ÈáçÊñ∞ÁîüÊàê</span></div>';
                    descElement.innerHTML = poem.desc + separator + aiBadge + markdownToHtml(cachedInterpretation);
                } else {
                    // Âê¶ÂàôÊòæÁ§∫ÈªòËÆ§Ê≥®Èáä
                    descElement.innerHTML = poem.desc;
                }

                // Update the image
                const img = document.getElementById('poemImage');
                // Try to add current src to cache if it's loaded successfully
                img.onload = function () {
                    addToImageCache(img.src);
                };
                img.src = getRandomImageUrl(0);
                img.onerror = function () {
                    this.onerror = null;
                    // Try cached image first, then fallback to random image
                    const cachedImage = getRandomCachedImage();
                    if (cachedImage) {
                        this.src = cachedImage;
                    } else {
                        this.src = 'https://picsum.photos/600/400?random=' + Math.floor(Math.random() * 1000);
                    }
                };

                // Show the content sections
                document.getElementById('loading').style.display = 'none';
                document.getElementById('poemTextContent').style.display = 'block';
                document.getElementById('poemDescContent').style.display = 'block';

                // Apply fade-in animation
                document.getElementById('poemTextContent').classList.remove('fade-in');
                document.getElementById('poemDescContent').classList.remove('fade-in');
                // Trigger reflow
                void document.getElementById('poemTextContent').offsetWidth;
                void document.getElementById('poemDescContent').offsetWidth;
                document.getElementById('poemTextContent').classList.add('fade-in');
                document.getElementById('poemDescContent').classList.add('fade-in');


                // Switch to symmetric layout to show details
                const symmetricContainer = document.querySelector('.poem-content');
                const waterfallContainer = document.getElementById('waterfallContainer');
                const layoutToggle = document.getElementById('layoutToggle');

                symmetricContainer.style.display = 'flex';
                waterfallContainer.classList.remove('active');
                layoutToggle.textContent = 'ÁÄëÂ∏ÉÊµÅ';
            }

            // Copy poem to clipboard function (‰ºòÂåñ‰∫å: Ê∑ªÂä†"Â§çÂà∂/ÂàÜ‰∫´"ÂäüËÉΩ)
            function copyPoemToClipboard() {
                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                // Ëé∑ÂèñÂéüÂßãÊñáÊú¨ÔºåÊää <br> Êç¢ÂõûÊç¢Ë°åÁ¨¶
                const verseHtml = document.getElementById('poemVerse').innerHTML;
                const verse = verseHtml.replace(/<br\s*\/?>/gi, '\n').replace(/&nbsp;/g, ' ');

                const textToCopy = `„Äê${title}„Äë\n${author}\n\n${verse}\n\n---- Êù•Ëá™ËãëÂπøÂ±±Âè§ÂÖ∏ËØóËØçÂ∞èÁ´ô`;

                navigator.clipboard.writeText(textToCopy).then(() => {
                    // ÁÆÄÂçïÁöÑÊèêÁ§∫ feedback
                    const btn = document.querySelector('button[title="Â§çÂà∂ËØóËØç"]');
                    if (btn) {
                        const originalText = 'üìã'; // Store original icon
                        btn.innerHTML = '‚úÖ';

                        // Clear any existing timeouts to prevent conflicts
                        if (btn.timeoutId) {
                            clearTimeout(btn.timeoutId);
                        }

                        // Set timeout to reset the button icon
                        btn.timeoutId = setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.timeoutId = null; // Clear the reference
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    // Optionally provide feedback to user
                    const btn = document.querySelector('button[title="Â§çÂà∂ËØóËØç"]');
                    if (btn) {
                        btn.innerHTML = '‚ùå';
                        if (btn.timeoutId) {
                            clearTimeout(btn.timeoutId);
                        }
                        btn.timeoutId = setTimeout(() => {
                            btn.innerHTML = 'üìã';
                            btn.timeoutId = null;
                        }, 2000);
                    }
                });
            }

            // New: intelligent poem layout analysis
            function analyzePoemLayout(poem) {
                const content = poem.content.replace(/\s+/g, ''); // Remove whitespace
                const sentences = content.split(/[„ÄÇÔºÅÔºü!?]/).filter(s => s.trim() !== '');

                // 1. Check if it's a 5-character or 7-character regulated verse (Êï¥ÈΩêÁöÑÊ†ºÂæã)
                // Simple check: see if the first line length is 5 or 7
                const firstLineLen = sentences[0] ? sentences[0].replace(/[Ôºå,]/g, '').length : 0;
                const isRegular = (firstLineLen === 5 || firstLineLen === 7) &&
                    sentences.every(s => {
                        const cleanLen = s.replace(/[Ôºå,]/g, '').length;
                        return cleanLen === firstLineLen * 2 || cleanLen === firstLineLen;
                    });

                let displayLines = [];
                let layoutMode = 'horizontal'; // Default horizontal layout

                if (isRegular && content.length <= 32) {
                    // 2. If it's a short 5/7-character poem (like a jueju), suitable for vertical display
                    layoutMode = 'vertical';
                    // Split the poem into lines by punctuation
                    displayLines = content.split(/[Ôºå„ÄÇÔºÅÔºü!?]/).filter(s => s.trim() !== '');
                } else {
                    // 3. If it's a long poem or ci (with uneven lines), just show a random couplet
                    // Prefer selecting middle sentences, avoid very short ones
                    const validCouplets = [];
                    // Try splitting by sentence punctuation, then by commas for couplets
                    for (let s of sentences) {
                        const parts = s.split(/[Ôºå,]/);
                        if (parts.length >= 2) {
                            // This is a complete sentence with commas, likely a couplet
                            if (parts[0].length + parts[1].length < 20) { // Limit length
                                validCouplets.push(parts[0] + 'Ôºå' + parts[1]);
                            }
                        }
                    }

                    if (validCouplets.length > 0) {
                        // Randomly take a couplet
                        const randomCouplet = validCouplets[Math.floor(Math.random() * validCouplets.length)];
                        // Replace commas with line breaks for display
                        displayLines = randomCouplet.split(/[Ôºå,]/);
                        layoutMode = 'horizontal-center'; // Quote mode suitable for center alignment
                    } else {
                        // Fallback: take first two sentences
                        if (sentences.length >= 2) {
                            displayLines = [sentences[0].split(/[Ôºå,]/)[0] || '', sentences[0].split(/[Ôºå,]/)[1] || ''];
                        } else if (sentences.length === 1) {
                            const parts = sentences[0].split(/[Ôºå,]/);
                            displayLines = [parts[0] || '', parts[1] || ''];
                        } else {
                            displayLines = ['ËØóËØçÂÜÖÂÆπ', 'ËØóËØçÂÜÖÂÆπ'];
                        }
                        layoutMode = 'horizontal-center';
                    }
                }

                return {
                    lines: displayLines,
                    mode: layoutMode,
                    title: poem.title,
                    author: poem.auth
                };
            }

            // Function to refresh content based on current layout
            function refreshContent() {
                const waterfallContainer = document.getElementById('waterfallContainer');

                if (waterfallContainer.classList.contains('active')) {
                    // If in waterfall layout, refresh the waterfall content with new random poems
                    generateWaterfallContent();
                } else {
                    // If in symmetric layout, load a new random poem
                    loadRandomPoem();
                }
            }

            // Function to get AI interpretation of the poem
            async function getPoemInterpretation() {
                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                const verse = document.getElementById('poemVerse').textContent;
                const desc = document.getElementById('poemDesc').textContent;

                // Show loading state
                const searchBtn = document.getElementById('ai-interpret-btn');
                const originalContent = searchBtn.innerHTML;
                searchBtn.innerHTML = 'üîÑ';
                searchBtn.disabled = true;

                try {
                    // Create a prompt for the AI
                    const prompt = `ËØ∑‰∏∫‰ª•‰∏ãÂè§ËØóËØçÊèê‰æõÊ∑±Â∫¶Ëß£ËØªÂíåËµèÊûêÔºå‰ΩøÁî®MarkdownÊ†ºÂºèËæìÂá∫ÔºåÂåÖÂê´‰ª•‰∏ãÈÉ®ÂàÜÔºö
1. ËØóËØçËÉåÊôØ‰∏é‰ΩúËÄÖÂøÉÂ¢É
2. ÈÄêÂè•Ëß£ÊûêÔºàÂ¶ÇÊûúËØóÂè•ËæÉÁü≠ÂèØÂêàÂπ∂Ëß£ÊûêÔºâ
3. Ëâ∫ÊúØÊâãÊ≥ï‰∏é‰øÆËæûÁâπÁÇπ
4. ‰∏ªÈ¢òÊÄùÊÉ≥‰∏éÊÉÖÊÑüÂÜÖÊ∂µ
5. ÊñáÂ≠¶‰ª∑ÂÄº‰∏éÂΩ±Âìç

ËØóËØçÈ¢òÁõÆÔºö${title}
‰ΩúËÄÖÔºö${author}
ËØóËØçÂÜÖÂÆπÔºö
${verse}

ÂéüÊ≥®ÈáäÔºö${desc}

ËØ∑‰ª•Ê†áÂáÜMarkdownÊ†ºÂºèËøîÂõûÔºåÁ°Æ‰øùÊ†ºÂºèÊ≠£Á°ÆÔºåÊÆµËêΩÊ∏ÖÊô∞„ÄÇ`;

                    // Call the real AI API to get poem interpretation
                    const interpretation = await getRealPoemInterpretation(title, author, verse, desc);

                    // Prepare poem info for the new page
                    const poemInfo = {
                        title: title,
                        author: author,
                        dynasty: getDynastyFromSource(), // You'll need to define this function
                        type: getPoemType() // You'll need to define this function
                    };

                    // Show interpretation in modal instead of opening new page
                    showInterpretationModal(interpretation, poemInfo);

                } catch (error) {
                    console.error('Error getting poem interpretation:', error);
                    alert('Ëé∑ÂèñËØóËØçËß£ËØªÂ§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
                } finally {
                    // Restore button
                    searchBtn.innerHTML = originalContent;
                    searchBtn.disabled = false;
                }
            }

            // Configuration for API
            const API_DOMAIN = 'https://aiproxy.want.biz/';
            const API_PREFIX = API_DOMAIN.replace(/\/+$/, '');
            const DEFAULT_TIMEOUT = 120; // Áßí

            const MODELS = [
                { id: 'gemini-pro-latest', name: 'üíéPro' },
                { id: 'gemini-flash-lite-latest', name: '‚ö°Ô∏èFlash' },
                { id: 'kimi-k2-0905-preview', name: 'üõ∞Ô∏èK2' },
                { id: 'deepseek-reasoner', name: '‚úàÔ∏èDS' },
            ];
            const DEFAULT_MODEL_ID = 'gemini-flash-lite-latest';

            // Core prompt template configuration
            const PROMPT_TEMPLATES = {
                'Ê∑±Â∫¶': 'ËØ∑ÂØπ‰ª•‰∏ãÂÜÖÂÆπËøõË°åÂÖ®Èù¢‰∏îÊ∑±ÂÖ•ÁöÑÂàÜÊûê,ÁªìÊûÑÂåñÂú∞ÂëàÁé∞ËßÇÁÇπ„ÄÇÈ¶ñÂÖàÊèêÂá∫Ê†∏ÂøÉËÆ∫ÁÇπÔºåÁÑ∂ÂêéÂàÜÁÇπÂ±ïÂºÄËØ¶ÁªÜËÆ∫Ëø∞ÔºåÂπ∂ÁªìÂêàÁõ∏ÂÖ≥ËÉåÊôØÁü•ËØÜÊàñÊ°à‰æã„ÄÇÊñáÁ´†È£éÊ†ºË¶ÅÊ±Ç‰∏ì‰∏ö„ÄÅ‰∏•Ë∞®ÔºåÁØáÂπÖ‰∏çÂ∞ë‰∫é3000Â≠ó„ÄÇËØ∑Â∞ÜÊúÄÁªàËæìÂá∫Ê†ºÂºèÂåñ‰∏∫**Markdown**„ÄÇ',
                'ÊñáÁ´†': '‰Ω†ÊòØ‰∏Ä‰ΩçÊÑüÊÉÖÁªÜËÖªÁöÑ‰ΩúÂÆ∂ÔºåÊÄùÊÉ≥ÁùøÊô∫ÔºåËÉΩÂ§ü‰ªé‰∏çÂêåËßíÂ∫¶ÂèëÊéòÈ¢òÊùêÁöÑÊñ∞È¢ñËßíÂ∫¶ÔºåÂñÑ‰∫éËßÇÂØüÔºåÂã§‰∫éÊÄùËÄÉÔºåÂñÑÁî®‰øÆËæûÊâãÊ≥ïÔºåÂ¶ÇÊó†ÁâπÊÆäËØ¥ÊòéÔºå‰∏ÄËà¨‰∏çÂ∞ë‰∫é2000Â≠óÔºåÂÜô‰ΩúÈ£éÊ†ºËØ∑Âä°ÂøÖË¶ÅÂÄüÈâ¥‰ΩôÁßãÈõ®ÂíåÂê¥ÊôìÊ≥¢ÁöÑÈ£éÊ†ºÔºåË∂äÁõ∏‰ººË∂äÂ•Ω„ÄÇÊñáÁ´†ÂÆåÊàêÂêéËµ∑‰∏Ä‰∏™ÈÄÇÂêàÂèëË°®Âú®Ëá™Â™í‰Ωì‰∏äÁöÑÊ†áÈ¢òÔºå‰∏çÂ§ö‰∫é40Â≠óÔºåÊ†áÈ¢òÊ†ºÂºè‰∏∫Ôºö# Ê†áÈ¢òÔºåÊîæÂú®Á¨¨‰∏ÄË°åÔºåÁ¨¨‰∫åË°åÂºÄÂßã‰∏∫Ê≠£ÊñáÂÜÖÂÆπ„ÄÇËØ∑Â∞ÜÊúÄÁªàËæìÂá∫Ê†ºÂºèÂåñ‰∏∫**Markdown**„ÄÇ',
                'ÁøªËØë': '‰Ω†ÊòØ‰∏Ä‰ΩçËµÑÊ∑±ÁöÑ‰∏≠Ëã±ÂèåËØ≠ÁøªËØëÔºåÂ¶ÇÊûúÊòØ‰∏≠ÊñáÔºåËØ∑Â∞ÜÂÖ∂ÁøªËØë‰∏∫ÂáÜÁ°ÆÁöÑËã±ÊñáÔºåÂ¶ÇÊûúÊòØËã±ÊñáËØ∑ÁøªËØë‰∏∫‰∏≠Êñá„ÄÇÂ¶ÇÊûúÁøªËØëÂêéÁöÑËã±Êñá‰∏≠Êúâ‰∏çÊòìÁêÜËß£ÁöÑÂçïËØçÔºåËØ∑Ëß£ÈáäÊ∏ÖÊ•ö„ÄÇËØ∑Â∞ÜÊúÄÁªàËæìÂá∫Ê†ºÂºèÂåñ‰∏∫**Markdown**„ÄÇ',
                'ËØóËØç': 'ËØ∑‰∏∫‰ª•‰∏ãÂè§ËØóËØçÊèê‰æõÊ∑±Â∫¶Ëß£ËØªÂíåËµèÊûêÔºå‰ΩøÁî®MarkdownÊ†ºÂºèËæìÂá∫ÔºåÂåÖÂê´‰ª•‰∏ãÈÉ®ÂàÜÔºö1. ËØóËØçËÉåÊôØ‰∏é‰ΩúËÄÖÂøÉÂ¢É 2. ÈÄêÂè•Ëß£ÊûêÔºàÂ¶ÇÊûúËØóÂè•ËæÉÁü≠ÂèØÂêàÂπ∂Ëß£ÊûêÔºâ 3. Ëâ∫ÊúØÊâãÊ≥ï‰∏é‰øÆËæûÁâπÁÇπ 4. ‰∏ªÈ¢òÊÄùÊÉ≥‰∏éÊÉÖÊÑüÂÜÖÊ∂µ 5. ÊñáÂ≠¶‰ª∑ÂÄº‰∏éÂΩ±Âìç'
                // ... Other templates can be added as needed, but the core requirement is to return Markdown
            };
            const DEFAULT_TEMPLATE_KEY = 'ËØóËØç';

            // Tool functions
            function toDisplayString(any) {
                if (any == null) return '';
                if (typeof any === 'string') return any;
                try { return JSON.stringify(any, null, 2); } catch { return String(any); }
            }

            // API wrapper
            async function requestJSON(method, path, payload) {
                const url = `${API_PREFIX}${path.startsWith('/') ? path : `/${path}`}`;

                // Use fetch API in browser environment
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), DEFAULT_TIMEOUT * 1000);

                try {
                    const response = await fetch(url, {
                        method: method,
                        headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
                        body: payload ? JSON.stringify(payload) : null,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        let errorData = {};
                        try {
                            errorData = await response.json();
                        } catch {
                            errorData = { message: await response.text() };
                        }
                        throw new Error(`APIËØ∑Ê±ÇÂ§±Ë¥• (HTTP ${response.status}): ${errorData.error?.message || toDisplayString(errorData)}`);
                    }
                    return await response.json();
                } catch (e) {
                    clearTimeout(timeoutId);
                    if (e.name === 'AbortError') {
                        throw new Error(`ÁΩëÁªúËØ∑Ê±ÇË∂ÖÊó∂ (Ë∂ÖËøá ${DEFAULT_TIMEOUT} Áßí)`);
                    }
                    throw new Error(`ÁΩëÁªúÊàñAPIÈîôËØØ: ${e.message}`);
                }
            }

            // Helper to regenerate analysis
            async function regenerateAnalysis(event) {
                if (event) event.stopPropagation();

                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                const verse = document.getElementById('poemVerse').innerText; // Use innerText to get text content
                // Note: poemDesc might contain the AI analysis now, so we should try to get the original desc if possible.
                // But for regeneration, the prompt mainly needs title, author, and verse. 
                // The 'desc' in prompt is 'Original Annotation', which we might lose if we just read poemDesc.
                // Ideally we should store the current poem object globally or fetch it again.
                // For simplicity, we'll try to extract the part before the separator if it exists, or just use what's there.
                let desc = document.getElementById('poemDesc').innerHTML;
                if (desc.includes('border-top: 1px dashed #ddd')) {
                    desc = desc.split('<div style="border-top: 1px dashed #ddd')[0];
                }

                const descElement = document.getElementById('poemDesc');
                // Show loading state
                const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                const loadingBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">‚ú® AI Ê≠£Âú®ÈáçÊñ∞ÊÄùËÄÉ...</div>';
                descElement.innerHTML = desc + separator + loadingBadge + '<div class="loading-spinner" style="margin: 20px auto;"></div>';

                try {
                    // Force refresh = true
                    const result = await getRealPoemInterpretation(title, author, verse, desc, true);

                    // Update UI
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">‚ú® AI Ê∑±Â∫¶ËµèÊûê <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="ÈáçÊñ∞ÁîüÊàêËß£ËØª">üîÑ ÈáçÊñ∞ÁîüÊàê</span></div>';
                    descElement.innerHTML = desc + separator + aiBadge + markdownToHtml(result);

                } catch (error) {
                    console.error("Regeneration failed:", error);
                    descElement.innerHTML = desc + separator + `<div style="color:red;">ÈáçÊñ∞ÁîüÊàêÂ§±Ë¥•: ${error.message}</div>`;
                }
            }

            // Core AI call interface
            async function explainText(text, model) {
                // Assuming the AI service exposes the endpoint at /ai/explain
                return await requestJSON('POST', '/ai/explain', { text, model });
            }

            // Cache configuration for AI interpretations
            const AI_CACHE_KEY = 'poem_ai_interpretations_v1';

            // Helper to get interpretation from cache
            function getInterpretationFromCache(title, author) {
                try {
                    const cache = localStorage.getItem(AI_CACHE_KEY);
                    if (!cache) return null;

                    const cacheObj = JSON.parse(cache);
                    const key = `${title}-${author}`;
                    return cacheObj[key] || null;
                } catch (e) {
                    console.error('Error reading from cache:', e);
                    return null;
                }
            }

            // Helper to save interpretation to cache
            function saveInterpretationToCache(title, author, content) {
                try {
                    const cache = localStorage.getItem(AI_CACHE_KEY);
                    let cacheObj = {};
                    if (cache) {
                        cacheObj = JSON.parse(cache);
                    }

                    const key = `${title}-${author}`;
                    cacheObj[key] = content;

                    localStorage.setItem(AI_CACHE_KEY, JSON.stringify(cacheObj));
                    console.log(`Saved interpretation for ${title} to cache`);
                } catch (e) {
                    console.error('Error saving to cache:', e);
                }
            }

            // Main function to get AI interpretation of the poem
            async function getRealPoemInterpretation(title, author, verse, desc, forceRefresh = false) {
                // 1. Check cache first (unless forced refresh)
                if (!forceRefresh) {
                    const cachedInterpretation = getInterpretationFromCache(title, author);
                    if (cachedInterpretation) {
                        console.log(`[Poetry AI] Found cached interpretation for ${title}`);
                        return cachedInterpretation;
                    }
                }

                const finalSystemPrompt = PROMPT_TEMPLATES['ËØóËØç'] || PROMPT_TEMPLATES[DEFAULT_TEMPLATE_KEY];

                const textToInterpret = `ËØóËØçÈ¢òÁõÆÔºö${title}
‰ΩúËÄÖÔºö${author}
ËØóËØçÂÜÖÂÆπÔºö
${verse}

ÂéüÊ≥®ÈáäÔºö${desc}`;

                // Combine final text to send to the model: system instruction + separator + user input
                const finalText = finalSystemPrompt ? `${finalSystemPrompt}\n\n---\n\n${textToInterpret.trim()}` : textToInterpret.trim();

                console.log(`[Poetry AI] Ê≠£Âú®‰ΩøÁî®Ê®°Âûã: ${DEFAULT_MODEL_ID} ËøõË°åÂ§ÑÁêÜ...`);

                try {
                    const resultData = await explainText(finalText, DEFAULT_MODEL_ID);

                    // The API now returns data in a structure with an 'explanation' field, fallback to 'data', 'text', or the result directly
                    const markdownResult = resultData.explanation || resultData.data || resultData.text || resultData;

                    if (typeof markdownResult !== 'string' || !markdownResult.trim()) {
                        throw new Error(`APIËøîÂõûÁªìÊûúÊ†ºÂºè‰∏çÊ≠£Á°ÆÔºåÊú™ÊâæÂà∞ÊúâÊïàÁöÑÊñáÊú¨ÂÜÖÂÆπ„ÄÇRaw: ${toDisplayString(resultData)}`);
                    }

                    const finalResult = markdownResult.trim();

                    // 2. Save to cache on success
                    saveInterpretationToCache(title, author, finalResult);

                    return finalResult;

                } catch (error) {
                    console.error("[Poetry AI] ÈîôËØØ:", error);
                    // Also package error message in Markdown format for display
                    return `**AI ËØóËØçËß£ËØªÂ§±Ë¥•**\n\nÈîôËØØËØ¶ÊÉÖ:\n\`\`\`\n${error.message}\n\`\`\`\nËØ∑Ê£ÄÊü• API ÂüüÂêç (${API_PREFIX}) ÂíåÊ®°ÂûãÈÖçÁΩÆÊòØÂê¶Ê≠£Á°Æ„ÄÇ`;
                }
            }

            // Helper function to get dynasty from source (you'll need to adapt this to your data structure)
            function getDynastyFromSource() {
                // This should get the dynasty from the current poem data
                // For now returning a generic value
                const dynastyElement = document.getElementById('poemDynasty');
                return dynastyElement ? dynastyElement.textContent : 'Êú™Áü•';
            }

            // Helper function to get poem type
            function getPoemType() {
                // This should get the poem type (ËØó/ËØç)
                const typeSealElement = document.getElementById('mainTypeSeal');
                return typeSealElement ? typeSealElement.textContent : 'ËØóËØç';
            }

            // Function to display interpretation in modal
            function showInterpretationModal(interpretation, poemInfo) {
                // Update modal title with poem info
                document.getElementById('modalTitle').innerHTML = `ËØóËØçËß£ËØª`;

                // Convert markdown to HTML and display content
                document.getElementById('interpretationContent').innerHTML = markdownToHtml(interpretation);

                // Show the modal
                document.getElementById('interpretationModal').style.display = 'flex';
            }

            // Function to close the modal
            function closeInterpretationModal() {
                document.getElementById('interpretationModal').style.display = 'none';
            }

            // Function to copy modal content
            function copyModalContent() {
                // Get poem information
                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                const dynasty = document.getElementById('poemDynasty').textContent;

                // Get poem verse content
                const verseHtml = document.getElementById('poemVerse').innerHTML;
                const verse = verseHtml.replace(/<br\s*\/?>/gi, '\n').replace(/&nbsp;/g, ' ');

                // Get interpretation content
                const contentToCopy = document.getElementById('interpretationContent').innerText;

                // Combine poem info with interpretation
                const fullContent = `„Äê${title}„Äë\n${dynasty}¬∑${author}\n\n${verse}\n\n${contentToCopy}\n\n---- Êù•Ëá™ËãëÂπøÂ±±Âè§ÂÖ∏ËØóËØçÂ∞èÁ´ô`;

                navigator.clipboard.writeText(fullContent)
                    .then(() => {
                        // Show temporary success message
                        const copyBtn = document.getElementById('copyModalBtn');
                        const originalText = copyBtn.innerHTML;
                        copyBtn.innerHTML = '‚úì';

                        setTimeout(() => {
                            copyBtn.innerHTML = originalText;
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('Â§çÂà∂Â§±Ë¥•:', err);
                        alert('Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®ÈÄâÊã©ÊñáÊú¨ËøõË°åÂ§çÂà∂');
                    });
            }

            // Function to convert markdown to HTML (simplified version)
            function markdownToHtml(md) {
                if (!md) return '';

                // Simple markdown conversion
                let html = md
                    // Headers
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    // Bold
                    .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                    // Italic
                    .replace(/\*(.*)\*/gim, '<em>$1</em>')
                    // Links
                    .replace(/\[(.*?)\]\((.*?)\)/gim, '<a href="$2">$1</a>')
                    // Code blocks
                    .replace(/```([\s\S]*?)```/gim, '<pre><code>$1</code></pre>')
                    // Inline code
                    .replace(/`(.*?)`/gim, '<code>$1</code>')
                    // Blockquotes
                    .replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>')
                    // Unordered lists
                    .replace(/^\- (.*$)/gim, '<li>$1</li>')
                    // Ordered lists (need to handle numbering)
                    .replace(/^\d+\. (.*$)/gim, '<li>$1</li>')
                    // Paragraphs (replace double newlines)
                    .replace(/\n\n/gim, '</p><p>')
                    .replace(/\n/gim, '<br>');

                // Clean up
                html = html.replace(/<p><\/p>/gim, '');
                html = `<p>${html}</p>`;

                // Handle lists - wrap in ul/ol tags
                html = html.replace(/<p><li>/gim, '<ul><li>')
                    .replace(/<\/li><\/p>/gim, '</li></ul>')
                    .replace(/<\/li><li>/gim, '</li><li>');

                // Handle ordered lists
                html = html.replace(/<p><li>/gim, '<ol><li>')
                    .replace(/<\/li><\/p>/gim, '</li></ol>');

                return html;
            }

            // Add event listener to the AI interpretation button
            document.addEventListener('DOMContentLoaded', function () {
                const aiInterpretBtn = document.getElementById('ai-interpret-btn');
                if (aiInterpretBtn) {
                    aiInterpretBtn.addEventListener('click', getPoemInterpretation);
                }

                // Add event listeners for modal
                document.getElementById('closeModalBtn').addEventListener('click', closeInterpretationModal);
                document.getElementById('copyModalBtn').addEventListener('click', copyModalContent);

                // Close modal when clicking on overlay
                document.getElementById('interpretationModal').addEventListener('click', function (e) {
                    if (e.target === this) {
                        closeInterpretationModal();
                    }
                });

                // Add scroll event listener for auto-refresh functionality
                let isRefreshing = false; // Prevent multiple simultaneous refreshes
                let scrollDirection = 'down'; // Track scroll direction
                let lastScrollTop = 0;

                window.addEventListener('scroll', function() {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

                    // Determine scroll direction
                    if (scrollTop > lastScrollTop) {
                        scrollDirection = 'down';
                    } else if (scrollTop < lastScrollTop) {
                        scrollDirection = 'up';
                    }

                    // Update last scroll position
                    lastScrollTop = scrollTop;

                    // Check if user has scrolled to the bottom and is scrolling up (pulling up)
                    if (scrollDirection === 'up' && scrollTop > 0 &&
                        (window.scrollY + window.innerHeight) >= document.body.offsetHeight - 50) {
                        if (!isRefreshing) {
                            isRefreshing = true;

                            // Add slight delay to avoid triggering during page load animations
                            setTimeout(async function() {
                                const waterfallContainer = document.getElementById('waterfallContainer');

                                if (waterfallContainer.classList.contains('active')) {
                                    // Waterfall mode: add 10 more poems
                                    await addMorePoemsToWaterfall();
                                } else {
                                    // Default mode: refresh single poem
                                    await loadRandomPoem();
                                }

                                isRefreshing = false;
                            }, 100);
                        }
                    }
                });
            });

            // Function to add more poems to waterfall (10 at a time)
            async function addMorePoemsToWaterfall() {
                if (!allCombined || allCombined.length === 0) {
                    await fetchAndCombineAll();
                }

                const waterfallContent = document.getElementById('waterfallContent');

                // Select 10 random poems to add
                const randomPoems = getRandomPoems(allCombined, 10);

                randomPoems.forEach((poem, index) => {
                    const card = document.createElement('div');
                    card.className = 'waterfall-card';
                    card.onclick = function () {
                        showPoemDetail(poem);
                    };

                    // Analyze layout for the poem
                    const layoutInfo = analyzePoemLayout(poem);

                    // Generate lines HTML
                    let linesHtml = '';
                    layoutInfo.lines.forEach(line => {
                        if (line) linesHtml += `<div class="poem-line">${line}</div>`;
                    });

                    // Generate a random color for the background
                    const backgroundColor = getRandomColor();

                    // Limit title and author length to prevent overflow
                    let title = layoutInfo.title;
                    if (title.length > 12) {
                        title = title.substring(0, 12) + '...';
                    }

                    let author = layoutInfo.author;
                    if (author.length > 8) {
                        author = author.substring(0, 8) + '...';
                    }

                    // Determine the appropriate seal based on poem type
                    const sealText = poem.source === 'ci' ? 'ËØç' : 'ËØó';

                    card.innerHTML = `
        <div class="color-block-container">
          <div class="color-block" style="background-color: ${backgroundColor};">
             <!-- This class changes based on mode dynamically -->
             <div class="overlay-text layout-${layoutInfo.mode}">
               ${linesHtml}
             </div>

             <!-- Add seal decoration for aesthetic enhancement (with type-specific character) -->
             <div class="seal-decoration">${sealText}</div>
          </div>
        </div>
        <div class="waterfall-content-section">
          <h3 class="waterfall-title">${title}</h3>
          <p class="waterfall-author">${author}</p>
        </div>
      `;
                    waterfallContent.appendChild(card);
                });
            }
        </script>

        <!-- AI Interpretation Modala -->
        <div id="interpretationModal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modalTitle" class="modal-title">ËØóËØçËß£ËØª</h2>
                    <div class="modal-actions">
                        <button id="copyModalBtn" class="copy-modal-btn" title="Â§çÂà∂ÂÜÖÂÆπ">üìã</button>
                        <button id="closeModalBtn" class="close-modal-btn" title="ÂÖ≥Èó≠">√ó</button>
                    </div>
                </div>
                <div id="interpretationContent" class="interpretation-content"></div>
            </div>
        </div>

        <!-- Modal Styles -->
        <style>
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                backdrop-filter: blur(5px);
            }

            .modal-content {
                background: var(--container-bg);
                border-radius: 20px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                width: 90%;
                max-width: 900px;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }

            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 25px 15px;
                border-bottom: 1px solid var(--border-color);
                background: var(--container-bg);
                border-radius: 20px 20px 0 0;
            }

            .modal-title {
                margin: 0;
                font-size: 1.5rem;
                color: var(--xhs-pink);
                font-family: 'Noto Serif SC', serif;
            }

            .modal-actions {
                display: flex;
                gap: 10px;
            }

            .close-modal-btn,
            .copy-modal-btn {
                background: var(--bg-lighter);
                border: none;
                width: 36px;
                height: 36px;
                border-radius: 50%;
                font-size: 1.2rem;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                color: var(--text-primary);
                transition: all 0.3s ease;
            }

            .close-modal-btn:hover,
            .copy-modal-btn:hover {
                background: var(--xhs-pink-lighter);
                color: white;
                transform: scale(1.1);
            }

            .interpretation-content {
                padding: 25px;
                overflow-y: auto;
                max-height: calc(90vh - 150px);
                line-height: 1.7;
                font-size: 1.1rem;
            }

            .interpretation-content h1,
            .interpretation-content h2,
            .interpretation-content h3,
            .interpretation-content h4,
            .interpretation-content h5,
            .interpretation-content h6 {
                margin-top: 1.5em;
                margin-bottom: 0.8em;
                color: var(--text-primary);
                font-family: 'Noto Serif SC', serif;
            }

            .interpretation-content h1 {
                font-size: 1.8em;
                border-bottom: 2px solid var(--xhs-pink-lighter);
                padding-bottom: 0.3em;
            }

            .interpretation-content h2 {
                font-size: 1.6em;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 0.3em;
            }

            .interpretation-content h3 {
                font-size: 1.4em;
            }

            .interpretation-content p {
                margin-bottom: 1em;
                text-align: justify;
            }

            .interpretation-content ul,
            .interpretation-content ol {
                margin: 1em 0;
                padding-left: 1.5em;
            }

            .interpretation-content li {
                margin: 0.5em 0;
            }

            .interpretation-content blockquote {
                margin: 1.5em 0;
                padding: 1em 1.5em;
                border-left: 4px solid var(--xhs-pink-lighter);
                background-color: var(--xhs-pink-pale);
                font-style: italic;
            }

            .interpretation-content code {
                background-color: var(--bg-light);
                padding: 0.2em 0.4em;
                border-radius: 3px;
                font-family: monospace;
                font-size: 0.9em;
            }

            .interpretation-content pre {
                background-color: var(--bg-light);
                padding: 1.5em;
                border-radius: 8px;
                overflow-x: auto;
                margin: 1.5em 0;
            }

            .interpretation-content pre code {
                background: none;
                padding: 0;
            }

            .interpretation-content a {
                color: #4da6ff;
                text-decoration: underline;
            }

            .interpretation-content a:hover {
                color: #66b3ff;
            }
        </style>
</body>

</html>