<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>诗词 · 小红书风格</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&family=Inter:wght@400;500;600;700&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Light theme variables - Xiaohongshu Style */
            --xhs-pink: #FE2C55;
            --xhs-pink-light: #FF6B8A;
            --xhs-pink-lighter: #FFE5EB;
            --xhs-pink-pale: #FFF5F7;
            --bg-gradient-start: #FFFFFF;
            --bg-gradient-end: #FFF5F7;
            --bg-gradient-mid: #FFFAFC;
            --container-bg: rgba(255, 255, 255, 0.98);
            --container-shadow: rgba(254, 44, 85, 0.08);
            --header-gradient-start: #FE2C55;
            --header-gradient-end: #FF6B8A;
            --header-gradient-mid: #FE4569;
            --header-color: white;
            --text-primary: #333333;
            --text-secondary: #666666;
            --text-tertiary: #999999;
            --text-light: #BBBBBB;
            --bg-light: #FAFAFA;
            --bg-lighter: #F5F5F5;
            --border-color: #EEEEEE;
            --filter-bg: rgba(255, 255, 255, 0.95);
            --poem-desc-bg: rgba(255, 255, 255, 0.98);
            --poem-desc-border: #FE2C55;
            --search-result-bg: #FAFAFA;
            --search-result-hover: #FFF5F7;
            --refresh-btn-gradient-start: #FE2C55;
            --refresh-btn-gradient-end: #FF6B8A;
            --refresh-btn-color: white;
            --clear-btn-bg: #999999;
            --clear-btn-hover: #666666;
            --search-btn-bg: #FE2C55;
            --search-btn-hover: #E02548;
            --footer-color: #999999;
            --accent-glow: rgba(254, 44, 85, 0.2);
            --card-shadow: 0 2px 12px rgba(0, 0, 0, 0.08);
            --card-shadow-hover: 0 4px 20px rgba(254, 44, 85, 0.15);
        }

        .dark-mode {
            /* Dark theme variables - Xiaohongshu Dark Style with improved contrast */
            --xhs-pink: #FF6B8A;
            --xhs-pink-light: #FF8FA8;
            --xhs-pink-lighter: #FFB3C6;
            --xhs-pink-pale: #3A1A25;
            --bg-gradient-start: #0A0A0A;
            --bg-gradient-end: #1A0F1F;
            --bg-gradient-mid: #120C16;
            --container-bg: rgba(30, 30, 30, 0.97);
            --container-shadow: rgba(0, 0, 0, 0.7);
            --header-gradient-start: #E02548;
            --header-gradient-end: #FF6B8A;
            --header-gradient-mid: #F23669;
            --header-color: #FFFFFF;
            --text-primary: #FFFFFF;
            --text-secondary: #E0E0E0;
            --text-tertiary: #C0C0C0;
            --text-light: #A0A0A0;
            --bg-light: #1F1F1F;
            --bg-lighter: #262626;
            --border-color: #555555;
            --filter-bg: rgba(30, 30, 30, 0.95);
            --poem-desc-bg: rgba(25, 25, 25, 0.98);
            --poem-desc-border: #FF6B8A;
            --search-result-bg: #262626;
            --search-result-hover: #3A2A3A;
            --refresh-btn-gradient-start: #E02548;
            --refresh-btn-gradient-end: #FF6B8A;
            --refresh-btn-color: #FFFFFF;
            --clear-btn-bg: #666666;
            --clear-btn-hover: #777777;
            --search-btn-bg: #E02548;
            --search-btn-hover: #C01830;
            --footer-color: #B0B0B0;
            --accent-glow: rgba(255, 107, 138, 0.4);
            --card-shadow: 0 2px 12px rgba(0, 0, 0, 0.5);
            --card-shadow-hover: 0 4px 20px rgba(255, 107, 138, 0.3);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-mid) 50%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 0;
            color: var(--text-primary);
            transition: background 0.5s ease;
        }

        @media (min-width: 768px) {
            body {
                padding: 20px;
            }
        }

        .container {
            max-width: 1200px;
            width: 100%;
            background: transparent;
            border-radius: 0;
            box-shadow: none;
            overflow: visible;
            margin: 0 auto;
            padding: 0 15px;
        }

        @media (min-width: 768px) {
            .container {
                margin: 20px auto;
            }
        }

        header {
            text-align: center;
            padding: 20px 15px;
            background: var(--container-bg);
            color: var(--text-primary);
            position: relative;
            box-shadow: var(--card-shadow);
            border-radius: 20px;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            header {
                padding: 30px 20px;
            }
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
            text-shadow: none;
            letter-spacing: 0.02em;
            font-weight: 600;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            color: var(--xhs-pink);
        }

        .subtitle {
            font-size: 0.95rem;
            opacity: 0.75;
            font-weight: 400;
            letter-spacing: 0.01em;
            color: var(--text-secondary);
        }



        .menu-toggle {
            position: absolute;
            top: 15px;
            right: 60px;
            /* Position to the left of the dark mode toggle */
            background: var(--bg-lighter);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 36px;
            height: 36px;
            font-size: 1.1rem;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: var(--card-shadow);
        }

        .menu-toggle:hover {
            background: var(--xhs-pink-lighter);
            transform: scale(1.05);
            box-shadow: var(--card-shadow-hover);
        }

        @media (min-width: 768px) {
            .menu-toggle {
                top: 20px;
                right: 75px;
                /* Adjust for larger screen */
                width: 45px;
                height: 45px;
            }
        }

        /* Menu overlay styles */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            z-index: 1001;
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            padding-top: 60px;
        }

        .menu-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .menu-content {
            background: var(--container-bg);
            border-radius: 20px;
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transform: translateY(-20px);
            transition: transform 0.3s ease;
        }

        .menu-overlay.active .menu-content {
            transform: translateY(0);
        }

        .menu-header {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .menu-title {
            margin: 0;
            font-size: 1.4rem;
            color: var(--xhs-pink);
            font-family: 'Noto Serif SC', serif;
        }

        .close-menu-btn {
            background: var(--bg-lighter);
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 1.2rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-primary);
            transition: all 0.3s ease;
        }

        .close-menu-btn:hover {
            background: var(--xhs-pink-lighter);
            color: white;
            transform: scale(1.1);
        }

        .menu-options {
            padding: 20px;
        }

        .menu-section {
            margin-bottom: 10px;
        }

        .menu-option {
            display: block;
            width: 100%;
            padding: 15px;
            background: var(--bg-lighter);
            border: none;
            border-radius: 10px;
            text-align: left;
            font-size: 1rem;
            cursor: pointer;
            color: var(--text-primary);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .menu-option:hover {
            background: var(--xhs-pink-lighter);
            color: white;
            transform: translateX(5px);
        }

        .history-list,
        .favorites-list {
            padding: 10px 15px 15px;
            margin-top: -5px;
            margin-bottom: 10px;
            max-height: 300px;
            overflow-y: auto;
            background: var(--xhs-pink-pale);
            border-radius: 0 0 10px 10px;
        }

        .history-list h4,
        .favorites-list h4 {
            margin: 0 0 10px 0;
            font-size: 0.9rem;
            color: var(--xhs-pink);
            font-weight: 600;
        }

        .history-item,
        .favorite-item {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .history-item:hover,
        .favorite-item:hover {
            background: var(--xhs-pink-pale);
            border-radius: 5px;
        }

        .history-item:last-child,
        .favorite-item:last-child {
            border-bottom: none;
        }

        .history-item .title,
        .favorite-item .title {
            font-weight: bold;
            color: var(--text-primary);
        }

        .history-item .author,
        .favorite-item .author {
            font-size: 0.9rem;
            color: var(--text-tertiary);
        }

        .header-search-btn {
            position: absolute;
            top: 10px;
            right: 60px;
            /* Position to the left of the dark mode toggle */
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            color: var(--header-color);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .header-search-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        @media (min-width: 768px) {
            .dark-mode-toggle {
                top: 20px;
                right: 20px;
                width: 45px;
                height: 45px;
            }

            .header-search-btn {
                top: 20px;
                right: 75px;
                /* Adjust for larger screen */
                width: 45px;
                height: 45px;
            }
        }

        .poem-content {
            display: flex;
            flex-direction: column;
            padding: 0;
            gap: 20px;
        }

        @media (min-width: 768px) {
            .poem-content {
                flex-direction: row;
                padding: 20px;
                min-height: 600px;
            }
        }

        @media (max-width: 767px) {
            .poem-content {
                padding: 5px;
            }
        }

        .poem-section {
            background: var(--container-bg);
            border-radius: 15px;
            box-shadow: var(--card-shadow);
            padding: 0px;
            transition: box-shadow 0.3s ease;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .poem-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        @media (min-width: 768px) {
            .poem-section {
                padding: 0px;
                /* Reduced from 20px to 10px */
            }
        }

        .image-section {
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            min-height: 280px;
            max-height: 380px;
        }

        @media (min-width: 768px) {
            .image-section {
                padding: 0;
                margin: 0;
                min-height: 380px;
                max-height: 380px;
            }
        }

        .poem-image {
            width: 100%;
            max-width: 100%;
            height: 100%;
            aspect-ratio: 4/3;
            border-radius: 15px 15px 0 0;
            object-fit: cover;
            box-shadow: none;
            transition: transform 0.3s ease;
            border: none;
            margin: 0;
            padding: 0;
        }

        .poem-image:hover {
            transform: scale(1.01);
            box-shadow: none;
        }

        .text-section {
            position: relative;
            /* Elegant solid gradient background - no pixelation */
            background: linear-gradient(
                135deg,
                #fefdfb 0%,
                #fdfcf7 25%,
                #fcfaf4 50%,
                #fbf9f0 75%,
                #faf8ed 100%
            );
            padding: 5px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            flex: 1;
            border-radius: 0 0 15px 15px;
            /* Enhanced inner shadow for realistic paper depth */
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.8),
                inset 0 -1px 0 rgba(200, 180, 150, 0.3),
                inset 1px 0 0 rgba(200, 180, 150, 0.2),
                inset -1px 0 0 rgba(255, 255, 255, 0.5),
                inset 0 0 10px rgba(0, 0, 0, 0.08);
        }

        /* Subtle paper texture overlay using pseudo-element */
        .text-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Very subtle paper fiber texture */
            background-image:
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.008) 0px,
                    rgba(0, 0, 0, 0.008) 1px,
                    transparent 1px,
                    transparent 3px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(0, 0, 0, 0.008) 0px,
                    rgba(0, 0, 0, 0.008) 1px,
                    transparent 1px,
                    transparent 3px
                );
            opacity: 0.5;
            border-radius: 0 0 15px 15px;
            pointer-events: none;
        }

        /* Dark mode text-section - elegant solid gradient */
        .dark-mode .text-section {
            background: linear-gradient(
                135deg,
                #2d2d2d 0%,
                #282828 25%,
                #242424 50%,
                #202020 75%,
                #1c1c1c 100%
            );
            color: var(--text-primary);
            box-shadow:
                inset 0 1px 0 rgba(255, 255, 255, 0.05),
                inset 0 -1px 0 rgba(100, 100, 100, 0.2),
                inset 1px 0 0 rgba(100, 100, 100, 0.1),
                inset -1px 0 0 rgba(255, 255, 255, 0.03),
                inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .dark-mode .text-section::before {
            background-image:
                repeating-linear-gradient(
                    0deg,
                    rgba(255, 255, 255, 0.008) 0px,
                    rgba(255, 255, 255, 0.008) 1px,
                    transparent 1px,
                    transparent 3px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0.008) 0px,
                    rgba(255, 255, 255, 0.008) 1px,
                    transparent 1px,
                    transparent 3px
                );
            opacity: 0.3;
        }

        /* Ensure poem text colors in dark mode have good contrast */
        .dark-mode .poem-verse {
            color: var(--text-secondary);
        }

        .dark-mode .poem-verse.vertical-mode,
        .dark-mode .poem-verse.horizontal-mode {
            color: var(--text-primary);
        }

        /* Vertical text layout for regular poems (shi) */
        .text-section.vertical-text {
            align-items: center;
        }

        .poem-verse.vertical-layout {
            display: flex;
            flex-direction: column;
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            font-size: 1.4rem;
            letter-spacing: 0.4em;
            line-height: 1.7;
            color: var(--text-secondary);
            text-align: center;
            margin: 0 auto;
            height: auto;
            white-space: nowrap;
        }

        .vertical-line {
            display: inline-flex;
            flex-direction: column;
        }

        .vertical-char {
            margin: 2px 0;
        }

        /* Enhanced styles for improved default mode */

        /* Dynasty tag styling */
        .poem-author-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
            justify-content: center;
        }

        .dynasty-tag {
            background-color: var(--xhs-pink);
            color: white;
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: sans-serif;
            /* 衬线体配无衬线标签 */
            vertical-align: middle;
        }

        .dark-mode .dynasty-tag {
            background-color: var(--xhs-pink-light);
            color: #ffffff;
        }

        /* 正文排版容器 */
        .poem-verse-container {
            position: relative;
            padding: 10px;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 竖排模式 (关键优化) */
        .poem-verse.vertical-mode {
            writing-mode: vertical-rl;
            text-orientation: upright;
            font-size: 1.6rem;
            letter-spacing: 0.4em;
            line-height: 2.1;
            /* Reduced from 2.5 */
            height: auto;
            max-height: 500px;
            /* 防止过高 */
            text-align: justify;
            margin: 0 auto;
            font-family: 'Noto Serif SC', serif;
        }

        .dark-mode .poem-verse.vertical-mode {
            color: var(--text-primary);
        }

        /* 横排模式优化 */
        .poem-verse.horizontal-mode {
            font-size: 1.6rem;
            line-height: 1.9;
            text-align: center;
            max-width: 95%;
        }

        .dark-mode .poem-verse.horizontal-mode {
            color: var(--text-primary);
        }

        /* Couplets for 7-character poems - display two lines together */
        /* 确保这是最新的样式 */
        .couplet-row {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 0;
            /* 关键：去掉外边距 */
            padding: 10px 0;
            /* 关键：只用内边距控制，10px-12px 比较合适 */
            border-bottom: 1px dashed rgba(128, 128, 128, 0.15);
            width: 100%;
        }

        /* 稍微增加一点行内文字的紧凑度，让两行诗靠近，这样组与组的区分度更好 */
        .horizontal-mode .couplet-row {
            line-height: 1.6;
        }

        .dark-mode .couplet-row {
            border-bottom: 1px dashed rgba(255, 255, 255, 0.1);
        }

        /* This seal will be used in the main display */
        .main-seal {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 40px;
            height: 40px;
            font-size: 18px;
            border: 2px solid #d44c4c;
            color: #d44c4c;
            background: rgba(255, 255, 255, 0.8);
            opacity: 0.8;
            transform: rotate(-5deg);
            pointer-events: none;
            /* 不挡鼠标 */
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-weight: bold;
        }

        .dark-mode .main-seal {
            background: rgba(40, 40, 40, 0.9);
            color: #FF6B8A;
            border-color: #FF6B8A;
        }

        /* Adjusted description section styling */
        .desc-section {
            /* 变成一个稍微深一点的背景，像书的封底 */
            background: #fdfdfd;
            border-left: 4px solid var(--xhs-pink-lighter);
            /* 左侧装饰线 */
        }

        .dark-mode .desc-section {
            background: #222222;
            border-left: 4px solid var(--xhs-pink-light);
            /* 左侧装饰线 in dark mode */
        }

        .poem-desc {
            font-size: 1rem;
            color: #555;
            text-align: justify;
            /* 两端对齐更像书 */
        }

        .dark-mode .poem-desc {
            color: var(--text-tertiary);
        }

        /* 首字下沉效果 (可选) */
        .poem-desc::first-letter {
            font-size: 1.5em;
            font-weight: bold;
            color: var(--xhs-pink);
            float: left;
            margin-right: 4px;
            line-height: 1;
        }

        .dark-mode .poem-desc::first-letter {
            color: var(--xhs-pink-light);
        }

        /* Seal decoration for default mode */
        .seal-default-mode {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 30px;
            height: 30px;
            background-color: rgba(180, 30, 30, 0.7);
            color: white;
            border-radius: 50%;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: serif;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            z-index: 11;
            opacity: 0.8;
        }

        @media (min-width: 768px) {
            .text-section {
                padding: 10px;
            }
        }

        .poem-title {
            font-size: 2.0rem;
            /* Reduced from 2.2rem to 2.0rem */
            color: var(--text-primary);
            text-align: center;
            margin-bottom: 12px;
            font-weight: 700;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            letter-spacing: 0.05em;
            line-height: 1.3;
            padding: 0 10px;
            position: relative;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .inline-search-btn {
            background: rgba(99, 102, 241, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .inline-search-btn.absolute-position {
            position: absolute;
            top: 20px;
            /* Adjust to align with title */
            right: 10px;
            /* Position to the right */
        }

        .inline-search-btn:hover {
            background: rgba(107, 114, 128, 0.3);
            transform: scale(1.15);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .ai-interpret-btn {
            background: rgba(99, 102, 241, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: none;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            font-size: 0.9rem;
            cursor: pointer;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .ai-interpret-btn.absolute-position {
            position: absolute;
            top: 20px;
            /* Align with title text */
            right: 10px;
            /* Position to the right of the title */
        }

        .ai-interpret-btn:hover {
            background: rgba(107, 114, 128, 0.3);
            transform: scale(1.15);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .positioned-title {
            position: relative;
        }

        .poem-author {
            font-size: 1.3rem;
            /* Increased from 1.1rem to 1.3rem */
            color: var(--text-tertiary);
            text-align: center;
            margin-bottom: 12px;
            font-style: normal;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            letter-spacing: 0.02em;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .poem-type {
            font-size: 1.1rem;
            /* Increased from 0.9rem to 1.1rem */
            color: var(--xhs-pink);
            text-align: center;
            margin-bottom: 18px;
            background: var(--xhs-pink-lighter);
            display: inline-block;
            padding: 6px 16px;
            border-radius: 20px;
            align-self: center;
            font-weight: 500;
            min-height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .poem-verse {
            font-size: 1.6rem;
            /* Increased from 1.2rem to 1.6rem for larger text */
            line-height: 1.9;
            /* Adjusted line height for better readability */
            color: var(--text-secondary);
            text-align: center;
            margin: 0;
            font-weight: 400;
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            letter-spacing: 0.03em;
            white-space: normal;
            /* Allow line breaks */
            word-wrap: break-word;
            /* Break long words if needed */
        }

        /* Ensure <br> tags create line breaks */
        .poem-verse br {
            display: block;
        }

        /* Make sure poem verse allows line breaks */
        .poem-verse {
            overflow-wrap: break-word;
            word-wrap: break-word;
        }

        /* Paragraph breaks between sections of poems */
        .poem-paragraph-break {
            display: block;
            height: 1.5em;
            /* Create visual separation between poem sections */
        }

        .desc-section {
            background: var(--container-bg);
            border-radius: 20px;
            box-shadow: var(--card-shadow);
            padding: 10px;
            /* Reduced from 20px to 10px */
            transition: box-shadow 0.3s ease;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .desc-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        @media (min-width: 768px) {
            .desc-section {
                padding: 15px;
                /* Reduced from 20px to 15px */
            }
        }

        .poem-desc {
            font-size: 1.1rem;
            /* Increased from 0.95rem to 1.1rem */
            line-height: 1.7;
            /* Reduced from 1.8 to 1.7 */
            color: var(--text-tertiary);
            padding: 0;
            background: transparent;
            border-radius: 0;
            border-left: none;
            height: 100%;
            overflow-y: auto;
            flex: 1;
        }

        .poem-desc a {
            color: #4da6ff;
            text-decoration: underline;
        }

        .poem-desc a:hover {
            color: #66b3ff;
        }

        @media (min-width: 768px) {
            .poem-desc {
                padding: 20px;
            }
        }

        .poem-desc h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .controls {
            text-align: center;
            padding: 0;
            margin-bottom: 20px;
        }

        @media (min-width: 768px) {
            .controls {
                padding: 30px;
            }
        }

        .refresh-btn {
            background: linear-gradient(135deg, var(--refresh-btn-gradient-start) 0%, var(--refresh-btn-gradient-end) 100%);
            color: var(--refresh-btn-color);
            border: none;
            padding: 12px 24px;
            font-size: 1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: var(--card-shadow);
            font-weight: 600;
            letter-spacing: 0.01em;
            position: relative;
            overflow: hidden;
        }

        .refresh-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .refresh-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .refresh-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--card-shadow-hover);
        }

        .refresh-btn:active {
            transform: translateY(0);
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2rem;
            color: #666;
        }

        .poem-meta {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .poem-meta span {
            background: #e9ecef;
            padding: 5px 12px;
            border-radius: 15px;
            font-size: 0.9rem;
            color: #555;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: var(--footer-color);
            font-size: 0.85rem;
            margin-top: 20px;
        }

        @media (min-width: 768px) {
            footer {
                padding: 20px;
            }
        }

        /* Animation for content loading */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.8s ease forwards;
        }

        .filter-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            padding: 18px;
            background: var(--container-bg);
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            transition: box-shadow 0.3s ease;
        }

        .filter-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        .filter-section label {
            font-weight: bold;
            color: var(--text-primary);
            white-space: nowrap;
            display: flex;
            align-items: center;
            min-height: 40px;
            /* Consistent height */
            padding: 0 5px;
            /* Uniform padding */
            box-sizing: border-box;
            /* Include padding in height calculation */
        }

        .filter-section select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            background: var(--container-bg);
            color: var(--text-primary);
            font-size: 1rem;
            min-width: 120px;
            flex: 1;
            min-width: 0;
            /* Allow it to shrink below min-width */
            height: 40px;
            /* Fixed height to ensure consistency */
            min-height: 40px;
            /* Consistent height */
            box-sizing: border-box;
            /* Include padding in height calculation */
            line-height: 1.2;
            /* Control text alignment inside the select */
        }

        .filter-section button {
            padding: 8px 16px;
            background: var(--clear-btn-bg);
            color: var(--refresh-btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            min-height: 40px;
            /* Consistent height */
            box-sizing: border-box;
            /* Include padding in height calculation */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .filter-section button:hover {
            background: var(--clear-btn-hover);
        }

        .search-section {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            align-items: center;
            padding: 18px;
            background: var(--container-bg);
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            transition: box-shadow 0.3s ease;
        }

        .search-section:hover {
            box-shadow: var(--card-shadow-hover);
        }

        .search-section.show {
            display: flex;
        }

        .search-section input {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            font-size: 1rem;
            min-width: 200px;
            flex: 1;
            background: var(--container-bg);
            color: var(--text-primary);
        }

        .search-section button {
            padding: 8px 16px;
            background: var(--search-btn-bg);
            color: var(--refresh-btn-color);
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .search-section button:nth-child(3) {
            background: var(--clear-btn-bg);
            /* Different color for clear button */
        }

        .search-section button:hover {
            background: var(--search-btn-hover);
        }

        .search-section button:nth-child(3):hover {
            background: var(--clear-btn-hover);
            /* Different hover for clear button */
        }



        .search-toggle-btn {
            background: #17a2b8 !important;
            /* Override default button color */
            display: flex !important;
            align-items: center !important;
            gap: 4px !important;
        }

        .search-toggle-btn:hover {
            background: #138496 !important;
        }

        .search-results {
            margin-bottom: 20px;
            padding: 20px;
            background: var(--container-bg);
            border-radius: 20px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
        }

        .search-results h3 {
            margin-top: 0;
            color: var(--text-primary);
            text-align: center;
        }

        .search-results ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .search-results li {
            padding: 8px;
            border-bottom: 1px solid var(--border-color);
            cursor: pointer;
            color: var(--text-tertiary);
        }

        .search-results li:hover {
            background-color: var(--search-result-hover);
        }

        .search-results .result-title {
            font-weight: bold;
            color: #4da6ff;
        }

        .search-results .result-author {
            font-style: italic;
            color: var(--text-light);
            font-size: 0.9em;
        }

        .search-results .result-preview {
            margin-top: 4px;
            color: var(--text-tertiary);
            font-size: 0.9em;
        }

        /* Mobile-specific styles for filter section */
        @media (max-width: 767px) {
            .filter-section {
                flex-direction: row;
                flex-wrap: nowrap;
                /* Keep items in a single line */
                align-items: center;
                padding: 8px;
                margin: 5px;
                gap: 3px;
                min-height: 40px;
            }

            .filter-section label {
                font-size: 0.65rem;
                white-space: nowrap;
                margin: 0;
                flex-shrink: 0;
                min-height: 34px;
                /* Consistent height for mobile */
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0 2px;
                /* Uniform padding for mobile */
            }

            .filter-section select {
                min-width: 0;
                font-size: 0.65rem;
                padding: 2px 4px;
                /* Adjusted padding for better height consistency */
                flex: 1 1 auto;
                height: 34px;
                /* Fixed height to ensure consistency */
                min-height: 34px;
                /* Consistent height for mobile */
                max-width: 70px;
                /* Further reduce width to fit all elements */
                flex-basis: 70px;
                box-sizing: border-box;
                /* Include padding in height calculation */
                line-height: 1.2;
                /* Control text alignment inside the select */
            }

            .filter-section button {
                font-size: 0.65rem;
                padding: 2px 4px;
                min-height: 34px;
                /* Consistent height for mobile */
                white-space: nowrap;
                flex: 0 0 auto;
                /* Prevent button from shrinking */
                min-width: 50px;
                /* Ensure minimum button width for tap targets */
                box-sizing: border-box;
                /* Include padding in height calculation */
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .search-toggle-btn {
                min-width: 45px !important;
                /* Smaller width for search button on mobile */
                padding: 2px 3px !important;
                /* Smaller padding on mobile */
                font-size: 0.6rem !important;
                /* Smaller font on mobile */
            }
        }

        /* Stack elements on very narrow screens */
        @media (max-width: 400px) {
            .filter-section {
                flex-wrap: wrap;
                /* Allow wrapping if too narrow */
                flex-direction: row;
                align-content: center;
            }
        }

        /* Mobile-specific styles for search section */
        @media (max-width: 767px) {
            .search-section {
                flex-direction: row;
                flex-wrap: wrap;
                padding: 8px;
                margin: 5px;
                gap: 4px;
            }

            .search-section input {
                font-size: 0.8rem;
                padding: 5px;
                min-width: 100px;
                flex: 2;
                min-height: 30px;
            }

            .search-section button {
                font-size: 0.8rem;
                padding: 5px 8px;
                min-height: 30px;
                flex: 1;
            }
        }

        @media (max-width: 480px) {
            .search-section {
                flex-direction: column;
            }

            .search-section input {
                width: 100%;
            }

            .search-section button {
                width: 100%;
            }
        }

        /* Poetry-specific styling */
        strong {
            color: #667eea;
            font-weight: bold;
        }

        p {
            margin: 10px 0;
        }

        mark {
            background-color: #ffeb3b;
            padding: 0 2px;
            border-radius: 2px;
        }

        .floating-refresh-btn {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--refresh-btn-gradient-start) 0%, var(--refresh-btn-gradient-end) 100%);
            color: white;
            border: none;
            font-size: 22px;
            cursor: pointer;
            box-shadow: var(--card-shadow-hover);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: all 0.3s ease;
            animation: float 3s ease-in-out infinite;
            pointer-events: auto;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0px);
            }

            50% {
                transform: translateY(-8px);
            }
        }

        .floating-refresh-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px rgba(254, 44, 85, 0.4);
            animation: none;
        }

        /* Mobile-specific styles for floating button */
        @media (max-width: 767px) {
            .floating-refresh-btn {
                bottom: 20px;
                right: 20px;
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
        }

        /* Waterfall Flow Layout */
        .waterfall-container {
            display: none;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px 5px;
            /* Reduced from 20px 10px to save space */
        }

        .waterfall-container.active {
            display: block;
        }

        .waterfall-content {
            column-count: 2;
            column-gap: 12px;
            /* Reduced from 20px to save space */
            /* Enhanced background with subtle pattern */
            background:
                linear-gradient(90deg, rgba(254, 44, 85, 0.02) 1px, transparent 1px),
                linear-gradient(rgba(254, 44, 85, 0.02) 1px, transparent 1px),
                var(--bg-gradient-start);
            background-size: 50px 50px;
        }

        @media (max-width: 1024px) {
            .waterfall-content {
                column-count: 2;
            }
        }

        @media (max-width: 767px) {
            .waterfall-content {
                column-count: 1;
            }
        }

        /* On very wide screens, allow 3 columns */
        @media (min-width: 1400px) {
            .waterfall-content {
                column-count: 3;
            }
        }

        .waterfall-card {
            display: block;
            background: var(--container-bg);
            border-radius: 20px;
            overflow: hidden;
            margin-bottom: 15px;
            /* Increased from 12px for better spacing */
            break-inside: avoid;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
            cursor: pointer;
            height: 340px;
            /* Increased from 300px for better proportions */
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(254, 44, 85, 0.08);
            /* Subtle border for depth */
            /* Enhanced texture effects */
            position: relative;
            background: var(--container-bg); /* Base background */
        }

        .waterfall-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* Subtle texture using SVG noise pattern */
            background-image:
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.15) 1.5px, transparent 2px),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.15) 1.5px, transparent 2px),
                radial-gradient(circle at 40% 40%, rgba(0, 0, 0, 0.08) 1px, transparent 1.5px),
                radial-gradient(circle at 60% 60%, rgba(0, 0, 0, 0.08) 1px, transparent 1.5px),
                /* Subtle noise texture */
                url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.05'/%3E%3C/svg%3E");
            background-size: 60px 60px, 70px 70px, 45px 45px, 35px 35px, 256px 256px;

            /* Set transparency and blend mode for natural texture effect */
            opacity: 0.5;
            mix-blend-mode: overlay;

            pointer-events: none; /* Ensure pseudo-element doesn't interfere with mouse events */
            border-radius: 20px; /* Match card border-radius */
        }

        .waterfall-card:hover::before {
            /* Enhanced texture effect on hover */
            background-image:
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.2) 1.5px, transparent 2px),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.2) 1.5px, transparent 2px),
                radial-gradient(circle at 40% 40%, rgba(0, 0, 0, 0.1) 1px, transparent 1.5px),
                radial-gradient(circle at 60% 60%, rgba(0, 0, 0, 0.1) 1px, transparent 1.5px),
                /* More prominent noise on hover */
                url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.1'/%3E%3C/svg%3E");
            background-size: 60px 60px, 70px 70px, 45px 45px, 35px 35px, 256px 256px;
            opacity: 0.6;
        }

        .waterfall-card:hover {
            transform: translateY(-5px) scale(1.02);
            /* Added subtle scale */
            box-shadow: var(--card-shadow-hover);
            /* Enhanced texture effect on hover with more intensity */
            background-image:
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.2) 1.5px, transparent 2px),
                radial-gradient(circle at 80% 80%, rgba(255, 255, 255, 0.2) 1.5px, transparent 2px),
                radial-gradient(circle at 40% 40%, rgba(0, 0, 0, 0.1) 1px, transparent 1.5px),
                radial-gradient(circle at 60% 60%, rgba(0, 0, 0, 0.1) 1px, transparent 1.5px),
                /* Add subtle noise on hover for extra texture */
                url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.6' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            background-size: 50px 50px, 60px 60px, 40px 40px, 30px 30px, 256px 256px;
        }

        .color-block {
            width: 100%;
            height: 200px;
            /* Increased from 170px for better text visibility */
            display: block;
            position: relative;
            /* Base gradient for background */
            background:
                linear-gradient(135deg, rgba(0, 0, 0, 0.05) 0%, rgba(255, 255, 255, 0.05) 100%);
            transition: all 0.3s ease;
        }

        .color-block::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;

            /* Rice paper texture using SVG pattern */
            background-image:
                /* Base texture - subtle paper */
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E"),
                /* Additional canvas-like pattern */
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.03) 0px,
                    rgba(0, 0, 0, 0.03) 1px,
                    transparent 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(0, 0, 0, 0.03) 0px,
                    rgba(0, 0, 0, 0.03) 1px,
                    transparent 1px,
                    transparent 2px
                );
            background-size:
                100px 100px,
                4px 4px,
                4px 4px;

            /* Set transparency and blend mode for natural texture effect */
            opacity: 0.3;
            mix-blend-mode: multiply;

            pointer-events: none; /* Ensure pseudo-element doesn't interfere with mouse events */
        }

        .color-block:hover::after {
            /* Enhanced texture effect on hover */
            background-image:
                /* Base texture - more prominent on hover */
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.25'/%3E%3C/svg%3E"),
                /* Additional canvas-like pattern */
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.05) 0px,
                    rgba(0, 0, 0, 0.05) 1px,
                    transparent 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(0, 0, 0, 0.05) 0px,
                    rgba(0, 0, 0, 0.05) 1px,
                    transparent 1px,
                    transparent 2px
                );
            background-size:
                100px 100px,
                4px 4px,
                4px 4px;
            opacity: 0.4;
        }

        .overlay-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            padding: 20px;
        }

        .dark-mode .overlay-text {
            color: #ffffff;
        }

        /* Mode 1: Vertical layout (suitable for 5/7-character poems) */
        .layout-vertical {
            flex-direction: row-reverse;
            /* Ancient Chinese reads from right to left */
            gap: 12px;
        }

        .layout-vertical .poem-line {
            writing-mode: vertical-rl;
            /* Vertical text */
            text-orientation: upright;
            font-family: 'Noto Serif SC', serif;
            font-size: 1.4rem;
            /* Vertical text can be larger */
            letter-spacing: 0.3em;
            /* Increase letter spacing for more breathing room */
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
            border-left: 1px solid rgba(255, 255, 255, 0.2);
            /* Decorative line */
            padding-left: 8px;
        }

        .layout-vertical .poem-line:last-child {
            border-left: none;
        }

        .dark-mode .layout-vertical .poem-line {
            color: rgba(255, 255, 255, 0.98);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        /* Mode 2: Horizontal center layout (suitable for ci/named phrases) */
        .layout-horizontal-center {
            flex-direction: column;
            gap: 16px;
        }

        .layout-horizontal-center .poem-line {
            font-family: 'Noto Serif SC', serif;
            font-size: 1.3rem;
            letter-spacing: 0.1em;
            color: white;
            text-align: center;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
            position: relative;
        }

        .dark-mode .layout-horizontal-center .poem-line {
            color: #ffffff;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
        }

        /* Add decoration like quotes for horizontal quotes */
        .layout-horizontal-center::before {
            content: "" ";
 font-family: serif;
            font-size: 4rem;
            position: absolute;
            top: 10px;
            left: 15px;
            opacity: 0.3;
            color: white;
        }

        /* Fallback for default layout - keep the original styling */
        .layout-horizontal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            /* Increased from 1rem for better readability */
            font-weight: 500;
            text-align: center;
            width: 98%;
            /* Reduced from 85% for better centering */
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.9);
            /* Enhanced shadow for better contrast */
            z-index: 10;
            /* Allow text to wrap to multiple lines */
            white-space: normal;
            word-wrap: break-word;
            overflow: hidden;
            /* Keep text within bounds */
            line-height: 1.8;
            /* Increased from 1.6 for seven-character poems */
            letter-spacing: 0.05em;
            /* Better spacing for Chinese characters */
            font-family: 'Noto Serif SC', 'STSong', 'Songti SC', serif;
            /* Use Chinese typography for proper character alignment */
        }

        .seal-decoration {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 28px;
            height: 28px;
            background:
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.4) 0%, transparent 40%),
                linear-gradient(135deg, #c81e1e, #8a0a0a);
            color: white;
            border-radius: 4px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: serif;
            border: 1px solid rgba(255, 255, 255, 0.5);
            box-shadow:
                0 2px 4px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            z-index: 11;
            opacity: 0.9;
            /* Add texture to the seal */
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
        }

        .color-block-container {
            position: relative;
            width: 100%;
            height: 200px;
            /* Increased from 170px for better text visibility */
            border-radius: 20px 20px 0 0;
            overflow: hidden;
        }

        .waterfall-content-section {
            padding: 12px 15px;
            /* Increased from 4px 6px for better spacing */
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
            /* Add gap between title and author */
            /* Paper-like texture background */
            background:
                /* Base color with subtle texture */
                linear-gradient(0deg, rgba(255, 255, 255, 0.9) 0%, rgba(245, 245, 240, 0.9) 100%),
                /* Paper fiber texture */
                repeating-linear-gradient(
                    0deg,
                    rgba(0, 0, 0, 0.02) 0px,
                    rgba(0, 0, 0, 0.02) 1px,
                    transparent 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(0, 0, 0, 0.02) 0px,
                    rgba(0, 0, 0, 0.02) 1px,
                    transparent 1px,
                    transparent 2px
                );
            /* Subtle inner shadow for depth */
            box-shadow:
                inset 2px 2px 4px rgba(0, 0, 0, 0.05),
                inset -2px -2px 4px rgba(255, 255, 255, 0.5);
        }

        .dark-mode .waterfall-content-section {
            /* Paper-like texture background for dark mode */
            background:
                /* Base color with subtle texture */
                linear-gradient(0deg, rgba(40, 40, 40, 0.9) 0%, rgba(30, 30, 30, 0.9) 100%),
                /* Paper fiber texture */
                repeating-linear-gradient(
                    0deg,
                    rgba(255, 255, 255, 0.02) 0px,
                    rgba(255, 255, 255, 0.02) 1px,
                    transparent 1px,
                    transparent 2px
                ),
                repeating-linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0.02) 0px,
                    rgba(255, 255, 255, 0.02) 1px,
                    transparent 1px,
                    transparent 2px
                );
            /* Subtle inner shadow for depth in dark mode */
            box-shadow:
                inset 2px 2px 4px rgba(0, 0, 0, 0.2),
                inset -2px -2px 4px rgba(80, 80, 80, 0.1);
        }

        .waterfall-title {
            font-size: 1rem;
            /* Increased from 0.9rem for better readability */
            font-weight: 600;
            color: var(--text-primary);
            margin: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .waterfall-author {
            font-size: 0.8rem;
            /* Increased from 0.75rem for better readability */
            color: var(--text-tertiary);
            margin: 0;
            /* Removed margin, using gap in parent instead */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .poem-content.symmetric-layout {
            display: flex;
        }

        .poem-content.waterfall-layout {
            display: none;
        }

        .poem-content.waterfall-active {
            display: none;
        }

        .poem-content.symmetric-active {
            display: flex;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>古典诗词</h1>
            <div class="subtitle">品味千年文化，感受诗词之美</div>
            <button id="menuToggle" class="menu-toggle" title="菜单">
                🎋
            </button>
        </header>

        <div class="controls">
            <div class="filter-section">
                <label for="authorFilter"></label>
                <select id="authorFilter" onchange="filterByAuthor()">
                    <option value="">作者</option>
                </select>
                <label for="poemList"></label>
                <select id="poemList" onchange="selectPoem()">
                    <option value="">作品</option>
                </select>
                <button class="refresh-btn" onclick="clearFilter()">清除</button>
                <button class="refresh-btn search-toggle-btn" onclick="toggleSearch()">🔍 搜诗词</button>
                <button class="refresh-btn" id="layoutToggle" onclick="toggleLayout()">瀑布流</button>
            </div>

            <!-- Search Section (Initially Hidden) -->
            <div id="searchSection" class="search-section" style="display: none;">
                <input type="text" id="searchInput" placeholder="搜索诗歌标题或正文..." onkeypress="handleSearchKeyPress(event)">
                <button class="refresh-btn" onclick="performSearch()">搜索</button>
                <button class="refresh-btn" onclick="hideSearch()">收起</button>
            </div>

            <!-- Search Results Section -->
            <div id="searchResults" class="search-results" style="display: none;">
                <h3>搜索结果</h3>
                <ul id="searchResultsList"></ul>
            </div>
        </div>

        <div class="poem-content">
            <div class="poem-section">
                <div class="image-section">
                    <img id="poemImage" class="poem-image fade-in" src="" alt="诗词配图">
                </div>
                <div class="text-section">
                    <div id="loading" class="loading">诗词加载中...</div>

                    <div id="poemTextContent"
                        style="display: none; width: 100%; display: flex; flex-direction: column; align-items: center;">

                        <!-- 头部组合：标题+作者 -->
                        <div class="poem-header-group">
                            <div class="poem-meta"
                                style="margin-bottom: 10px; display: flex; justify-content: center; gap: 10px;">
                                <!-- 搜索按钮保留 -->
                                <button id="inlineSearchBtn" class="inline-search-btn" title="搜索诗词赏析">🔍</button>
                                <button onclick="copyPoemToClipboard()" class="inline-search-btn"
                                    title="复制诗词">📋</button>
                                <button id="favoriteToggleBtn" class="inline-search-btn" title="收藏此诗词">
                                    ♡
                                </button>
                                <button id="ai-interpret-btn" class="ai-interpret-btn" title="AI解读诗词">
                                    💡
                                </button>
                            </div>
                            <div style="position: relative; width: 100%; min-height: 60px;">
                                <h2 id="poemTitle" class="poem-title positioned-title"></h2>
                            </div>
                            <div class="poem-author-badge">
                                <span id="poemDynasty" class="dynasty-tag">唐</span> <!-- 动态年份 -->
                                <span id="poemAuthor"></span>
                            </div>
                        </div>

                        <!-- 正文容器 -->
                        <div class="poem-verse-container">
                            <div id="poemVerse" class="poem-verse"></div>
                            <!-- 大印章 (will be updated dynamically) -->
                            <div class="seal-decoration main-seal" id="mainTypeSeal">诗</div>
                        </div>

                    </div>
                </div>
            </div>
            <div class="desc-section">
                <div id="poemDescContent" style="display: none;">
                    <div class="poem-desc" id="poemDesc"></div>
                </div>
            </div>
        </div>

        <!-- Waterfall Flow Container -->
        <div id="waterfallContainer" class="waterfall-container">
            <div id="waterfallContent" class="waterfall-content">
                <!-- Waterfall cards will be dynamically generated here -->
            </div>
        </div>

        <!-- Floating Refresh Button -->
        <button class="floating-refresh-btn" onclick="refreshContent()" title="刷新内容">
            ♻️
        </button>

        <footer>
            <p>Powered by yuangs| 随机展示经典诗词</p>
        </footer>

        <!-- Menu Overlay -->
        <div id="menuOverlay" class="menu-overlay">
            <div class="menu-content">
                <div class="menu-header">
                    <h3 class="menu-title">菜单</h3>
                    <button id="closeMenuBtn" class="close-menu-btn" title="关闭">×</button>
                </div>
                <div class="menu-options">
                    <!-- History Section -->
                    <div class="menu-section">
                        <button class="menu-option" id="historyBtn">
                            <span>🕒</span> 历史记录
                        </button>
                        <div id="historySection" class="history-list" style="display: none;">
                            <h4>历史记录</h4>
                            <div id="historyList"></div>
                        </div>
                    </div>

                    <!-- Favorites Section -->
                    <div class="menu-section">
                        <button class="menu-option" id="favoritesBtn">
                            <span>❤️</span> 我的收藏
                        </button>
                        <div id="favoritesSection" class="favorites-list" style="display: none;">
                            <h4>我的收藏</h4>
                            <div id="favoritesList"></div>
                        </div>
                    </div>

                    <!-- Dark Mode Toggle -->
                    <div class="menu-section">
                        <button class="menu-option" id="darkModeToggle">
                            <span>🌙</span> 切换模式
                        </button>
                    </div>

                    <!-- About Section -->
                    <div class="menu-section">
                        <button class="menu-option" id="aboutBtn">
                            <span>ℹ️</span> 关于
                        </button>
                        <div id="aboutSection" class="about-section"
                            style="display: none; padding: 20px; color: var(--text-primary);">
                            <h4>关于本站</h4>
                            <p style="margin-top: 10px; line-height: 1.6;">
                                本站致力于弘扬中华传统文化，为您随机展示唐诗宋词的经典之作。
                            </p>
                            <p style="margin-top: 10px; line-height: 1.6;">
                                我们提供 AI 深度赏析功能，助您更好地理解诗词意境。
                            </p>
                            <p style="margin-top: 20px; font-size: 0.9rem; color: var(--text-tertiary);">
                                Version 1.2.0<br>
                                Powered by yuangs
                            </p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <script>
            // Store all poems and ci globally after first fetch
            let allPoems = null;
            let allCi = null;
            let allCombined = null; // Combined poems and ci
            let filteredPoems = null; // Store currently filtered poems

            // Image cache to store latest 20 images
            let imageCache = [];
            const MAX_CACHE_SIZE = 20;

            // Function to add image to cache
            function addToImageCache(imgUrl) {
                // Check if image is already in cache
                const existingIndex = imageCache.indexOf(imgUrl);
                if (existingIndex !== -1) {
                    // Move to front if already in cache
                    imageCache.splice(existingIndex, 1);
                } else if (imageCache.length >= MAX_CACHE_SIZE) {
                    // Remove oldest item if cache is full
                    imageCache.pop();
                }
                // Add to front of cache
                imageCache.unshift(imgUrl);
            }

            // Function to get a random cached image
            function getRandomCachedImage() {
                if (imageCache.length === 0) {
                    return null;
                }
                // Return a random image from the cache
                return imageCache[Math.floor(Math.random() * imageCache.length)];
            }

            // Define color palettes with enhanced color schemes
            const colorPalettes = [
                // First color group - based on #00695B teal green
                ['#00695B', '#2F9C8D', '#148374', '#005045', '#00362F', '#006927', '#004269', '#5B0069', '#695B00', '#69000E', '#260069', '#426900', '#692700', '#690043', '#88485e', '#316742', '#006771', '#635587', '#7c5233', '#405e8d', '#685b2a', '#7c4c75', '#874b46'],
                // Second color group - based on #88485E purple pink
                ['#88485E', '#BB96A2', '#A26E80', '#6F2A41', '#55142A', '#88487E', '#885248', '#5E8848', '#485E88', '#7E8848', '#488872', '#524888', '#488852', '#487E88', '#7c4c76', '#316743', '#006771', '#4f6330', '#0d6586', '#685b2a', '#02695b', '#415e8d', '#316743', '#006771'],
                // Third color group - based on #AF52DE purple blue
                ['#AF52DE', '#CC9AE5', '#D081F7', '#912BC5', '#760CAB', '#6952DE', '#DE52C7', '#DEAF52', '#52DEAF', '#DE6952', '#81DE52', '#52C7DE', '#C7DE52', '#52DE69', '#3f75ff', '#e121a2', '#a57000', '#008b89', '#d8481d', '#009001', '#0088a4', '#778200', '#008d66'],
                // Fourth color group - based on #657786 blue gray
                ['#657786', '#867465', '#658684', '#656686', '#866577', '#778665', '#846586', '#678665', '#94A8B9', '#9098A0', '#42596D', '#263E53', '#877466', '#777561', '#876f69'],
                // Additional LCH color groups
                ['#8fe4d2', '#65b9a9', '#3b9081', '#00695B', '#88485e', '#316742', '#006771', '#635587', '#7c5233', '#405e8d', '#685b2a', '#7c4c75', '#874b46'],
                ['#ffc4d5', '#dd95ac', '#b26e84', '#88485E', '#02695b', '#7c4c76', '#316743', '#4f6330', '#0d6586', '#685b2a', '#02695b', '#415e8d', '#316743', '#006771'],
                ['#f2d2ff', '#e3a4ff', '#d174ff', '#AF52DE', '#009001', '#778200', '#008d66', '#a57000', '#008b89', '#d8481d', '#009001', '#0088a4', '#778200', '#008d66'],
                ['#cadeee', '#a7baca', '#8598a8', '#657786', '#817263', '#5e7980', '#707487', '#886e72', '#6d7865', '#846e7c', '#817263', '#637a6d', '#876f69', '#777561']
            ];

            // Function to get a random color from the defined palettes
            function getRandomColor() {
                // Select a random palette
                const palette = colorPalettes[Math.floor(Math.random() * colorPalettes.length)];
                // Select a random color from that palette
                return palette[Math.floor(Math.random() * palette.length)];
            }

            // Function to fetch and cache Tang poems
            async function fetchAndCachePoems() {
                if (allPoems !== null) {
                    return allPoems;
                }

                const CACHE_KEY = 'tang_poems_cache_v2'; // Updated cache key to force refresh
                const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

                // Check if we have cached data and it's still valid
                const cachedData = localStorage.getItem(CACHE_KEY);
                if (cachedData) {
                    const { data, timestamp } = JSON.parse(cachedData);
                    const now = Date.now();

                    if (now - timestamp < CACHE_DURATION) {
                        // Cache is still valid - store in memory for subsequent requests
                        allPoems = data;
                        console.log("Using cached Tang poem data");
                        return allPoems;
                    }
                }

                // Fetch new data from the XML file
                try {
                    console.log("Fetching fresh Tang poem data from API...");
                    const response = await fetch('https://wealth.want.biz/pages/poem.xml');
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");

                    // Extract poem data from XML
                    const poemNodes = xmlDoc.querySelectorAll('node');
                    const poems = [];

                    poemNodes.forEach(node => {
                        const title = node.querySelector('title')?.textContent || '';
                        const auth = node.querySelector('auth')?.textContent || '';
                        const type = node.querySelector('type')?.textContent || '';
                        const content = node.querySelector('content')?.textContent || '';
                        const desc = node.querySelector('desc')?.textContent || '';

                        // Create a search link for analysis if no description is available
                        const searchQuery = encodeURIComponent(`${auth || ''} ${title || ''}`);
                        const searchLink = `https://chat.baidu.com/search?word=${searchQuery}&setype=csaitab`;

                        let finalDesc = desc;
                        if (!desc || desc.trim() === '') {
                            // If no description exists, create one with the AI search link
                            finalDesc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">🔍 点击搜索诗词赏析</a></div>`;
                        } else {
                            // If description exists, prepend the AI search link above the description
                            finalDesc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">🔍 点击搜索诗词赏析</a></div><br><br>${desc}`;
                        }

                        poems.push({
                            title: title,
                            auth: auth,
                            type: type,
                            content: content,
                            desc: finalDesc,
                            source: 'poem' // Mark as poem
                        });
                    });

                    // Cache the fetched data
                    const cacheData = {
                        data: poems,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));

                    // Store in memory for subsequent requests
                    allPoems = poems;

                    console.log(`Fetched and cached ${poems.length} Tang poems`);
                    return allPoems;
                } catch (error) {
                    console.error('Error fetching Tang poem data:', error);

                    // If fetching failed, try to return cached data even if it's expired
                    if (cachedData) {
                        const { data } = JSON.parse(cachedData);
                        console.warn("Using expired cached Tang poem data due to fetch error");
                        // Store expired data in memory temporarily
                        allPoems = data;
                        return allPoems;
                    }

                    // If no cached data is available, return an empty array
                    allPoems = [];
                    return allPoems;
                }
            }

            // Function to fetch and cache Song ci
            async function fetchAndCacheCi() {
                if (allCi !== null) {
                    return allCi;
                }

                const CACHE_KEY = 'song_ci_cache_v2'; // Updated cache key to force refresh
                const CACHE_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds

                // Check if we have cached data and it's still valid
                const cachedData = localStorage.getItem(CACHE_KEY);
                if (cachedData) {
                    const { data, timestamp } = JSON.parse(cachedData);
                    const now = Date.now();

                    if (now - timestamp < CACHE_DURATION) {
                        // Cache is still valid - store in memory for subsequent requests
                        allCi = data;
                        console.log("Using cached Song ci data");
                        return allCi;
                    }
                }

                // Fetch new data from the JSON file
                try {
                    console.log("Fetching fresh Song ci data from API...");
                    const response = await fetch('https://wealth.want.biz/pages/songci.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }

                    const ciData = await response.json();

                    // Process ci data to match poem structure
                    const processedCi = ciData.map(ci => {
                        // Create a search link for analysis if no description is available
                        const searchQuery = encodeURIComponent(`${ci.author || ''} ${ci.rhythmic || ''}`);
                        const searchLink = `https://chat.baidu.com/search?word=${searchQuery}&setype=csaitab`;

                        let desc = '';
                        if (ci.tags && ci.tags.length > 0) {
                            // Place the search link above the tags
                            desc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">🔍 点击搜索诗词赏析</a></div><br><br>标签: ${ci.tags.join(', ')}`;
                        } else {
                            desc = `<div style="margin-top: 10px; padding: 10px; background-color: #e9ecef; border-radius: 5px; text-align: center;"><a href="${searchLink}" target="_blank" style="color: #007bff; text-decoration: none; font-weight: bold;">🔍 点击搜索诗词赏析</a></div>`;
                        }

                        return {
                            title: ci.rhythmic || '未知词牌', // Use rhythmic as title
                            auth: ci.author || '未知作者',
                            type: '宋词', // Mark as Song ci
                            content: ci.paragraphs ? ci.paragraphs.join('<br>') : '无内容',
                            desc: desc,
                            source: 'ci' // Mark as ci
                        };
                    });

                    // Cache the fetched data
                    const cacheData = {
                        data: processedCi,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));

                    // Store in memory for subsequent requests
                    allCi = processedCi;

                    console.log(`Fetched and cached ${processedCi.length} Song ci`);
                    return allCi;
                } catch (error) {
                    console.error('Error fetching Song ci data:', error);

                    // If fetching failed, try to return cached data even if it's expired
                    if (cachedData) {
                        const { data } = JSON.parse(cachedData);
                        console.warn("Using expired cached Song ci data due to fetch error");
                        // Store expired data in memory temporarily
                        allCi = data;
                        return allCi;
                    }

                    // If no cached data is available, return an empty array
                    allCi = [];
                    return allCi;
                }
            }

            // Function to fetch and combine both poems and ci
            async function fetchAndCombineAll() {
                if (allCombined !== null) {
                    return allCombined;
                }

                // Fetch both poems and ci in parallel
                const [poems, ci] = await Promise.all([
                    fetchAndCachePoems(),
                    fetchAndCacheCi()
                ]);

                // Combine both arrays
                allCombined = [...poems, ...ci];
                console.log(`Combined ${poems.length} Tang poems and ${ci.length} Song ci, total ${allCombined.length} entries`);

                return allCombined;
            }

            // Function to get a random poem from cached data
            async function getRandomPoem() {
                const poems = await fetchAndCachePoems();
                if (poems.length === 0) {
                    console.warn("No poems available");
                    return null;
                }
                const randomIndex = Math.floor(Math.random() * poems.length);
                return poems[randomIndex];
            }

            // Function to get a random image URL from various sources with fallbacks
            function getRandomImageUrl(fallbackNum = 1) {
                const timestamp = Date.now();
                switch (fallbackNum) {
                    case 1:
                        // Primary source: picsum with random seed
                        return `https://picsum.photos/seed/${timestamp}/400/300`;
                    case 2:
                        // Fallback 1: picsum without seed (random image)
                        return `https://picsum.photos/400/300?random=${timestamp}`;
                    case 3:
                        // Fallback 2: Unsplash source with random seed
                        return `https://source.unsplash.com/400x300/?nature,random&ts=${timestamp}`;
                    case 4:
                        // Fallback 3: Pexel source with random seed
                        return `https://images.pexels.com/photos/3225517/pexels-photo-3225517.jpeg?auto=compress&cs=tinysrgb&dpr=1&w=400&h=300&ts=${timestamp}`;
                    case 5:
                        // Local fallback: base64 encoded placeholder image
                        return `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAwIiBoZWlnaHQ9IjMwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjY2NjIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzY2NiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkPDpXNpIFBvaWN0cnkgUGxhY2Vob2xkZXI8L3RleHQ+PC9zdmc+`;
                    default:
                        // Last resort: simple placeholder if all other sources fail
                        return `https://placehold.co/400x300/cccccc/666666?text=诗词配图`;
                }
            }

            // Function to get a random poem from filtered data
            async function getRandomPoem() {
                // Use filtered poems if available, otherwise use combined poems and ci
                if (filteredPoems && filteredPoems.length > 0) {
                    const randomIndex = Math.floor(Math.random() * filteredPoems.length);
                    return filteredPoems[randomIndex];
                } else {
                    // Use combined poems and ci
                    const allItems = await fetchAndCombineAll();
                    if (allItems.length === 0) {
                        console.warn("No poems or ci available");
                        return null;
                    }
                    const randomIndex = Math.floor(Math.random() * allItems.length);
                    return allItems[randomIndex];
                }
            }

            // Function to determine if poem is suitable for vertical layout
            function isVerticalLayoutPoem(poem) {
                const content = poem.content.replace(/\s+/g, ''); // Remove whitespace
                const sentences = content.split(/[。！？!?]/).filter(s => s.trim() !== '');

                // Check if it's a 5-character or 7-character regulated verse
                const firstLineLen = sentences[0] ? sentences[0].replace(/[，,]/g, '').length : 0;
                const isRegular = (firstLineLen === 5 || firstLineLen === 7) &&
                    sentences.every(s => {
                        const cleanLen = s.replace(/[，,]/g, '').length;
                        return cleanLen === firstLineLen * 2 || cleanLen === firstLineLen;
                    });

                // Suitable for vertical layout if it's a regular 5/7 character poem and not too long
                return isRegular && content.length <= 64;
            }

            // Function to determine if poem is a 7-character regulated verse (七言诗)
            function isRegularPoem(poem) {
                const content = poem.content.replace(/\s+/g, ''); // Remove whitespace
                const sentences = content.split(/[。！？!?]/).filter(s => s.trim() !== '');

                // 获取第一句长度（通常是 5 或 7）
                const firstLineLen = sentences[0] ? sentences[0].replace(/[，,]/g, '').length : 0;

                // 允许 5言 或 7言，且每句长度要一致
                const isRegular = (firstLineLen === 5 || firstLineLen === 7) &&
                    sentences.every(s => {
                        const cleanLen = s.replace(/[，,]/g, '').length;
                        // 一句可能是5/7字，或者是一联10/14字
                        return cleanLen === firstLineLen * 2 || cleanLen === firstLineLen;
                    });

                return isRegular;
            }

            // 【修改 2】 通用的成对格式化函数 (原 formatSevenCharacterPoem)
            function formatCoupletPoem(poem) {
                // 关键点：filter(line => line !== '') 会自动把造成大间距的空行过滤掉！
                const lines = poem.content.split('\n').map(line => line.trim()).filter(line => line !== '');

                const formattedLines = [];
                for (let i = 0; i < lines.length; i += 2) {
                    if (i + 1 < lines.length) {
                        // 成对输出
                        formattedLines.push(`<div class="couplet-row">${lines[i]}<br>${lines[i + 1]}</div>`);
                    } else {
                        // 落单的最后一句
                        formattedLines.push(`<div class="couplet-row">${lines[i]}</div>`);
                    }
                }
                return formattedLines.join('');
            }

            // Function to insert line breaks at commas and periods for better layout
            function insertLineBreaksAtPunctuation(content) {
                // 先规范化换行符，过滤空行，再处理标点符号
                // 首先，将内容按换行符分割并过滤空行
                const lines = content.split('\n')
                    .map(line => line.trim())
                    .filter(line => line !== '');

                // 重新组合内容，但确保格式整洁
                let processed = lines.join('\n');

                // 然后添加标点符号后的换行
                processed = processed
                    .replace(/([，,])(?!\n)/g, '$1\n') // 在逗号后添加换行（如果没有已经存在的换行）
                    .replace(/([？?])(?!\n)/g, '$1\n'); // 在句号后添加换行（如果没有已经存在的换行）

                // 最后，将所有换行符统一转换为 <br> 标签
                processed = processed.replace(/\n/g, '<br>');

                // 处理可能出现的多个连续 <br> 标签
                processed = processed
                    .replace(/(<br>\s*){3,}/g, '<br><div class="poem-paragraph-break"></div><br>') // 3+ brs to br + paragraph break + br
                    .replace(/(<br>\s*){2}/g, '<br>'); // 2 brs to single br to avoid double spacing

                return processed;
            }

            // Function to load a random poem and image
            async function loadRandomPoem() {
                // Show loading
                document.getElementById('loading').style.display = 'block';
                document.getElementById('poemTextContent').style.display = 'none';
                document.getElementById('poemDescContent').style.display = 'none';

                // Get random poem
                const poem = await getRandomPoem();

                if (!poem) {
                    document.getElementById('loading').innerHTML = '诗词加载失败，请稍后再试';
                    return;
                }

                // 1. 设置基本信息
                document.getElementById('poemTitle').textContent = poem.title;
                document.getElementById('poemAuthor').textContent = poem.auth;

                // 优化：尝试从 type 中提取朝代，如果没有则默认显示诗词类型
                const dynastyElement = document.getElementById('poemDynasty');
                const typeSealElement = document.getElementById('mainTypeSeal');
                if (poem.source === 'ci') {
                    dynastyElement.textContent = '宋';
                    dynastyElement.style.backgroundColor = '#88485E'; // 宋词用紫红色
                    typeSealElement.textContent = '词'; // 词类型
                } else {
                    dynastyElement.textContent = '唐'; // 你的数据源主要是唐诗
                    dynastyElement.style.backgroundColor = '#FE2C55'; // 唐诗用小红书红
                    typeSealElement.textContent = '诗'; // 诗类型
                }

                // 2. 智能排版逻辑 (复用 analyzePoemLayout)
                // 注意：这里我们稍微改一下，如果是 analyzePoemLayout 返回 vertical，我们就用竖排
                // 但对于主展示区，我们可以稍微放宽竖排的条件（比如只要是律诗绝句都竖排，不受32字限制，因为空间大）

                const content = poem.content;
                const verseElement = document.getElementById('poemVerse');

                // 清除之前的类
                verseElement.className = 'poem-verse';

                // 简单判断：不包含逗号且句子长度整齐的，或者你是用 analyzePoemLayout
                const layoutInfo = analyzePoemLayout(poem);

                if (layoutInfo.mode === 'vertical') {
                    verseElement.classList.add('vertical-mode');
                    // 竖排时，换行符保留，且标点符号可能会影响美观，可以考虑用空格替换标点，或者保留
                    // 这里直接保留原文排版 but add line breaks at punctuation
                    verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                } else {
                    verseElement.classList.add('horizontal-mode');
                    // 横排居中，适合长短句
                    // 【修改 3】 只要是格律诗（五言或七言），且行数足够，就使用成对布局
                    // 这样就能利用 .couplet-row 的 CSS 来控制间距，消灭大空行
                    if (isRegularPoem(poem) && poem.content.split('\n').length >= 2) {
                        verseElement.innerHTML = formatCoupletPoem(poem);
                    } else {
                        // 其他长短句（词）继续使用默认排版
                        verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                    }
                }

                // 3. 赏析内容处理 (优先显示缓存的 AI 赏析)
                const cachedInterpretation = getInterpretationFromCache(poem.title, poem.auth);
                const descElement = document.getElementById('poemDesc');

                if (cachedInterpretation) {
                    // 如果有缓存，显示 AI 赏析
                    const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">✨ AI 深度赏析 <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="重新生成解读">🔄 重新生成</span></div>';
                    descElement.innerHTML = poem.desc + separator + aiBadge + markdownToHtml(cachedInterpretation);
                } else {
                    // 否则显示默认注释
                    descElement.innerHTML = poem.desc;
                }

                // Update image with multiple fallbacks and timeout
                const img = document.getElementById('poemImage');
                let currentFallback = 1;
                const maxFallbacks = 6; // Primary + 4 fallbacks + 1 local fallback
                let timeoutId;

                // Function to try loading next fallback image
                function tryNextFallback() {
                    if (currentFallback < maxFallbacks) {
                        currentFallback++;
                        // Clear previous timeout
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        // Set a new timeout for this fallback
                        timeoutId = setTimeout(() => {
                            console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                            if (currentFallback < maxFallbacks) {
                                tryNextFallback();
                            } else {
                                // All fallbacks exhausted, show content without image and indicate failure
                                handleImageFailure();
                            }
                        }, 15000); // 5 seconds timeout for each fallback

                        img.src = getRandomImageUrl(currentFallback);
                    } else {
                        // All fallbacks exhausted, show content without image and indicate failure
                        handleImageFailure();
                    }
                }

                // Function to handle the case when all image sources fail
                function handleImageFailure() {
                    console.warn("All image loading attempts failed, displaying content without image");

                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';

                    // Show poem content
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';

                    // Apply fade-in animation and add seal
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');


                    // Optionally, add a visual indicator that image loading failed
                    const img = document.getElementById('poemImage');
                    img.onerror = null; // Remove error handler to prevent loops
                    img.onload = null;  // Remove load handler
                }

                // Set up image event handlers
                img.onload = function () {
                    // Add loaded image to cache
                    addToImageCache(img.src);
                    // Clear timeout on successful load
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    // Show content once image is loaded
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');

                };

                img.onerror = function () {
                    console.log(`Image loading error for fallback ${currentFallback}, trying next...`);
                    // If we have cached images, try using one as a fallback
                    const cachedImage = getRandomCachedImage();
                    if (cachedImage && currentFallback >= maxFallbacks - 1) { // Only try cached on last attempt
                        console.log(`Using cached image as final fallback: ${cachedImage}`);
                        img.src = cachedImage;
                        return; // Don't try next fallback, try the cached image instead
                    }
                    // Try next fallback image
                    tryNextFallback();
                };

                // Set the new image source with primary URL
                img.src = getRandomImageUrl(currentFallback);

                // Set timeout for primary image
                timeoutId = setTimeout(() => {
                    console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                    if (currentFallback < maxFallbacks) {
                        tryNextFallback();
                    } else {
                        // Try cached image if available before showing content without image
                        const cachedImage = getRandomCachedImage();
                        if (cachedImage) {
                            console.log(`Using cached image as final fallback due to timeout: ${cachedImage}`);
                            img.src = cachedImage;
                        } else {
                            // All fallbacks exhausted, show content without image and indicate failure
                            handleImageFailure();
                        }
                    }
                }, 5000); // 5 seconds timeout for primary image

                // Show content immediately if this is the first load (image might take time)
                setTimeout(() => {
                    if (document.getElementById('loading').style.display === 'block') {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('poemTextContent').style.display = 'block';
                        document.getElementById('poemDescContent').style.display = 'block';
                        document.getElementById('poemTextContent').classList.add('fade-in');
                        document.getElementById('poemDescContent').classList.add('fade-in');

                    }
                }, 300); // Show content after 300ms if image hasn't loaded yet
            }

            // Function to populate author filter dropdown
            async function populateAuthorFilter() {
                const authorsWithCount = await getAllAuthors();
                const authorFilter = document.getElementById('authorFilter');

                // Clear existing options except the first one
                authorFilter.innerHTML = '<option value="">全部作者</option>';

                // Add authors with poem counts to the dropdown
                authorsWithCount.forEach(authorObj => {
                    const option = document.createElement('option');
                    option.value = authorObj.name;
                    option.textContent = `${authorObj.name} (${authorObj.count})`;
                    authorFilter.appendChild(option);
                });
            }

            // Function to get all authors sorted by poem count
            async function getAllAuthors() {
                // Use combined poems and ci for author list
                const allItems = await fetchAndCombineAll();

                // Count items per author
                const authorCount = {};
                allItems.forEach(item => {
                    if (authorCount[item.auth]) {
                        authorCount[item.auth]++;
                    } else {
                        authorCount[item.auth] = 1;
                    }
                });

                // Create array of {name, count} objects and sort by count (descending)
                const authorsWithCount = Object.entries(authorCount).map(([name, count]) => ({
                    name: name,
                    count: count
                }));

                // Sort by poem count (descending), then by name (ascending) for ties
                authorsWithCount.sort((a, b) => {
                    if (b.count !== a.count) {
                        return b.count - a.count; // Sort by count descending
                    }
                    return a.name.localeCompare(b.name); // Sort by name ascending for ties
                });

                return authorsWithCount;
            }

            // Function to filter poems by author
            async function filterByAuthor() {
                const selectedAuthor = document.getElementById('authorFilter').value;
                const allItems = await fetchAndCombineAll();

                if (selectedAuthor === '') {
                    filteredPoems = allItems;
                } else {
                    // Extract just the author name (before the parentheses)
                    const authorName = selectedAuthor.split(' (')[0];
                    filteredPoems = allItems.filter(item => item.auth === authorName);
                }

                // Update poem list dropdown
                updatePoemListDropdown();
            }

            // Function to update poem list dropdown based on filtered poems
            function updatePoemListDropdown() {
                const poemList = document.getElementById('poemList');

                // Clear existing options except the first one
                poemList.innerHTML = '<option value="">选择作品</option>';

                if (filteredPoems && filteredPoems.length > 0) {
                    filteredPoems.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item.title;
                        option.textContent = item.title;
                        poemList.appendChild(option);
                    });
                }
            }

            // Function to select a specific poem
            async function selectPoem() {
                const selectedTitle = document.getElementById('poemList').value;

                if (selectedTitle) {
                    // Find the selected poem in the filtered poems
                    const poem = filteredPoems.find(p => p.title === selectedTitle);
                    if (poem) {
                        displayPoem(poem);
                    }
                }
            }

            // Function to display a specific poem
            function displayPoem(poem) {
                // Show loading
                document.getElementById('loading').style.display = 'block';
                document.getElementById('poemTextContent').style.display = 'none';
                document.getElementById('poemDescContent').style.display = 'none';

                // 1. 设置基本信息
                document.getElementById('poemTitle').textContent = poem.title;
                document.getElementById('poemAuthor').textContent = poem.auth;

                // 优化：尝试从 type 中提取朝代，如果没有则默认显示诗词类型
                const dynastyElement = document.getElementById('poemDynasty');
                const typeSealElement = document.getElementById('mainTypeSeal');
                if (poem.source === 'ci') {
                    dynastyElement.textContent = '宋';
                    dynastyElement.style.backgroundColor = '#88485E'; // 宋词用紫红色
                    typeSealElement.textContent = '词'; // 词类型
                } else {
                    dynastyElement.textContent = '唐'; // 你的数据源主要是唐诗
                    dynastyElement.style.backgroundColor = '#FE2C55'; // 唐诗用小红书红
                    typeSealElement.textContent = '诗'; // 诗类型
                }

                // 2. 智能排版逻辑 (复用 analyzePoemLayout)
                // 注意：这里我们稍微改一下，如果是 analyzePoemLayout 返回 vertical，我们就用竖排
                // 但对于主展示区，我们可以稍微放宽竖排的条件（比如只要是律诗绝句都竖排，不受32字限制，因为空间大）

                const content = poem.content;
                const verseElement = document.getElementById('poemVerse');

                // 清除之前的类
                verseElement.className = 'poem-verse';

                // 简单判断：不包含逗号且句子长度整齐的，或者你是用 analyzePoemLayout
                const layoutInfo = analyzePoemLayout(poem);

                if (layoutInfo.mode === 'vertical') {
                    verseElement.classList.add('vertical-mode');
                    // 竖排时，换行符保留，且标点符号可能会影响美观，可以考虑用空格替换标点，或者保留
                    // 这里直接保留原文排版 but add line breaks at punctuation
                    verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                } else {
                    verseElement.classList.add('horizontal-mode');
                    // 横排居中，适合长短句
                    // 【修改 3】 只要是格律诗（五言或七言），且行数足够，就使用成对布局
                    // 这样就能利用 .couplet-row 的 CSS 来控制间距，消灭大空行
                    if (isRegularPoem(poem) && poem.content.split('\n').length >= 2) {
                        verseElement.innerHTML = formatCoupletPoem(poem);
                    } else {
                        // 其他长短句（词）继续使用默认排版
                        verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                    }
                }

                // Debug: Log the desc content to console
                console.log("Poem desc content:", poem.desc);
                console.log("Poem source:", poem.source);

                // 3. 赏析内容处理 (优先显示缓存的 AI 赏析)
                const cachedInterpretation = getInterpretationFromCache(poem.title, poem.auth);
                const descElement = document.getElementById('poemDesc');

                if (cachedInterpretation) {
                    // 如果有缓存，显示 AI 赏析
                    const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">✨ AI 深度赏析 <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="重新生成解读">🔄 重新生成</span></div>';
                    descElement.innerHTML = poem.desc + separator + aiBadge + markdownToHtml(cachedInterpretation);
                } else {
                    // 否则显示默认注释
                    descElement.innerHTML = poem.desc;
                }

                // Update image with multiple fallbacks and timeout
                const img = document.getElementById('poemImage');
                let currentFallback = 1;
                const maxFallbacks = 6; // Primary + 4 fallbacks + 1 local fallback
                let timeoutId;

                // Function to try loading next fallback image
                function tryNextFallback() {
                    if (currentFallback < maxFallbacks) {
                        currentFallback++;
                        // Clear previous timeout
                        if (timeoutId) {
                            clearTimeout(timeoutId);
                        }
                        // Set a new timeout for this fallback
                        timeoutId = setTimeout(() => {
                            console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                            if (currentFallback < maxFallbacks) {
                                tryNextFallback();
                            } else {
                                // All fallbacks exhausted, show content without image and indicate failure
                                handleImageFailure();
                            }
                        }, 5000); // 5 seconds timeout for each fallback

                        img.src = getRandomImageUrl(currentFallback);
                    } else {
                        // All fallbacks exhausted, show content without image and indicate failure
                        handleImageFailure();
                    }
                }

                // Function to handle the case when all image sources fail
                function handleImageFailure() {
                    console.warn("All image loading attempts failed, displaying content without image");

                    // Hide loading indicator
                    document.getElementById('loading').style.display = 'none';

                    // Show poem content
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';

                    // Apply fade-in animation and add seal
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');


                    // Optionally, add a visual indicator that image loading failed
                    const img = document.getElementById('poemImage');
                    img.onerror = null; // Remove error handler to prevent loops
                    img.onload = null;  // Remove load handler
                }

                // Set up image event handlers
                img.onload = function () {
                    // Add loaded image to cache
                    addToImageCache(img.src);
                    // Clear timeout on successful load
                    if (timeoutId) {
                        clearTimeout(timeoutId);
                    }
                    // Show content once image is loaded
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('poemTextContent').style.display = 'block';
                    document.getElementById('poemDescContent').style.display = 'block';
                    document.getElementById('poemTextContent').classList.add('fade-in');
                    document.getElementById('poemDescContent').classList.add('fade-in');

                };

                img.onerror = function () {
                    console.log(`Image loading error for fallback ${currentFallback}, trying next...`);
                    // If we have cached images, try using one as a fallback
                    const cachedImage = getRandomCachedImage();
                    if (cachedImage && currentFallback >= maxFallbacks - 1) { // Only try cached on last attempt
                        console.log(`Using cached image as final fallback: ${cachedImage}`);
                        img.src = cachedImage;
                        return; // Don't try next fallback, try the cached image instead
                    }
                    // Try next fallback image
                    tryNextFallback();
                };

                // Set the new image source with primary URL
                img.src = getRandomImageUrl(currentFallback);

                // Set timeout for primary image
                timeoutId = setTimeout(() => {
                    console.log(`Image loading timeout for fallback ${currentFallback}, trying next...`);
                    if (currentFallback < maxFallbacks) {
                        tryNextFallback();
                    } else {
                        // Try cached image if available before showing content without image
                        const cachedImage = getRandomCachedImage();
                        if (cachedImage) {
                            console.log(`Using cached image as final fallback due to timeout: ${cachedImage}`);
                            img.src = cachedImage;
                        } else {
                            // All fallbacks exhausted, show content without image and indicate failure
                            handleImageFailure();
                        }
                    }
                }, 5000); // 5 seconds timeout for primary image

                // Show content immediately if this is the first load (image might take time)
                setTimeout(() => {
                    if (document.getElementById('loading').style.display === 'block') {
                        document.getElementById('loading').style.display = 'none';
                        document.getElementById('poemTextContent').style.display = 'block';
                        document.getElementById('poemDescContent').style.display = 'block';
                        document.getElementById('poemTextContent').classList.add('fade-in');
                        document.getElementById('poemDescContent').classList.add('fade-in');

                    }
                }, 300); // Show content after 300ms if image hasn't loaded yet
            }

            // Function to clear filters
            function clearFilter() {
                document.getElementById('authorFilter').value = '';
                document.getElementById('poemList').value = '';
                filteredPoems = allCombined; // Reset to all combined data (poems and ci)
                updatePoemListDropdown();
            }

            // Function to perform search
            async function performSearch() {
                const searchTerm = document.getElementById('searchInput').value.trim();
                if (!searchTerm) {
                    alert('请输入搜索关键词');
                    return;
                }

                const allItems = await fetchAndCombineAll();
                const searchResults = [];

                // Search in title and content
                allItems.forEach(item => {
                    const title = item.title.toLowerCase();
                    const content = item.content.toLowerCase();
                    const auth = item.auth.toLowerCase();
                    const desc = item.desc.toLowerCase();

                    if (title.includes(searchTerm.toLowerCase()) ||
                        content.includes(searchTerm.toLowerCase()) ||
                        auth.includes(searchTerm.toLowerCase()) ||
                        desc.includes(searchTerm.toLowerCase())) {
                        // Create a preview of where the match occurred
                        let preview = '';
                        if (content.includes(searchTerm.toLowerCase())) {
                            const matchIndex = content.indexOf(searchTerm.toLowerCase());
                            const start = Math.max(0, matchIndex - 20);
                            const end = Math.min(content.length, matchIndex + searchTerm.length + 20);
                            preview = '...' + content.substring(start, end) + '...';
                        } else {
                            preview = content.substring(0, 60) + '...';
                        }

                        searchResults.push({
                            ...item,
                            preview: preview
                        });
                    }
                });

                displaySearchResults(searchResults, searchTerm);
            }

            // Function to handle Enter key in search input
            function handleSearchKeyPress(event) {
                if (event.key === 'Enter') {
                    performSearch();
                }
            }

            // Function to display search results
            function displaySearchResults(results, searchTerm) {
                const resultsContainer = document.getElementById('searchResults');
                const resultsList = document.getElementById('searchResultsList');

                if (results.length === 0) {
                    resultsList.innerHTML = '<li>未找到匹配的诗歌</li>';
                } else {
                    resultsList.innerHTML = '';

                    results.forEach((poem, index) => {
                        const li = document.createElement('li');
                        li.innerHTML = `
            <div class="result-title">${highlightText(poem.title, searchTerm)}</div>
            <div class="result-author">作者: ${highlightText(poem.auth, searchTerm)}</div>
            <div class="result-preview">${highlightText(poem.preview, searchTerm)}</div>
          `;
                        li.onclick = () => selectSearchResult(poem);
                        resultsList.appendChild(li);
                    });
                }

                resultsContainer.style.display = 'block';
            }

            // Function to highlight search term in text
            function highlightText(text, searchTerm) {
                if (!searchTerm) return text;

                const regex = new RegExp(`(${searchTerm})`, 'gi');
                return text.replace(regex, '<mark>$1</mark>');
            }

            // Function to select a search result
            function selectSearchResult(poem) {
                displayPoem(poem);

                // Close search results and search section
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('searchSection').style.display = 'none';
                document.getElementById('searchInput').value = '';
            }

            // Function to clear search
            function clearSearch() {
                document.getElementById('searchInput').value = '';
                document.getElementById('searchResults').style.display = 'none';
            }

            // Function to toggle search section
            function toggleSearch() {
                const searchSection = document.getElementById('searchSection');
                const isCurrentlyVisible = searchSection.style.display !== 'none';

                if (isCurrentlyVisible) {
                    hideSearch();
                } else {
                    searchSection.style.display = 'flex';
                    // Focus on the search input when showing
                    document.getElementById('searchInput').focus();
                }
            }

            // Function to hide search section
            function hideSearch() {
                document.getElementById('searchSection').style.display = 'none';
                document.getElementById('searchResults').style.display = 'none';
                document.getElementById('searchInput').value = '';
            }

            // Load a random poem when the page loads
            window.onload = async function () {
                // Preload both poems and ci data
                await fetchAndCombineAll();
                // Initialize filteredPoems to all combined data
                filteredPoems = allCombined;
                await loadRandomPoem();
                await populateAuthorFilter(); // Populate the author filter after poems are loaded

                console.log("Page loaded. Combined data count:", allCombined ? allCombined.length : 0);
                console.log("Tang poem count:", allPoems ? allPoems.length : 0);
                console.log("Song ci count:", allCi ? allCi.length : 0);
            };

            // Add keyboard support (press spacebar for next poem)
            document.addEventListener('keydown', function (event) {
                if (event.code === 'Space') {
                    event.preventDefault();
                    loadRandomPoem();
                }
            });

            // Function to open Baidu search for current poem
            function openCurrentPoemSearch() {
                const titleElement = document.getElementById('poemTitle');
                const authorElement = document.getElementById('poemAuthor');

                let title = '';
                let author = '';

                if (titleElement) {
                    title = titleElement.textContent || titleElement.innerText;
                }

                if (authorElement) {
                    author = authorElement.textContent || authorElement.innerText;
                }

                // Create search query
                const searchQuery = encodeURIComponent(`${author} ${title}`);
                const searchUrl = `https://chat.baidu.com/search?word=${searchQuery}&setype=csaitab`;

                // Open search in a new tab/window
                window.open(searchUrl, '_blank');
            }

            document.addEventListener('DOMContentLoaded', function () {
                // Add event listener for inline search button
                const inlineSearchBtn = document.getElementById('inlineSearchBtn');
                if (inlineSearchBtn) {
                    inlineSearchBtn.addEventListener('click', openCurrentPoemSearch);
                }

                const darkModeToggle = document.getElementById('darkModeToggle');
                const body = document.body;

                // Check for saved theme preference or respect system preference
                const currentTheme = localStorage.getItem('theme');
                if (currentTheme === 'dark') {
                    body.classList.add('dark-mode');
                    darkModeToggle.innerHTML = '<span>☀️</span> 切换模式'; // Sun icon when in dark mode
                } else if (currentTheme === 'light') {
                    body.classList.remove('dark-mode');
                    darkModeToggle.innerHTML = '<span>🌙</span> 切换模式'; // Moon icon when in light mode
                } else {
                    // Check system preference
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        body.classList.add('dark-mode');
                        darkModeToggle.innerHTML = '<span>☀️</span> 切换模式';
                    } else {
                        body.classList.remove('dark-mode');
                        darkModeToggle.innerHTML = '<span>🌙</span> 切换模式';
                    }
                }

                darkModeToggle.addEventListener('click', function () {
                    body.classList.toggle('dark-mode');

                    if (body.classList.contains('dark-mode')) {
                        darkModeToggle.innerHTML = '<span>☀️</span> 切换模式';
                        localStorage.setItem('theme', 'dark');
                    } else {
                        darkModeToggle.innerHTML = '<span>🌙</span> 切换模式';
                        localStorage.setItem('theme', 'light');
                    }
                });

                // Menu functionality
                const menuToggle = document.getElementById('menuToggle');
                const menuOverlay = document.getElementById('menuOverlay');
                const closeMenuBtn = document.getElementById('closeMenuBtn');
                const historyBtn = document.getElementById('historyBtn');
                const favoritesBtn = document.getElementById('favoritesBtn');
                const aboutBtn = document.getElementById('aboutBtn');
                const historySection = document.getElementById('historySection');
                const favoritesSection = document.getElementById('favoritesSection');
                const aboutSection = document.getElementById('aboutSection');
                const historyList = document.getElementById('historyList');
                const favoritesList = document.getElementById('favoritesList');

                // Toggle menu
                menuToggle.addEventListener('click', function () {
                    menuOverlay.classList.add('active');
                });

                // Close menu
                closeMenuBtn.addEventListener('click', function () {
                    menuOverlay.classList.remove('active');
                    // Hide sections when closing
                    historySection.style.display = 'none';
                    favoritesSection.style.display = 'none';
                    aboutSection.style.display = 'none';
                });

                // Close menu when clicking on overlay
                menuOverlay.addEventListener('click', function (e) {
                    if (e.target === menuOverlay) {
                        menuOverlay.classList.remove('active');
                        // Hide sections when closing
                        historySection.style.display = 'none';
                        favoritesSection.style.display = 'none';
                        aboutSection.style.display = 'none';
                    }
                });

                // Show history section
                historyBtn.addEventListener('click', function () {
                    favoritesSection.style.display = 'none';
                    aboutSection.style.display = 'none';
                    historySection.style.display = 'block';
                    loadHistoryList();
                });

                // Show favorites section
                favoritesBtn.addEventListener('click', function () {
                    historySection.style.display = 'none';
                    aboutSection.style.display = 'none';
                    favoritesSection.style.display = 'block';
                    loadFavoritesList();
                });

                // Show about section
                aboutBtn.addEventListener('click', function () {
                    historySection.style.display = 'none';
                    favoritesSection.style.display = 'none';
                    aboutSection.style.display = 'block';
                });

                // History functionality
                const HISTORY_KEY = 'poem_history';
                const MAX_HISTORY = 50; // Store max 50 history items

                // Add poem to history
                function addToHistory(poem) {
                    if (!poem || !poem.title || !poem.auth) return;

                    const history = getHistoryFromStorage();
                    const newEntry = {
                        title: poem.title,
                        author: poem.auth,
                        source: poem.source || 'poem'
                    };

                    // Remove any existing entry with same title and author
                    const filteredHistory = history.filter(item =>
                        !(item.title === newEntry.title && item.author === newEntry.author)
                    );

                    // Add new entry to the beginning
                    filteredHistory.unshift(newEntry);

                    // Keep only the most recent MAX_HISTORY entries
                    if (filteredHistory.length > MAX_HISTORY) {
                        filteredHistory.splice(MAX_HISTORY);
                    }

                    localStorage.setItem(HISTORY_KEY, JSON.stringify(filteredHistory));
                }

                // Get history from storage
                function getHistoryFromStorage() {
                    try {
                        const history = localStorage.getItem(HISTORY_KEY);
                        return history ? JSON.parse(history) : [];
                    } catch (e) {
                        console.error('Error reading history from localStorage:', e);
                        return [];
                    }
                }

                // Load and display history list
                function loadHistoryList() {
                    const history = getHistoryFromStorage();
                    historyList.innerHTML = '';

                    if (history.length === 0) {
                        historyList.innerHTML = '<p style="padding: 10px; text-align: center; color: var(--text-tertiary);">暂无历史记录</p>';
                        return;
                    }

                    history.forEach((item, index) => {
                        const historyItem = document.createElement('div');
                        historyItem.className = 'history-item';
                        historyItem.innerHTML = `
                            <div class="title">${item.title}</div>
                            <div class="author">${item.author}</div>
                        `;
                        historyItem.addEventListener('click', function () {
                            searchAndDisplayPoem(item.title, item.author);
                            menuOverlay.classList.remove('active');
                            historySection.style.display = 'none';
                        });
                        historyList.appendChild(historyItem);
                    });
                }

                // Favorites functionality
                const FAVORITES_KEY = 'poem_favorites';
                const MAX_FAVORITES = 100; // Store max 100 favorite items

                // Toggle favorite status
                function toggleFavorite(poem) {
                    if (!poem || !poem.title || !poem.auth) return;

                    const isFavorite = isPoemFavorite(poem);
                    const favorites = getFavoritesFromStorage();
                    const favoriteEntry = {
                        title: poem.title,
                        author: poem.auth,
                        source: poem.source || 'poem'
                    };

                    if (isFavorite) {
                        // Remove from favorites
                        const filteredFavorites = favorites.filter(item =>
                            !(item.title === favoriteEntry.title && item.author === favoriteEntry.author)
                        );
                        localStorage.setItem(FAVORITES_KEY, JSON.stringify(filteredFavorites));
                    } else {
                        // Add to favorites
                        // Remove any existing entry first to avoid duplicates
                        const filteredFavorites = favorites.filter(item =>
                            !(item.title === favoriteEntry.title && item.author === favoriteEntry.author)
                        );

                        // Add new entry to the beginning
                        filteredFavorites.unshift(favoriteEntry);

                        // Keep only MAX_FAVORITES entries
                        if (filteredFavorites.length > MAX_FAVORITES) {
                            filteredFavorites.splice(MAX_FAVORITES);
                        }

                        localStorage.setItem(FAVORITES_KEY, JSON.stringify(filteredFavorites));
                    }
                }

                // Check if a poem is in favorites
                function isPoemFavorite(poem) {
                    if (!poem || !poem.title || !poem.auth) return false;

                    const favorites = getFavoritesFromStorage();
                    return favorites.some(item =>
                        item.title === poem.title && item.author === poem.auth
                    );
                }

                // Get favorites from storage
                function getFavoritesFromStorage() {
                    try {
                        const favorites = localStorage.getItem(FAVORITES_KEY);
                        return favorites ? JSON.parse(favorites) : [];
                    } catch (e) {
                        console.error('Error reading favorites from localStorage:', e);
                        return [];
                    }
                }

                // Load and display favorites list
                function loadFavoritesList() {
                    const favorites = getFavoritesFromStorage();
                    favoritesList.innerHTML = '';

                    if (favorites.length === 0) {
                        favoritesList.innerHTML = '<p style="padding: 10px; text-align: center; color: var(--text-tertiary);">暂无收藏</p>';
                        return;
                    }

                    favorites.forEach((item, index) => {
                        const favoriteItem = document.createElement('div');
                        favoriteItem.className = 'favorite-item';
                        favoriteItem.innerHTML = `
                            <div class="title">${item.title}</div>
                            <div class="author">${item.author}</div>
                        `;
                        favoriteItem.addEventListener('click', function () {
                            searchAndDisplayPoem(item.title, item.author);
                            menuOverlay.classList.remove('active');
                            favoritesSection.style.display = 'none';
                        });
                        favoritesList.appendChild(favoriteItem);
                    });
                }

                // Function to search and display a specific poem by title and author
                async function searchAndDisplayPoem(title, author) {
                    // Fetch all poems if not already loaded
                    await fetchAndCombineAll();

                    // Find the poem in the combined data
                    const poem = allCombined.find(p =>
                        p.title === title && p.auth === author
                    );

                    if (poem) {
                        displayPoem(poem);
                    } else {
                        alert('未找到该诗词');
                    }
                }

                // Add favorite button to poem display (we'll add this functionality later)
                // For now, we'll add a function to check favorite status when a poem is displayed
                function updateFavoriteButton() {
                    const poemTitle = document.getElementById('poemTitle').textContent;
                    const poemAuthor = document.getElementById('poemAuthor').textContent;

                    if (!poemTitle || !poemAuthor) return;

                    const currentPoem = {
                        title: poemTitle,
                        auth: poemAuthor
                    };

                    const isFav = isPoemFavorite(currentPoem);
                    // We'll add the favorite button later
                }

                // Add functionality to store current poem to history when it's displayed
                // We'll modify the displayPoem function to add to history
                const originalDisplayPoem = window.displayPoem || displayPoem;
                window.displayPoem = function (poem) {
                    originalDisplayPoem.call(this, poem);
                    // Add to history after poem is displayed
                    setTimeout(() => {
                        addToHistory(poem);
                    }, 500); // Small delay to ensure the poem is fully displayed
                };

                // Also modify the showPoemDetail function to add to history
                const originalShowPoemDetail = window.showPoemDetail || showPoemDetail;
                window.showPoemDetail = function (poem) {
                    originalShowPoemDetail.call(this, poem);
                    // Add to history after poem is displayed
                    setTimeout(() => {
                        addToHistory(poem);
                    }, 500); // Small delay to ensure the poem is fully displayed
                };

                // Modify the loadRandomPoem function to add to history
                const originalLoadRandomPoem = window.loadRandomPoem || loadRandomPoem;
                window.loadRandomPoem = async function () {
                    // Get a random poem first, then display it with history tracking
                    const allItems = await fetchAndCombineAll();
                    if (allItems.length === 0) {
                        console.warn("No poems or ci available");
                        return null;
                    }
                    const randomIndex = Math.floor(Math.random() * allItems.length);
                    const poem = allItems[randomIndex];

                    // Call the original display function
                    displayPoem(poem);

                    // Add to history after poem is displayed
                    setTimeout(() => {
                        addToHistory(poem);
                    }, 500); // Small delay to ensure the poem is fully displayed
                };

                // Add favorites toggle button functionality
                const favoriteToggleBtn = document.getElementById('favoriteToggleBtn');

                if (favoriteToggleBtn) {
                    // Function to update the favorite button based on current poem
                    function updateFavoriteButton() {
                        if (!favoriteToggleBtn) return;

                        const poemTitle = document.getElementById('poemTitle').textContent;
                        const poemAuthor = document.getElementById('poemAuthor').textContent;

                        if (!poemTitle || !poemAuthor) return;

                        const currentPoem = {
                            title: poemTitle,
                            auth: poemAuthor
                        };

                        const isFav = isPoemFavorite(currentPoem);

                        // Update button appearance
                        favoriteToggleBtn.innerHTML = isFav ? '❤️' : '♡';
                        favoriteToggleBtn.title = isFav ? '取消收藏' : '收藏此诗词';
                    }

                    // Add click event to the favorite toggle button
                    favoriteToggleBtn.addEventListener('click', function () {
                        const poemTitle = document.getElementById('poemTitle').textContent;
                        const poemAuthor = document.getElementById('poemAuthor').textContent;

                        if (!poemTitle || !poemAuthor) return;

                        // We need to get the full poem object to toggle favorite
                        // This will be done in the context of the currently displayed poem
                        const currentPoem = {
                            title: poemTitle,
                            auth: poemAuthor
                        };

                        // In a more complete implementation, we would have access to the full poem object
                        // For now, we'll create a temporary object with the necessary fields
                        // and update the favorites list
                        toggleFavorite(currentPoem);

                        // Update the button appearance
                        updateFavoriteButton();

                        // Show feedback to user
                        const isFav = isPoemFavorite(currentPoem);
                        const feedback = isFav ? '已收藏' : '已取消收藏';

                        // Show temporary feedback
                        const originalTitle = favoriteToggleBtn.title;
                        favoriteToggleBtn.title = feedback;
                        setTimeout(() => {
                            favoriteToggleBtn.title = originalTitle;
                            updateFavoriteButton();
                        }, 2000);
                    });

                    // Update the favorites button when poem content changes
                    // We'll call this function after a poem is displayed
                    const originalDisplayPoem = window.displayPoem || displayPoem;
                    window.displayPoem = function (poem) {
                        originalDisplayPoem.call(this, poem);
                        // Add to history after poem is displayed
                        setTimeout(() => {
                            addToHistory(poem);
                            updateFavoriteButton();
                        }, 500); // Small delay to ensure the poem is fully displayed
                    };

                    const originalShowPoemDetail = window.showPoemDetail || showPoemDetail;
                    window.showPoemDetail = function (poem) {
                        originalShowPoemDetail.call(this, poem);
                        // Add to history after poem is displayed
                        setTimeout(() => {
                            addToHistory(poem);
                            updateFavoriteButton();
                        }, 500); // Small delay to ensure the poem is fully displayed
                    };
                }
            });

            // Toggle layout between symmetric and waterfall
            function toggleLayout() {
                const symmetricContainer = document.querySelector('.poem-content');
                const waterfallContainer = document.getElementById('waterfallContainer');
                const layoutToggle = document.getElementById('layoutToggle');

                if (symmetricContainer.style.display === 'none') {
                    // Switch to symmetric layout
                    symmetricContainer.style.display = 'flex';
                    waterfallContainer.classList.remove('active');
                    layoutToggle.textContent = '瀑布流';
                    generateWaterfallContent(); // Generate waterfall content if needed
                } else {
                    // Switch to waterfall layout
                    symmetricContainer.style.display = 'none';
                    waterfallContainer.classList.add('active');
                    layoutToggle.textContent = '默认布局';
                    generateWaterfallContent(); // Generate waterfall content
                }
            }


            // Generate waterfall content from poem data
            function generateWaterfallContent() {
                const waterfallContent = document.getElementById('waterfallContent');
                // Only generate if content is not already there or if we want to refresh
                if (allCombined && allCombined.length > 0) {
                    waterfallContent.innerHTML = ''; // Clear existing content

                    // Select 12 random poems from allCombined (increased from 10)
                    const randomPoems = getRandomPoems(allCombined, 12);

                    randomPoems.forEach((poem, index) => {
                        const card = document.createElement('div');
                        card.className = 'waterfall-card';
                        card.onclick = function () {
                            showPoemDetail(poem);
                        };

                        // Analyze layout for the poem
                        const layoutInfo = analyzePoemLayout(poem);

                        // Generate lines HTML
                        let linesHtml = '';
                        layoutInfo.lines.forEach(line => {
                            if (line) linesHtml += `<div class="poem-line">${line}</div>`;
                        });

                        // Generate a random color for the background
                        const backgroundColor = getRandomColor();

                        // Limit title and author length to prevent overflow
                        let title = layoutInfo.title;
                        if (title.length > 12) {
                            title = title.substring(0, 12) + '...';
                        }

                        let author = layoutInfo.author;
                        if (author.length > 8) {
                            author = author.substring(0, 8) + '...';
                        }

                        // Determine the appropriate seal based on poem type
                        const sealText = poem.source === 'ci' ? '词' : '诗';

                        card.innerHTML = `
            <div class="color-block-container">
              <div class="color-block" style="background-color: ${backgroundColor};">
                 <!-- This class changes based on mode dynamically -->
                 <div class="overlay-text layout-${layoutInfo.mode}">
                   ${linesHtml}
                 </div>

                 <!-- Add seal decoration for aesthetic enhancement (with type-specific character) -->
                 <div class="seal-decoration">${sealText}</div>
              </div>
            </div>
            <div class="waterfall-content-section">
              <h3 class="waterfall-title">${title}</h3>
              <p class="waterfall-author">${author}</p>
            </div>
          `;
                        waterfallContent.appendChild(card);
                    });
                }
            }

            // Function to get a specified number of random poems from an array
            function getRandomPoems(poemsArray, count) {
                // Create a copy of the array to avoid modifying the original
                const arrayCopy = [...poemsArray];
                const shuffled = arrayCopy.sort(() => 0.5 - Math.random());
                // Return the first 'count' elements or all elements if array is smaller
                return shuffled.slice(0, Math.min(count, shuffled.length));
            }

            // Break text into lines with maximum specified length
            function breakTextIntoLines(text, maxLength) {
                if (!text) return '';

                // First, split by periods to ensure sentences end at periods
                const sentences = text.split('。');
                const result = [];

                for (let i = 0; i < sentences.length; i++) {
                    // Only add the period back if it wasn't the last element from a text that ended with a period
                    let sentence = sentences[i];

                    // Check if this is not the last segment or if the original text didn't end with a period
                    const isLastSegment = (i === sentences.length - 1);
                    const originalTextEndedWithPeriod = (i === sentences.length - 1 && sentence === '');

                    if (!originalTextEndedWithPeriod) {
                        sentence += '。';
                    } else {
                        // If it's an empty string because text ended with a period, skip it
                        continue;
                    }

                    // Special handling for Chinese poetry (especially 7-character verses) and long sentences
                    if (sentence.length > maxLength) {
                        // For Chinese poetry, try to break at natural boundaries
                        // If we have a 七言诗 (7-character verse), keep it as one line if possible
                        if (sentence.includes('。') && sentence.length <= maxLength + 2) {
                            // If the sentence with period is only slightly over the limit, include it
                            result.push(sentence);
                        } else {
                            // For very long sentences, break them into smaller chunks
                            let start = 0;
                            while (start < sentence.length) {
                                const chunk = sentence.substring(start, Math.min(start + maxLength, sentence.length));
                                result.push(chunk);
                                start += maxLength;
                            }
                        }
                    } else {
                        // Check if we can add this sentence to the current line without exceeding maxLength
                        if (result.length === 0) {
                            // First sentence goes directly to result
                            result.push(sentence);
                        } else {
                            const currentLine = result[result.length - 1];
                            if ((currentLine + sentence).length <= maxLength) {
                                // Add to current line if it doesn't exceed maxLength
                                result[result.length - 1] += sentence;
                            } else {
                                // Start a new line
                                result.push(sentence);
                            }
                        }
                    }
                }

                return result.join('<br>');
            }

            // Show detailed poem view when clicking a card
            function showPoemDetail(poem) {
                // 1. 设置基本信息
                document.getElementById('poemTitle').textContent = poem.title;
                document.getElementById('poemAuthor').textContent = poem.auth;

                // 优化：尝试从 type 中提取朝代，如果没有则默认显示诗词类型
                const dynastyElement = document.getElementById('poemDynasty');
                const typeSealElement = document.getElementById('mainTypeSeal');
                if (poem.source === 'ci') {
                    dynastyElement.textContent = '宋';
                    dynastyElement.style.backgroundColor = '#88485E'; // 宋词用紫红色
                    typeSealElement.textContent = '词'; // 词类型
                } else {
                    dynastyElement.textContent = '唐'; // 你的数据源主要是唐诗
                    dynastyElement.style.backgroundColor = '#FE2C55'; // 唐诗用小红书红
                    typeSealElement.textContent = '诗'; // 诗类型
                }

                // 2. 智能排版逻辑 (复用 analyzePoemLayout)
                // 注意：这里我们稍微改一下，如果是 analyzePoemLayout 返回 vertical，我们就用竖排
                // 但对于主展示区，我们可以稍微放宽竖排的条件（比如只要是律诗绝句都竖排，不受32字限制，因为空间大）

                const content = poem.content;
                const verseElement = document.getElementById('poemVerse');

                // 清除之前的类
                verseElement.className = 'poem-verse';

                // 简单判断：不包含逗号且句子长度整齐的，或者你是用 analyzePoemLayout
                const layoutInfo = analyzePoemLayout(poem);

                if (layoutInfo.mode === 'vertical') {
                    verseElement.classList.add('vertical-mode');
                    // 竖排时，换行符保留，且标点符号可能会影响美观，可以考虑用空格替换标点，或者保留
                    // 这里直接保留原文排版 but add line breaks at punctuation
                    verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                } else {
                    verseElement.classList.add('horizontal-mode');
                    // 横排居中，适合长短句
                    // 【修改 3】 只要是格律诗（五言或七言），且行数足够，就使用成对布局
                    // 这样就能利用 .couplet-row 的 CSS 来控制间距，消灭大空行
                    if (isRegularPoem(poem) && poem.content.split('\n').length >= 2) {
                        verseElement.innerHTML = formatCoupletPoem(poem);
                    } else {
                        // 其他长短句（词）继续使用默认排版
                        verseElement.innerHTML = insertLineBreaksAtPunctuation(poem.content);
                    }
                }

                // 3. 赏析内容处理 (优先显示缓存的 AI 赏析)
                const cachedInterpretation = getInterpretationFromCache(poem.title, poem.auth);
                const descElement = document.getElementById('poemDesc');

                if (cachedInterpretation) {
                    // 如果有缓存，显示 AI 赏析
                    const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">✨ AI 深度赏析 <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="重新生成解读">🔄 重新生成</span></div>';
                    descElement.innerHTML = poem.desc + separator + aiBadge + markdownToHtml(cachedInterpretation);
                } else {
                    // 否则显示默认注释
                    descElement.innerHTML = poem.desc;
                }

                // Update the image
                const img = document.getElementById('poemImage');
                // Try to add current src to cache if it's loaded successfully
                img.onload = function () {
                    addToImageCache(img.src);
                };
                img.src = getRandomImageUrl(0);
                img.onerror = function () {
                    this.onerror = null;
                    // Try cached image first, then fallback to random image
                    const cachedImage = getRandomCachedImage();
                    if (cachedImage) {
                        this.src = cachedImage;
                    } else {
                        this.src = 'https://picsum.photos/600/400?random=' + Math.floor(Math.random() * 1000);
                    }
                };

                // Show the content sections
                document.getElementById('loading').style.display = 'none';
                document.getElementById('poemTextContent').style.display = 'block';
                document.getElementById('poemDescContent').style.display = 'block';

                // Apply fade-in animation
                document.getElementById('poemTextContent').classList.remove('fade-in');
                document.getElementById('poemDescContent').classList.remove('fade-in');
                // Trigger reflow
                void document.getElementById('poemTextContent').offsetWidth;
                void document.getElementById('poemDescContent').offsetWidth;
                document.getElementById('poemTextContent').classList.add('fade-in');
                document.getElementById('poemDescContent').classList.add('fade-in');


                // Switch to symmetric layout to show details
                const symmetricContainer = document.querySelector('.poem-content');
                const waterfallContainer = document.getElementById('waterfallContainer');
                const layoutToggle = document.getElementById('layoutToggle');

                symmetricContainer.style.display = 'flex';
                waterfallContainer.classList.remove('active');
                layoutToggle.textContent = '瀑布流';
            }

            // Copy poem to clipboard function (优化二: 添加"复制/分享"功能)
            function copyPoemToClipboard() {
                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                // 获取原始文本，把 <br> 换回换行符
                const verseHtml = document.getElementById('poemVerse').innerHTML;
                const verse = verseHtml.replace(/<br\s*\/?>/gi, '\n').replace(/&nbsp;/g, ' ');

                const textToCopy = `【${title}】\n${author}\n\n${verse}\n\n---- 来自苑广山古典诗词小站`;

                navigator.clipboard.writeText(textToCopy).then(() => {
                    // 简单的提示 feedback
                    const btn = document.querySelector('button[title="复制诗词"]');
                    if (btn) {
                        const originalText = '📋'; // Store original icon
                        btn.innerHTML = '✅';

                        // Clear any existing timeouts to prevent conflicts
                        if (btn.timeoutId) {
                            clearTimeout(btn.timeoutId);
                        }

                        // Set timeout to reset the button icon
                        btn.timeoutId = setTimeout(() => {
                            btn.innerHTML = originalText;
                            btn.timeoutId = null; // Clear the reference
                        }, 2000);
                    }
                }).catch(err => {
                    console.error('Failed to copy text: ', err);
                    // Optionally provide feedback to user
                    const btn = document.querySelector('button[title="复制诗词"]');
                    if (btn) {
                        btn.innerHTML = '❌';
                        if (btn.timeoutId) {
                            clearTimeout(btn.timeoutId);
                        }
                        btn.timeoutId = setTimeout(() => {
                            btn.innerHTML = '📋';
                            btn.timeoutId = null;
                        }, 2000);
                    }
                });
            }

            // New: intelligent poem layout analysis
            function analyzePoemLayout(poem) {
                const content = poem.content.replace(/\s+/g, ''); // Remove whitespace
                const sentences = content.split(/[。！？!?]/).filter(s => s.trim() !== '');

                // 1. Check if it's a 5-character or 7-character regulated verse (整齐的格律)
                // Simple check: see if the first line length is 5 or 7
                const firstLineLen = sentences[0] ? sentences[0].replace(/[，,]/g, '').length : 0;
                const isRegular = (firstLineLen === 5 || firstLineLen === 7) &&
                    sentences.every(s => {
                        const cleanLen = s.replace(/[，,]/g, '').length;
                        return cleanLen === firstLineLen * 2 || cleanLen === firstLineLen;
                    });

                let displayLines = [];
                let layoutMode = 'horizontal'; // Default horizontal layout

                if (isRegular && content.length <= 32) {
                    // 2. If it's a short 5/7-character poem (like a jueju), suitable for vertical display
                    layoutMode = 'vertical';
                    // Split the poem into lines by punctuation
                    displayLines = content.split(/[，。！？!?]/).filter(s => s.trim() !== '');
                } else {
                    // 3. If it's a long poem or ci (with uneven lines), just show a random couplet
                    // Prefer selecting middle sentences, avoid very short ones
                    const validCouplets = [];
                    // Try splitting by sentence punctuation, then by commas for couplets
                    for (let s of sentences) {
                        const parts = s.split(/[，,]/);
                        if (parts.length >= 2) {
                            // This is a complete sentence with commas, likely a couplet
                            if (parts[0].length + parts[1].length < 20) { // Limit length
                                validCouplets.push(parts[0] + '，' + parts[1]);
                            }
                        }
                    }

                    if (validCouplets.length > 0) {
                        // Randomly take a couplet
                        const randomCouplet = validCouplets[Math.floor(Math.random() * validCouplets.length)];
                        // Replace commas with line breaks for display
                        displayLines = randomCouplet.split(/[，,]/);
                        layoutMode = 'horizontal-center'; // Quote mode suitable for center alignment
                    } else {
                        // Fallback: take first two sentences
                        if (sentences.length >= 2) {
                            displayLines = [sentences[0].split(/[，,]/)[0] || '', sentences[0].split(/[，,]/)[1] || ''];
                        } else if (sentences.length === 1) {
                            const parts = sentences[0].split(/[，,]/);
                            displayLines = [parts[0] || '', parts[1] || ''];
                        } else {
                            displayLines = ['诗词内容', '诗词内容'];
                        }
                        layoutMode = 'horizontal-center';
                    }
                }

                return {
                    lines: displayLines,
                    mode: layoutMode,
                    title: poem.title,
                    author: poem.auth
                };
            }

            // Function to refresh content based on current layout
            function refreshContent() {
                const waterfallContainer = document.getElementById('waterfallContainer');

                if (waterfallContainer.classList.contains('active')) {
                    // If in waterfall layout, refresh the waterfall content with new random poems
                    generateWaterfallContent();
                } else {
                    // If in symmetric layout, load a new random poem
                    loadRandomPoem();
                }
            }

            // Function to get AI interpretation of the poem
            async function getPoemInterpretation() {
                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                const verse = document.getElementById('poemVerse').textContent;
                const desc = document.getElementById('poemDesc').textContent;

                // Show loading state
                const searchBtn = document.getElementById('ai-interpret-btn');
                const originalContent = searchBtn.innerHTML;
                searchBtn.innerHTML = '🔄';
                searchBtn.disabled = true;

                try {
                    // Create a prompt for the AI
                    const prompt = `请为以下古诗词提供深度解读和赏析，使用Markdown格式输出，包含以下部分：
1. 诗词背景与作者心境
2. 逐句解析（如果诗句较短可合并解析）
3. 艺术手法与修辞特点
4. 主题思想与情感内涵
5. 文学价值与影响

诗词题目：${title}
作者：${author}
诗词内容：
${verse}

原注释：${desc}

请以标准Markdown格式返回，确保格式正确，段落清晰。`;

                    // Call the real AI API to get poem interpretation
                    const interpretation = await getRealPoemInterpretation(title, author, verse, desc);

                    // Prepare poem info for the new page
                    const poemInfo = {
                        title: title,
                        author: author,
                        dynasty: getDynastyFromSource(), // You'll need to define this function
                        type: getPoemType() // You'll need to define this function
                    };

                    // Show interpretation in modal instead of opening new page
                    showInterpretationModal(interpretation, poemInfo);

                } catch (error) {
                    console.error('Error getting poem interpretation:', error);
                    alert('获取诗词解读失败，请稍后重试');
                } finally {
                    // Restore button
                    searchBtn.innerHTML = originalContent;
                    searchBtn.disabled = false;
                }
            }

            // Configuration for API
            const API_DOMAIN = 'https://aiproxy.want.biz/';
            const API_PREFIX = API_DOMAIN.replace(/\/+$/, '');
            const DEFAULT_TIMEOUT = 120; // 秒

            const MODELS = [
                { id: 'gemini-pro-latest', name: '💎Pro' },
                { id: 'gemini-flash-lite-latest', name: '⚡️Flash' },
                { id: 'kimi-k2-0905-preview', name: '🛰️K2' },
                { id: 'deepseek-reasoner', name: '✈️DS' },
            ];
            const DEFAULT_MODEL_ID = 'gemini-flash-lite-latest';

            // Core prompt template configuration
            const PROMPT_TEMPLATES = {
                '深度': '请对以下内容进行全面且深入的分析,结构化地呈现观点。首先提出核心论点，然后分点展开详细论述，并结合相关背景知识或案例。文章风格要求专业、严谨，篇幅不少于3000字。请将最终输出格式化为**Markdown**。',
                '文章': '你是一位感情细腻的作家，思想睿智，能够从不同角度发掘题材的新颖角度，善于观察，勤于思考，善用修辞手法，如无特殊说明，一般不少于2000字，写作风格请务必要借鉴余秋雨和吴晓波的风格，越相似越好。文章完成后起一个适合发表在自媒体上的标题，不多于40字，标题格式为：# 标题，放在第一行，第二行开始为正文内容。请将最终输出格式化为**Markdown**。',
                '翻译': '你是一位资深的中英双语翻译，如果是中文，请将其翻译为准确的英文，如果是英文请翻译为中文。如果翻译后的英文中有不易理解的单词，请解释清楚。请将最终输出格式化为**Markdown**。',
                '诗词': '请为以下古诗词提供深度解读和赏析，使用Markdown格式输出，包含以下部分：1. 诗词背景与作者心境 2. 逐句解析（如果诗句较短可合并解析） 3. 艺术手法与修辞特点 4. 主题思想与情感内涵 5. 文学价值与影响'
                // ... Other templates can be added as needed, but the core requirement is to return Markdown
            };
            const DEFAULT_TEMPLATE_KEY = '诗词';

            // Tool functions
            function toDisplayString(any) {
                if (any == null) return '';
                if (typeof any === 'string') return any;
                try { return JSON.stringify(any, null, 2); } catch { return String(any); }
            }

            // API wrapper
            async function requestJSON(method, path, payload) {
                const url = `${API_PREFIX}${path.startsWith('/') ? path : `/${path}`}`;

                // Use fetch API in browser environment
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), DEFAULT_TIMEOUT * 1000);

                try {
                    const response = await fetch(url, {
                        method: method,
                        headers: { 'Content-Type': 'application/json', Accept: 'application/json' },
                        body: payload ? JSON.stringify(payload) : null,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok) {
                        let errorData = {};
                        try {
                            errorData = await response.json();
                        } catch {
                            errorData = { message: await response.text() };
                        }
                        throw new Error(`API请求失败 (HTTP ${response.status}): ${errorData.error?.message || toDisplayString(errorData)}`);
                    }
                    return await response.json();
                } catch (e) {
                    clearTimeout(timeoutId);
                    if (e.name === 'AbortError') {
                        throw new Error(`网络请求超时 (超过 ${DEFAULT_TIMEOUT} 秒)`);
                    }
                    throw new Error(`网络或API错误: ${e.message}`);
                }
            }

            // Helper to regenerate analysis
            async function regenerateAnalysis(event) {
                if (event) event.stopPropagation();

                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                const verse = document.getElementById('poemVerse').innerText; // Use innerText to get text content
                // Note: poemDesc might contain the AI analysis now, so we should try to get the original desc if possible.
                // But for regeneration, the prompt mainly needs title, author, and verse. 
                // The 'desc' in prompt is 'Original Annotation', which we might lose if we just read poemDesc.
                // Ideally we should store the current poem object globally or fetch it again.
                // For simplicity, we'll try to extract the part before the separator if it exists, or just use what's there.
                let desc = document.getElementById('poemDesc').innerHTML;
                if (desc.includes('border-top: 1px dashed #ddd')) {
                    desc = desc.split('<div style="border-top: 1px dashed #ddd')[0];
                }

                const descElement = document.getElementById('poemDesc');
                // Show loading state
                const separator = '<div style="border-top: 1px dashed #ddd; margin: 20px 0;"></div>';
                const loadingBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">✨ AI 正在重新思考...</div>';
                descElement.innerHTML = desc + separator + loadingBadge + '<div class="loading-spinner" style="margin: 20px auto;"></div>';

                try {
                    // Force refresh = true
                    const result = await getRealPoemInterpretation(title, author, verse, desc, true);

                    // Update UI
                    const aiBadge = '<div style="display:inline-block; background:linear-gradient(90deg, #6366f1, #8b5cf6); color:white; padding:2px 8px; border-radius:12px; font-size:0.8rem; margin-bottom:10px; font-weight:bold;">✨ AI 深度赏析 <span onclick="regenerateAnalysis(event)" style="cursor:pointer; margin-left:10px; font-size:0.8em; opacity:0.8; border-bottom:1px solid white;" title="重新生成解读">🔄 重新生成</span></div>';
                    descElement.innerHTML = desc + separator + aiBadge + markdownToHtml(result);

                } catch (error) {
                    console.error("Regeneration failed:", error);
                    descElement.innerHTML = desc + separator + `<div style="color:red;">重新生成失败: ${error.message}</div>`;
                }
            }

            // Core AI call interface
            async function explainText(text, model) {
                // Assuming the AI service exposes the endpoint at /ai/explain
                return await requestJSON('POST', '/ai/explain', { text, model });
            }

            // Cache configuration for AI interpretations
            const AI_CACHE_KEY = 'poem_ai_interpretations_v1';

            // Helper to get interpretation from cache
            function getInterpretationFromCache(title, author) {
                try {
                    const cache = localStorage.getItem(AI_CACHE_KEY);
                    if (!cache) return null;

                    const cacheObj = JSON.parse(cache);
                    const key = `${title}-${author}`;
                    return cacheObj[key] || null;
                } catch (e) {
                    console.error('Error reading from cache:', e);
                    return null;
                }
            }

            // Helper to save interpretation to cache
            function saveInterpretationToCache(title, author, content) {
                try {
                    const cache = localStorage.getItem(AI_CACHE_KEY);
                    let cacheObj = {};
                    if (cache) {
                        cacheObj = JSON.parse(cache);
                    }

                    const key = `${title}-${author}`;
                    cacheObj[key] = content;

                    localStorage.setItem(AI_CACHE_KEY, JSON.stringify(cacheObj));
                    console.log(`Saved interpretation for ${title} to cache`);
                } catch (e) {
                    console.error('Error saving to cache:', e);
                }
            }

            // Main function to get AI interpretation of the poem
            async function getRealPoemInterpretation(title, author, verse, desc, forceRefresh = false) {
                // 1. Check cache first (unless forced refresh)
                if (!forceRefresh) {
                    const cachedInterpretation = getInterpretationFromCache(title, author);
                    if (cachedInterpretation) {
                        console.log(`[Poetry AI] Found cached interpretation for ${title}`);
                        return cachedInterpretation;
                    }
                }

                const finalSystemPrompt = PROMPT_TEMPLATES['诗词'] || PROMPT_TEMPLATES[DEFAULT_TEMPLATE_KEY];

                const textToInterpret = `诗词题目：${title}
作者：${author}
诗词内容：
${verse}

原注释：${desc}`;

                // Combine final text to send to the model: system instruction + separator + user input
                const finalText = finalSystemPrompt ? `${finalSystemPrompt}\n\n---\n\n${textToInterpret.trim()}` : textToInterpret.trim();

                console.log(`[Poetry AI] 正在使用模型: ${DEFAULT_MODEL_ID} 进行处理...`);

                try {
                    const resultData = await explainText(finalText, DEFAULT_MODEL_ID);

                    // The API now returns data in a structure with an 'explanation' field, fallback to 'data', 'text', or the result directly
                    const markdownResult = resultData.explanation || resultData.data || resultData.text || resultData;

                    if (typeof markdownResult !== 'string' || !markdownResult.trim()) {
                        throw new Error(`API返回结果格式不正确，未找到有效的文本内容。Raw: ${toDisplayString(resultData)}`);
                    }

                    const finalResult = markdownResult.trim();

                    // 2. Save to cache on success
                    saveInterpretationToCache(title, author, finalResult);

                    return finalResult;

                } catch (error) {
                    console.error("[Poetry AI] 错误:", error);
                    // Also package error message in Markdown format for display
                    return `**AI 诗词解读失败**\n\n错误详情:\n\`\`\`\n${error.message}\n\`\`\`\n请检查 API 域名 (${API_PREFIX}) 和模型配置是否正确。`;
                }
            }

            // Helper function to get dynasty from source (you'll need to adapt this to your data structure)
            function getDynastyFromSource() {
                // This should get the dynasty from the current poem data
                // For now returning a generic value
                const dynastyElement = document.getElementById('poemDynasty');
                return dynastyElement ? dynastyElement.textContent : '未知';
            }

            // Helper function to get poem type
            function getPoemType() {
                // This should get the poem type (诗/词)
                const typeSealElement = document.getElementById('mainTypeSeal');
                return typeSealElement ? typeSealElement.textContent : '诗词';
            }

            // Function to display interpretation in modal
            function showInterpretationModal(interpretation, poemInfo) {
                // Update modal title with poem info
                document.getElementById('modalTitle').innerHTML = `诗词解读`;

                // Convert markdown to HTML and display content
                document.getElementById('interpretationContent').innerHTML = markdownToHtml(interpretation);

                // Show the modal
                document.getElementById('interpretationModal').style.display = 'flex';
            }

            // Function to close the modal
            function closeInterpretationModal() {
                document.getElementById('interpretationModal').style.display = 'none';
            }

            // Function to copy modal content
            function copyModalContent() {
                // Get poem information
                const title = document.getElementById('poemTitle').textContent;
                const author = document.getElementById('poemAuthor').textContent;
                const dynasty = document.getElementById('poemDynasty').textContent;

                // Get poem verse content
                const verseHtml = document.getElementById('poemVerse').innerHTML;
                const verse = verseHtml.replace(/<br\s*\/?>/gi, '\n').replace(/&nbsp;/g, ' ');

                // Get interpretation content
                const contentToCopy = document.getElementById('interpretationContent').innerText;

                // Combine poem info with interpretation
                const fullContent = `【${title}】\n${dynasty}·${author}\n\n${verse}\n\n${contentToCopy}\n\n---- 来自苑广山古典诗词小站`;

                navigator.clipboard.writeText(fullContent)
                    .then(() => {
                        // Show temporary success message
                        const copyBtn = document.getElementById('copyModalBtn');
                        const originalText = copyBtn.innerHTML;
                        copyBtn.innerHTML = '✓';

                        setTimeout(() => {
                            copyBtn.innerHTML = originalText;
                        }, 2000);
                    })
                    .catch(err => {
                        console.error('复制失败:', err);
                        alert('复制失败，请手动选择文本进行复制');
                    });
            }

            // Function to convert markdown to HTML (simplified version)
            function markdownToHtml(md) {
                if (!md) return '';

                // Simple markdown conversion
                let html = md
                    // Headers
                    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
                    // Bold
                    .replace(/\*\*(.*)\*\*/gim, '<strong>$1</strong>')
                    // Italic
                    .replace(/\*(.*)\*/gim, '<em>$1</em>')
                    // Links
                    .replace(/\[(.*?)\]\((.*?)\)/gim, '<a href="$2">$1</a>')
                    // Code blocks
                    .replace(/```([\s\S]*?)```/gim, '<pre><code>$1</code></pre>')
                    // Inline code
                    .replace(/`(.*?)`/gim, '<code>$1</code>')
                    // Blockquotes
                    .replace(/^> (.*$)/gim, '<blockquote>$1</blockquote>')
                    // Unordered lists
                    .replace(/^\- (.*$)/gim, '<li>$1</li>')
                    // Ordered lists (need to handle numbering)
                    .replace(/^\d+\. (.*$)/gim, '<li>$1</li>')
                    // Paragraphs (replace double newlines)
                    .replace(/\n\n/gim, '</p><p>')
                    .replace(/\n/gim, '<br>');

                // Clean up
                html = html.replace(/<p><\/p>/gim, '');
                html = `<p>${html}</p>`;

                // Handle lists - wrap in ul/ol tags
                html = html.replace(/<p><li>/gim, '<ul><li>')
                    .replace(/<\/li><\/p>/gim, '</li></ul>')
                    .replace(/<\/li><li>/gim, '</li><li>');

                // Handle ordered lists
                html = html.replace(/<p><li>/gim, '<ol><li>')
                    .replace(/<\/li><\/p>/gim, '</li></ol>');

                return html;
            }

            // Add event listener to the AI interpretation button
            document.addEventListener('DOMContentLoaded', function () {
                const aiInterpretBtn = document.getElementById('ai-interpret-btn');
                if (aiInterpretBtn) {
                    aiInterpretBtn.addEventListener('click', getPoemInterpretation);
                }

                // Add event listeners for modal
                document.getElementById('closeModalBtn').addEventListener('click', closeInterpretationModal);
                document.getElementById('copyModalBtn').addEventListener('click', copyModalContent);

                // Close modal when clicking on overlay
                document.getElementById('interpretationModal').addEventListener('click', function (e) {
                    if (e.target === this) {
                        closeInterpretationModal();
                    }
                });

                // Add scroll event listener for auto-refresh functionality (only in waterfall mode)
                let isRefreshing = false; // Prevent multiple simultaneous refreshes
                let lastScrollTop = 0;
                let hasReachedBottom = false; // Flag to track if user reached bottom

                window.addEventListener('scroll', function () {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const waterfallContainer = document.getElementById('waterfallContainer');

                    // Only enable auto-refresh in waterfall mode
                    if (waterfallContainer.classList.contains('active')) {
                        // Check if user has reached near the bottom of the page
                        if ((window.scrollY + window.innerHeight) >= document.body.offsetHeight - 50) {
                            hasReachedBottom = true;
                        } else {
                            // Only reset if scrolling down away from bottom
                            if (scrollTop > lastScrollTop) {
                                hasReachedBottom = false;
                            }
                        }

                        // Check if user was at bottom and started scrolling down (away from bottom)
                        if (hasReachedBottom && scrollTop > lastScrollTop && lastScrollTop > 0) {
                            if (!isRefreshing) {
                                isRefreshing = true;

                                // Add slight delay to avoid triggering during page load animations
                                setTimeout(async function () {
                                    // Waterfall mode: add 10 more poems
                                    await addMorePoemsToWaterfall();

                                    // Reset flags after successful refresh
                                    hasReachedBottom = false;
                                    isRefreshing = false;
                                }, 100);
                            }
                        }
                    }

                    // Update last scroll position
                    lastScrollTop = scrollTop;
                });
            });

            // Function to add more poems to waterfall (10 at a time)
            async function addMorePoemsToWaterfall() {
                if (!allCombined || allCombined.length === 0) {
                    await fetchAndCombineAll();
                }

                const waterfallContent = document.getElementById('waterfallContent');

                // Select 10 random poems to add
                const randomPoems = getRandomPoems(allCombined, 10);

                randomPoems.forEach((poem, index) => {
                    const card = document.createElement('div');
                    card.className = 'waterfall-card';
                    card.onclick = function () {
                        showPoemDetail(poem);
                    };

                    // Analyze layout for the poem
                    const layoutInfo = analyzePoemLayout(poem);

                    // Generate lines HTML
                    let linesHtml = '';
                    layoutInfo.lines.forEach(line => {
                        if (line) linesHtml += `<div class="poem-line">${line}</div>`;
                    });

                    // Generate a random color for the background
                    const backgroundColor = getRandomColor();

                    // Limit title and author length to prevent overflow
                    let title = layoutInfo.title;
                    if (title.length > 12) {
                        title = title.substring(0, 12) + '...';
                    }

                    let author = layoutInfo.author;
                    if (author.length > 8) {
                        author = author.substring(0, 8) + '...';
                    }

                    // Determine the appropriate seal based on poem type
                    const sealText = poem.source === 'ci' ? '词' : '诗';

                    card.innerHTML = `
        <div class="color-block-container">
          <div class="color-block" style="background-color: ${backgroundColor};">
             <!-- This class changes based on mode dynamically -->
             <div class="overlay-text layout-${layoutInfo.mode}">
               ${linesHtml}
             </div>

             <!-- Add seal decoration for aesthetic enhancement (with type-specific character) -->
             <div class="seal-decoration">${sealText}</div>
          </div>
        </div>
        <div class="waterfall-content-section">
          <h3 class="waterfall-title">${title}</h3>
          <p class="waterfall-author">${author}</p>
        </div>
      `;
                    waterfallContent.appendChild(card);
                });
            }
        </script>

        <!-- AI Interpretation Modala -->
        <div id="interpretationModal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2 id="modalTitle" class="modal-title">诗词解读</h2>
                    <div class="modal-actions">
                        <button id="copyModalBtn" class="copy-modal-btn" title="复制内容">📋</button>
                        <button id="closeModalBtn" class="close-modal-btn" title="关闭">×</button>
                    </div>
                </div>
                <div id="interpretationContent" class="interpretation-content"></div>
            </div>
        </div>

        <!-- Modal Styles -->
        <style>
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.7);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 1000;
                backdrop-filter: blur(5px);
            }

            .modal-content {
                background: var(--container-bg);
                border-radius: 20px;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
                width: 90%;
                max-width: 900px;
                max-height: 90vh;
                display: flex;
                flex-direction: column;
                overflow: hidden;
                position: relative;
            }

            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px 25px 15px;
                border-bottom: 1px solid var(--border-color);
                background: var(--container-bg);
                border-radius: 20px 20px 0 0;
            }

            .modal-title {
                margin: 0;
                font-size: 1.5rem;
                color: var(--xhs-pink);
                font-family: 'Noto Serif SC', serif;
            }

            .modal-actions {
                display: flex;
                gap: 10px;
            }

            .close-modal-btn,
            .copy-modal-btn {
                background: var(--bg-lighter);
                border: none;
                width: 36px;
                height: 36px;
                border-radius: 50%;
                font-size: 1.2rem;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                color: var(--text-primary);
                transition: all 0.3s ease;
            }

            .close-modal-btn:hover,
            .copy-modal-btn:hover {
                background: var(--xhs-pink-lighter);
                color: white;
                transform: scale(1.1);
            }

            .interpretation-content {
                padding: 25px;
                overflow-y: auto;
                max-height: calc(90vh - 150px);
                line-height: 1.7;
                font-size: 1.1rem;
            }

            .interpretation-content h1,
            .interpretation-content h2,
            .interpretation-content h3,
            .interpretation-content h4,
            .interpretation-content h5,
            .interpretation-content h6 {
                margin-top: 1.5em;
                margin-bottom: 0.8em;
                color: var(--text-primary);
                font-family: 'Noto Serif SC', serif;
            }

            .interpretation-content h1 {
                font-size: 1.8em;
                border-bottom: 2px solid var(--xhs-pink-lighter);
                padding-bottom: 0.3em;
            }

            .interpretation-content h2 {
                font-size: 1.6em;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 0.3em;
            }

            .interpretation-content h3 {
                font-size: 1.4em;
            }

            .interpretation-content p {
                margin-bottom: 1em;
                text-align: justify;
            }

            .interpretation-content ul,
            .interpretation-content ol {
                margin: 1em 0;
                padding-left: 1.5em;
            }

            .interpretation-content li {
                margin: 0.5em 0;
            }

            .interpretation-content blockquote {
                margin: 1.5em 0;
                padding: 1em 1.5em;
                border-left: 4px solid var(--xhs-pink-lighter);
                background-color: var(--xhs-pink-pale);
                font-style: italic;
            }

            .interpretation-content code {
                background-color: var(--bg-light);
                padding: 0.2em 0.4em;
                border-radius: 3px;
                font-family: monospace;
                font-size: 0.9em;
            }

            .interpretation-content pre {
                background-color: var(--bg-light);
                padding: 1.5em;
                border-radius: 8px;
                overflow-x: auto;
                margin: 1.5em 0;
            }

            .interpretation-content pre code {
                background: none;
                padding: 0;
            }

            .interpretation-content a {
                color: #4da6ff;
                text-decoration: underline;
            }

            .interpretation-content a:hover {
                color: #66b3ff;
            }
        </style>
</body>

</html>