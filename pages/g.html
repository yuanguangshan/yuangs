<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>ULW Minecraft 4.1 - Fast & Infinite</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* 准星 */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: rgba(255,255,255,0.8);
            clip-path: polygon(40% 0, 60% 0, 60% 40%, 100% 40%, 100% 60%, 60% 60%, 60% 100%, 40% 100%, 40% 60%, 0 60%, 0 40%, 40% 40%);
            transform: translate(-50%, -50%); mix-blend-mode: exclusion; z-index: 100;
        }

        /* UI 层 */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* 右侧背包按钮 */
        #inv-toggle-btn {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            width: 60px; height: 60px; background: rgba(0,0,0,0.6); border: 2px solid #fff;
            border-radius: 10px; cursor: pointer; pointer-events: auto;
            display: flex; align-items: center; justify-content: center; color: white; font-weight: bold;
            transition: 0.2s;
        }
        #inv-toggle-btn:hover { background: rgba(0,0,0,0.8); scale: 1.1; }

        /* 快捷栏 */
        #hotbar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 8px; pointer-events: auto;
        }
        .slot {
            width: 50px; height: 50px; background: #3c3c3c; border: 3px solid #555;
            display: flex; align-items: center; justify-content: center; position: relative; cursor: pointer;
            image-rendering: pixelated;
        }
        .slot.active { border-color: #fff; box-shadow: 0 0 8px white; transform: translateY(-2px); }
        .slot img { width: 36px; height: 36px; image-rendering: pixelated; }
        .slot .count { 
            position: absolute; bottom: 2px; right: 2px; color: white; 
            font-size: 14px; font-weight: bold; text-shadow: 2px 2px 0 #000; font-family: monospace;
        }

        /* 背包界面 */
        #inventory-screen {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 720px; height: 550px; background: #c6c6c6; border: 4px solid #333; pointer-events: auto;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); padding: 20px; border-radius: 4px;
            color: #333;
        }
        
        .panel-title { font-size: 18px; margin-bottom: 10px; font-weight: bold; border-bottom: 2px solid #777; padding-bottom: 5px; }

        #crafting-area {
            display: flex; gap: 10px; overflow-x: auto; padding-bottom: 15px; margin-bottom: 15px;
            background: #b0b0b0; padding: 10px; border-radius: 4px; box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        .craft-item {
            min-width: 64px; height: 80px; background: #8b8b8b; border: 2px solid #555; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative;
        }
        .craft-item:hover { background: #9c9c9c; border-color: #fff; }
        .craft-item.disabled { opacity: 0.4; filter: grayscale(1); cursor: not-allowed; }

        #inv-grid { 
            display: grid; grid-template-columns: repeat(10, 1fr); gap: 6px; 
            height: 320px; overflow-y: auto; background: #8b8b8b; padding: 10px; border: inset 3px #555;
        }
        
        #stats { position: absolute; top: 10px; left: 10px; color: white; text-shadow: 2px 2px 0 #000; font-family: monospace; }
        
        /* 提示 */
        #message {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 24px; color: #ffeb3b; text-shadow: 2px 2px 4px #000; 
            opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="crosshair"></div>
<div id="message"></div>

<div id="ui-layer">
    <div id="stats">FPS: 60 | Y: 60</div>
    <div id="inv-toggle-btn" onclick="toggleInventory()">背包<br>(E)</div>
    <div id="hotbar"></div>
    <div id="inventory-screen">
        <div class="panel-title">合成台 (点击图标合成)</div>
        <div id="crafting-area"></div>
        <div class="panel-title">物品栏 (64格 - 选中物品后点击快捷栏装备)</div>
        <div id="inv-grid"></div>
        <button onclick="toggleInventory()" style="margin-top:10px; padding:8px 30px; cursor:pointer; background:#555; color:white; border:2px solid #333;">关闭</button>
    </div>
</div>

<!-- Three.js 核心库 -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

<script>
    // --- 1. 游戏配置 (速度大幅提升) ---
    const CONF = {
        RENDER_DIST: 3,
        CHUNK_SIZE: 16,
        WORLD_BOTTOM: -64,
        WORLD_TOP: 64,
        SEA_LEVEL: 10,
        GRAVITY: 30.0,
        WALK_SPEED: 60.0,  // 基础行走速度提升 (原6.0)
        RUN_SPEED: 110.0,  // 疾跑速度
        JUMP: 13.0         // 跳跃高度略微提升
    };

    // 方块ID
    const B = {
        AIR: 0, GRASS: 1, DIRT: 2, STONE: 3, BEDROCK: 4, LOG: 5, LEAVES: 6, PLANKS: 7,
        COAL_ORE: 8, IRON_ORE: 9, DIAMOND_ORE: 10, GOLD_ORE: 11,
        WATER: 12, LAVA: 13, SAND: 14, CRAFTING_TABLE: 15, COBBLESTONE: 16, BRICK: 17,
        SWORD_WOOD: 100, SWORD_STONE: 101, SWORD_IRON: 102, SWORD_DIAMOND: 103, MEAT: 104
    };

    // --- 2. 纹理生成 ---
    const iconCache = {};
    const textures = {};

    function generateTextureAndIcon(id, color, type = 'standard') {
        const size = 64;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = color; ctx.fillRect(0,0,size,size);
        for(let i=0; i<300; i++) {
            ctx.fillStyle = Math.random()>0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
            const s = Math.ceil(Math.random()*3);
            ctx.fillRect(Math.random()*size, Math.random()*size, s, s);
        }
        if(type === 'ore') {
            ctx.fillStyle = '#000'; for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 10, 10);
            ctx.fillStyle = color; for(let i=0; i<6; i++) ctx.fillRect(Math.random()*40+10, Math.random()*40+10, 6, 6);
            ctx.globalCompositeOperation = 'destination-over'; ctx.fillStyle = '#757575'; ctx.fillRect(0,0,size,size);
        } else if (type === 'log') {
            ctx.strokeStyle = 'rgba(0,0,0,0.3)'; ctx.lineWidth = 4;
            for(let i=4; i<size; i+=10) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke(); }
            ctx.fillStyle = '#5d4037'; ctx.fillRect(0,0,10,10);
        } else if (type === 'brick' || type === 'cobble') {
            ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 2;
            ctx.strokeRect(0,0,size,size); ctx.strokeRect(size/2, 0, size/2, size/2); ctx.strokeRect(0, size/2, size/2, size/2);
        } else if (type === 'sword') {
            ctx.clearRect(0,0,size,size);
            ctx.fillStyle = '#4e342e'; ctx.fillRect(10,50, 15,15);
            ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(20,55); ctx.lineTo(55,20); ctx.lineTo(60,25); ctx.lineTo(25,60); ctx.fill();
        } else if (type === 'meat') {
            ctx.clearRect(0,0,size,size); ctx.fillStyle = '#e57373'; ctx.beginPath(); ctx.arc(32,32, 20, 0, Math.PI*2); ctx.fill();
        }
        iconCache[id] = canvas.toDataURL();
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        return tex;
    }

    const matCache = {};
    const DEF = [
        {id: B.GRASS, col:'#567d46', t:'standard'}, {id: B.DIRT, col:'#5d4037', t:'standard'},
        {id: B.STONE, col:'#757575', t:'standard'}, {id: B.BEDROCK, col:'#111', t:'standard'},
        {id: B.LOG, col:'#3e2723', t:'log'}, {id: B.LEAVES, col:'#2e7d32', t:'standard'},
        {id: B.PLANKS, col:'#bcaaa4', t:'wood'}, {id: B.SAND, col:'#fff9c4', t:'standard'},
        {id: B.WATER, col:'#2196f3', t:'standard', tr:true, op:0.6},
        {id: B.LAVA, col:'#ff3d00', t:'standard', glow:true},
        {id: B.COAL_ORE, col:'#212121', t:'ore'}, {id: B.IRON_ORE, col:'#d7ccc8', t:'ore'},
        {id: B.DIAMOND_ORE, col:'#00bcd4', t:'ore'}, {id: B.GOLD_ORE, col:'#ffeb3b', t:'ore'},
        {id: B.CRAFTING_TABLE, col:'#8d6e63', t:'brick'}, {id: B.COBBLESTONE, col:'#616161', t:'cobble'},
        {id: B.SWORD_WOOD, col:'#8d6e63', t:'sword'}, {id: B.SWORD_STONE, col:'#757575', t:'sword'},
        {id: B.SWORD_IRON, col:'#fff', t:'sword'}, {id: B.SWORD_DIAMOND, col:'#00bcd4', t:'sword'},
        {id: B.MEAT, col:'#f48fb1', t:'meat'}
    ];
    DEF.forEach(d => {
        const tex = generateTextureAndIcon(d.id, d.col, d.t);
        if(d.id < 100) matCache[d.id] = new THREE.MeshLambertMaterial({ map: tex, transparent: d.tr, opacity: d.op||1, emissive: d.glow?d.col:0 });
    });

    // --- 3. 场景 ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, CONF.RENDER_DIST * CONF.CHUNK_SIZE - 5);
    // 增加一点 FOV 增加速度感
    const camera = new THREE.PerspectiveCamera(80, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: false});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));
    const sun = new THREE.DirectionalLight(0xffffff, 0.8); sun.position.set(50, 100, 50); scene.add(sun);

    // --- 4. 世界 ---
    const worldData = {}; 
    const chunks = {};
    const simplex = new SimplexNoise();

    function getBiomeHeight(x, z) { return Math.floor(simplex.noise2D(x/100, z/100) * 20 + 30); }

    function generateChunk(cx, cz) {
        const forestNoise = (x,z) => simplex.noise2D(x/50, z/50) > 0.3;
        for(let x=0; x<16; x++) {
            for(let z=0; z<16; z++) {
                const wx = cx*16 + x, wz = cz*16 + z;
                const h = getBiomeHeight(wx, wz);
                for(let y = CONF.WORLD_BOTTOM; y <= Math.max(h, CONF.SEA_LEVEL); y++) {
                    let id = B.AIR;
                    if(y === CONF.WORLD_BOTTOM) id = B.BEDROCK;
                    else if (y < h - 4) {
                        const cave = simplex.noise3D(wx/20, y/20, wz/20);
                        if(cave > 0.6) id = (y < -10) ? B.LAVA : B.AIR;
                        else {
                            const r = Math.random();
                            if(y<10 && r>0.99) id = B.DIAMOND_ORE;
                            else if(y<30 && r>0.98) id = B.GOLD_ORE;
                            else if(y<50 && r>0.97) id = B.IRON_ORE;
                            else if(r>0.96) id = B.COAL_ORE;
                            else id = B.STONE;
                        }
                    } else if (y < h) id = B.DIRT;
                    else if (y === h) id = (y <= CONF.SEA_LEVEL) ? B.SAND : B.GRASS;
                    else if (y <= CONF.SEA_LEVEL) id = B.WATER;
                    if(id !== B.AIR) worldData[`${wx},${y},${wz}`] = id;
                }
                if(h > CONF.SEA_LEVEL && forestNoise(wx, wz) && Math.random() > 0.9) createTree(wx, h+1, wz);
            }
        }
        if(Math.random() > 0.8) spawnEntity('pig', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);
        if(Math.random() > 0.9) spawnEntity('zombie', cx*16+8, getBiomeHeight(cx*16+8, cz*16+8)+2, cz*16+8);
    }

    function createTree(x, y, z) {
        for(let i=0; i<5; i++) worldData[`${x},${y+i},${z}`] = B.LOG;
        for(let lx=-2; lx<=2; lx++) for(let lz=-2; lz<=2; lz++) for(let ly=3; ly<=5; ly++)
            if(!worldData[`${x+lx},${y+ly},${z+lz}`]) worldData[`${x+lx},${y+ly},${z+lz}`] = B.LEAVES;
    }

    function updateChunkMesh(cx, cz) {
        const key = `${cx},${cz}`;
        if(chunks[key]) { scene.remove(chunks[key]); delete chunks[key]; }
        const group = new THREE.Group();
        const geometries = {}, matrices = {};
        for(let x=0; x<16; x++) for(let z=0; z<16; z++) {
            const wx = cx*16+x, wz = cz*16+z;
            for(let y=CONF.WORLD_BOTTOM; y<=CONF.WORLD_TOP; y++) {
                const id = worldData[`${wx},${y},${wz}`];
                if(id && id!==B.AIR) {
                    if(!geometries[id]) { geometries[id]=0; matrices[id]=[]; }
                    matrices[id].push(new THREE.Matrix4().makeTranslation(wx, y, wz));
                    geometries[id]++;
                }
            }
        }
        const boxGeo = new THREE.BoxGeometry(1,1,1);
        for(let id in geometries) {
            if(!matCache[id]) continue;
            const mesh = new THREE.InstancedMesh(boxGeo, matCache[id], geometries[id]);
            const arr = matrices[id];
            for(let i=0; i<arr.length; i++) mesh.setMatrixAt(i, arr[i]);
            group.add(mesh);
        }
        scene.add(group); chunks[key] = group;
    }

    // --- 5. 实体 ---
    const entities = [];
    const handGroup = new THREE.Group(); camera.add(handGroup); scene.add(camera);
    const armMesh = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, 0.8), new THREE.MeshLambertMaterial({color: 0xeebb99}));
    armMesh.position.set(0.5, -0.4, -0.5); handGroup.add(armMesh);
    const heldItemMesh = new THREE.Mesh(new THREE.BoxGeometry(0.4,0.4,0.4), matCache[B.DIRT]);
    heldItemMesh.position.set(0.5, -0.3, -0.8); heldItemMesh.visible = false; handGroup.add(heldItemMesh);

    function spawnEntity(type, x, y, z) {
        const color = type==='zombie'?0x2e7d32 : 0xf48fb1;
        const h = type==='zombie'?1.8:0.8;
        const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.6, h, 0.6), new THREE.MeshLambertMaterial({color}));
        mesh.position.set(x,y,z); scene.add(mesh);
        entities.push({type, mesh, hp:10, vel:new THREE.Vector3(), timer:0});
    }

    // --- 6. 交互与UI ---
    const player = { inv: new Array(64).fill(null), hotbar: [null,null,null,null,null], sel: 0 };
    const controls = new THREE.PointerLockControls(camera, document.body);
    const keys = {};
    document.addEventListener('keydown', e => keys[e.code] = true);
    document.addEventListener('keyup', e => keys[e.code] = false);

    let isInvOpen = false, selectedInvIndex = -1;
    function toggleInventory() {
        isInvOpen = !isInvOpen;
        document.getElementById('inventory-screen').style.display = isInvOpen ? 'block' : 'none';
        if(isInvOpen) { controls.unlock(); renderInv(); } else controls.lock();
    }

    document.addEventListener('mousedown', e => {
        if(isInvOpen || !controls.isLocked) { if(!isInvOpen) controls.lock(); return; }
        handGroup.rotation.x = -0.5; setTimeout(()=>handGroup.rotation.x=0, 150);
        if(e.button === 0) interact('break'); if(e.button === 2) interact('place');
    });
    
    document.addEventListener('keydown', e => {
        if(e.code === 'KeyE') toggleInventory();
        if(e.key >= '1' && e.key <= '5') { player.sel = parseInt(e.key) - 1; updateHand(); renderHotbar(); }
    });

    function getLookingAt() {
        const dir = new THREE.Vector3(); camera.getWorldDirection(dir);
        let pos = camera.position.clone();
        for(let i=0; i<80; i++) {
            pos.addScaledVector(dir, 0.06);
            const x=Math.round(pos.x), y=Math.round(pos.y), z=Math.round(pos.z);
            const id = worldData[`${x},${y},${z}`];
            if(id && id!==B.AIR && id!==B.WATER) {
                 const prev = pos.clone().addScaledVector(dir, -0.06);
                 return {x,y,z, id, face:{x:Math.round(prev.x)-x, y:Math.round(prev.y)-y, z:Math.round(prev.z)-z}};
            }
        }
        return null;
    }

    function interact(action) {
        if(action === 'break') {
            const hitEnt = entities.find(e => e.mesh.position.distanceTo(camera.position) < 3);
            if(hitEnt) {
                hitEnt.hp -= 2; hitEnt.mesh.material.emissive.setHex(0xff0000); setTimeout(()=>hitEnt.mesh.material.emissive.setHex(0), 100);
                hitEnt.vel.y = 5; hitEnt.vel.add(new THREE.Vector3().copy(camera.getWorldDirection(new THREE.Vector3())).multiplyScalar(5));
                if(hitEnt.hp<=0) { scene.remove(hitEnt.mesh); entities.splice(entities.indexOf(hitEnt),1); if(hitEnt.type==='pig') addToInv(B.MEAT, 2); }
                return;
            }
        }
        const hit = getLookingAt(); if(!hit) return;
        if(action === 'break') {
            if(hit.id === B.BEDROCK) return;
            delete worldData[`${hit.x},${hit.y},${hit.z}`];
            let drop = hit.id; if(hit.id===B.STONE) drop=B.COBBLESTONE; if(hit.id===B.GRASS) drop=B.DIRT; if(hit.id===B.LEAVES) drop=null;
            if(drop) addToInv(drop, 1);
            rebuild(hit.x, hit.z);
        } else if (action === 'place') {
            const idx = player.hotbar[player.sel]; if(idx===null || !player.inv[idx]) return;
            const item = player.inv[idx]; if(item.id>=100) return;
            const tx=hit.x+hit.face.x, ty=hit.y+hit.face.y, tz=hit.z+hit.face.z;
            if(Math.abs(camera.position.x-tx)<0.6 && Math.abs(camera.position.y-ty)<1.8 && Math.abs(camera.position.z-tz)<0.6) return;
            worldData[`${tx},${ty},${tz}`] = item.id;
            item.count--; if(item.count<=0) player.inv[idx]=null;
            renderHotbar(); updateHand(); rebuild(tx, tz);
        }
    }
    
    function rebuild(x, z) { updateChunkMesh(Math.floor(x/16), Math.floor(z/16)); }
    function addToInv(id, num) {
        for(let i=0; i<64; i++) if(player.inv[i] && player.inv[i].id===id && player.inv[i].count<64) { player.inv[i].count+=num; showMsg(`获得物品`); renderHotbar(); return; }
        for(let i=0; i<64; i++) if(!player.inv[i]) { player.inv[i]={id, count:num}; showMsg(`获得物品`); renderHotbar(); updateHand(); return; }
    }
    function showMsg(m) { const el=document.getElementById('message'); el.innerText=m; el.style.opacity=1; setTimeout(()=>el.style.opacity=0,1500); }

    const RECIPES = [
        {out:B.PLANKS, n:4, in:{[B.LOG]:1}}, {out:B.CRAFTING_TABLE, n:1, in:{[B.PLANKS]:4}},
        {out:B.SWORD_WOOD, n:1, in:{[B.PLANKS]:2}}, {out:B.SWORD_STONE, n:1, in:{[B.COBBLESTONE]:2}},
        {out:B.SWORD_IRON, n:1, in:{[B.IRON_ORE]:2}}, {out:B.SWORD_DIAMOND, n:1, in:{[B.DIAMOND_ORE]:2}},
        {out:B.BRICK, n:1, in:{[B.STONE]:1}}
    ];
    
    function renderInv() {
        const grid = document.getElementById('inv-grid'); grid.innerHTML='';
        player.inv.forEach((item, i) => {
            const el = document.createElement('div'); el.className='slot'+(selectedInvIndex===i?' active':'');
            if(item) el.innerHTML = `<img src="${iconCache[item.id]}"><span class="count">${item.count}</span>`;
            el.onclick = () => { selectedInvIndex=i; renderInv(); }; grid.appendChild(el);
        });
        const craft = document.getElementById('crafting-area'); craft.innerHTML='';
        RECIPES.forEach(r => {
            const div = document.createElement('div'); div.className='craft-item';
            let enough = true;
            for(let reqId in r.in) if(player.inv.reduce((s,it)=>s+(it&&it.id==reqId?it.count:0),0) < r.in[reqId]) enough=false;
            if(!enough) div.classList.add('disabled');
            div.innerHTML = `<img src="${iconCache[r.out]}" width="40"><span style="font-size:10px;font-weight:bold">${r.n}</span>`;
            div.onclick = () => {
                if(!enough) return;
                for(let reqId in r.in) {
                    let cost=r.in[reqId];
                    for(let i=0; i<64; i++) if(player.inv[i] && player.inv[i].id==reqId) {
                        let take=Math.min(player.inv[i].count, cost); player.inv[i].count-=take; cost-=take;
                        if(player.inv[i].count===0) player.inv[i]=null; if(cost<=0) break;
                    }
                }
                addToInv(r.out, r.n); renderInv();
            };
            craft.appendChild(div);
        });
    }

    function renderHotbar() {
        const bar = document.getElementById('hotbar'); bar.innerHTML='';
        for(let i=0; i<5; i++) {
            const idx = player.hotbar[i]; const item = idx!==null?player.inv[idx]:null;
            const el = document.createElement('div'); el.className='slot '+(player.sel===i?'active':'');
            if(item) el.innerHTML = `<img src="${iconCache[item.id]}"><span class="count">${item.count}</span>`;
            el.onclick=(e)=>{ e.stopPropagation(); if(isInvOpen && selectedInvIndex!==-1) { player.hotbar[i]=selectedInvIndex; selectedInvIndex=-1; renderInv(); renderHotbar(); updateHand(); } else { player.sel=i; renderHotbar(); updateHand(); }};
            bar.appendChild(el);
        }
    }
    
    function updateHand() {
        const idx=player.hotbar[player.sel], item=idx!==null?player.inv[idx]:null;
        armMesh.visible = !item; heldItemMesh.visible = !!item;
        if(item) {
            heldItemMesh.geometry = item.id>=100 ? new THREE.BoxGeometry(0.1,0.6,0.1) : new THREE.BoxGeometry(0.4,0.4,0.4);
            heldItemMesh.rotation.set(item.id>=100?Math.PI/4:0, 0, 0);
            heldItemMesh.material = matCache[item.id] || new THREE.MeshBasicMaterial({color:0xffffff});
        }
    }

    // --- 7. 循环与物理 ---
    const clock = new THREE.Clock(); const vel = new THREE.Vector3();
    let lastCx=-999, lastCz=-999, onGround=false;
    camera.position.set(0, 50, 0);

    function animate() {
        requestAnimationFrame(animate);
        const dt = Math.min(clock.getDelta(), 0.1);
        if(controls.isLocked) {
            vel.x -= vel.x * 10.0 * dt; vel.z -= vel.z * 10.0 * dt; vel.y -= CONF.GRAVITY * dt;
            const dir = new THREE.Vector3();
            const fwd = (keys['KeyW']?1:0)-(keys['KeyS']?1:0), side = (keys['KeyD']?1:0)-(keys['KeyA']?1:0);
            dir.z = fwd; dir.x = side; dir.normalize();
            
            // 疾跑逻辑：按Shift加速
            const currentSpeed = keys['ShiftLeft'] ? CONF.RUN_SPEED : CONF.WALK_SPEED;
            if(fwd||side) { vel.z -= dir.z * currentSpeed * dt; vel.x -= dir.x * currentSpeed * dt; }
            
            controls.moveRight(-vel.x * dt); controls.moveForward(-vel.z * dt); camera.position.y += vel.y * dt;
            
            // 碰撞与自动跳跃
            checkCollision();
            if(keys['Space'] && onGround) vel.y = CONF.JUMP;
            if(camera.position.y < CONF.WORLD_BOTTOM-10) { camera.position.set(0,60,0); vel.set(0,0,0); }
        }

        const cx = Math.floor(camera.position.x/16), cz = Math.floor(camera.position.z/16);
        if(cx!==lastCx || cz!==lastCz) {
            for(let x=-CONF.RENDER_DIST; x<=CONF.RENDER_DIST; x++) for(let z=-CONF.RENDER_DIST; z<=CONF.RENDER_DIST; z++) {
                if(!chunks[`${cx+x},${cz+z}`]) { generateChunk(cx+x, cz+z); updateChunkMesh(cx+x, cz+z); }
            }
            for(let k in chunks) { const p=k.split(','); if(Math.abs(p[0]-cx)>CONF.RENDER_DIST+1 || Math.abs(p[1]-cz)>CONF.RENDER_DIST+1) { scene.remove(chunks[k]); delete chunks[k]; } }
            lastCx=cx; lastCz=cz;
        }

        entities.forEach(ent => {
            ent.vel.y -= CONF.GRAVITY * dt;
            if(ent.type==='zombie' && ent.mesh.position.distanceTo(camera.position)<20) {
                const d=camera.position.clone().sub(ent.mesh.position).normalize(); ent.vel.x=d.x*4; ent.vel.z=d.z*4;
            } else if(Math.random()>0.98) { ent.vel.x=(Math.random()-0.5)*4; ent.vel.z=(Math.random()-0.5)*4; }
            ent.mesh.position.addScaledVector(ent.vel, dt);
            const ex=Math.round(ent.mesh.position.x), ey=Math.round(ent.mesh.position.y), ez=Math.round(ent.mesh.position.z);
            if(worldData[`${ex},${ey},${ez}`] || worldData[`${ex},${ey-1},${ez}`]) { if(ent.vel.y<0) { ent.vel.y=0; ent.mesh.position.y=ey+1; } }
        });

        renderer.render(scene, camera);
        document.getElementById('stats').innerText = `XYZ: ${Math.floor(camera.position.x)},${Math.floor(camera.position.y)},${Math.floor(camera.position.z)}`;
    }

    function checkCollision() {
        const x=camera.position.x, y=camera.position.y, z=camera.position.z;
        const bx=Math.round(x), by=Math.round(y-1.6), bz=Math.round(z);
        // 自动跳跃
        const dir=new THREE.Vector3(); camera.getWorldDirection(dir);
        if(onGround && keys['KeyW'] && worldData[`${Math.round(x+dir.x)},${Math.round(y-1)},${Math.round(z+dir.z)}`] && !worldData[`${Math.round(x+dir.x)},${Math.round(y)},${Math.round(z+dir.z)}`]) vel.y=6;
        
        let hitY = -999;
        for(let k=0; k<=2; k++) if(worldData[`${bx},${by-k},${bz}`] && worldData[`${bx},${by-k},${bz}`]!==B.AIR) { hitY=by-k; break; }
        if(y < hitY+2.6) { camera.position.y=hitY+2.6; vel.y=0; onGround=true; } else onGround=false;
    }

    updateHand(); renderHotbar(); animate();
    window.onresize = () => { camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); };
</script>
</body>
</html>