<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∏âÊ∂àÂ∞ÑÂáªÊ∏∏Êàè - ‰øÆÊ≠£Áâà</title>
    <style>
        :root {
            --grid-size: 40px; 
            --gap: 4px;
            --bg-color: #2c3e50;
            --grid-bg: #34495e;
            --score-color: #ecf0f1;
            --red: #e74c3c;
            --orange: #e67e22;
            --yellow: #f1c40f;
            --border-radius: 5px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: var(--bg-color);
            color: var(--score-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .game-wrapper {
            text-align: center;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: calc(25 * var(--grid-size) + 24 * var(--gap));
            margin: 0 auto 20px auto;
        }

        h1 {
            font-size: 2em;
            margin: 0;
        }

        #score-board {
            font-size: 2.5em;
            font-weight: bold;
        }

        .game-container {
            display: flex;
            gap: var(--gap);
            position: relative;
        }

        .grid {
            display: grid;
            gap: var(--gap);
            background-color: var(--grid-bg);
            padding: var(--gap);
            border-radius: var(--border-radius);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
        }

        #match-grid {
            grid-template-columns: repeat(10, var(--grid-size));
            grid-template-rows: repeat(10, var(--grid-size));
        }

        #enemy-grid {
            grid-template-columns: repeat(15, var(--grid-size));
            grid-template-rows: repeat(10, var(--grid-size));
        }

        .cell {
            width: var(--grid-size);
            height: var(--grid-size);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: calc(var(--grid-size) * 0.7);
        }
        
        .enemy-cell {
             cursor: default;
        }

        .cell.red { background-color: var(--red); }
        .cell.orange { background-color: var(--orange); }
        .cell.yellow { background-color: var(--yellow); }

        .cell.selected {
            box-shadow: 0 0 10px 4px #ecf0f1;
            transform: scale(1.1);
            z-index: 10;
        }
        
        .enemy {
            animation: enemy-spawn 0.3s ease-out;
        }
        
        @keyframes enemy-spawn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        .bullet {
            position: absolute;
            width: calc(var(--grid-size) * 0.3);
            height: calc(var(--grid-size) * 0.3);
            border-radius: 50%;
            z-index: 20;
            transition: left 0.5s linear;
        }
        
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            display: none; /* Initially hidden */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
        }

        #game-over-screen h2 {
            font-size: 4em;
            margin: 0;
            color: var(--red);
        }

        #game-over-screen p {
            font-size: 1.5em;
        }

        #game-over-screen button {
            font-size: 1.2em;
            padding: 15px 30px;
            border: none;
            background-color: var(--yellow);
            color: var(--bg-color);
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
            transition: transform 0.2s;
        }
        #game-over-screen button:hover {
            transform: scale(1.05);
        }

    </style>
</head>
<body>

<div class="game-wrapper">
    <div id="player-stats" style="position: absolute; top: 10px; left: 10px; color: white;">
        <div id="health-bar-container" style="width: 20px; height: 100px; background-color: #555; border: 1px solid #fff;">
            <div id="health-bar" style="width: 100%; height: 100%; background-color: red;"></div>
        </div>
        <div id="money-container" style="margin-top: 5px;">
            ÈìúÊùø: <span id="money">0</span>
        </div>
    </div>
    <div id="boss-health-bars" style="position: absolute; top: 10px; right: 10px; color: white; width: 20px;"></div>
    <div class="header">
        <h1>‰∏âÊ∂àÂ∞ÑÂáª</h1>
        <div id="score-board">ÂæóÂàÜ: 0</div>
    </div>
    <div class="game-container" id="game-container">
        <div id="match-grid" class="grid"></div>
        <div id="enemy-grid" class="grid"></div>
        <div id="game-over-screen">
            <h2>Ê∏∏ÊàèÁªìÊùü</h2>
            <p id="final-score"></p>
            <button onclick="location.reload()">ÈáçÊñ∞ÂºÄÂßã</button>
        </div>
    </div>
</div>

<script>
    // --- Ê∏∏ÊàèÈÖçÁΩÆ ---
    const MATCH_GRID_SIZE = 10;
    const ENEMY_GRID_WIDTH = 15;
    const ENEMY_GRID_HEIGHT = 10;
    const COLORS = ['red', 'orange', 'yellow'];
    const ENEMY_SPAWN_INTERVAL = 2000;
    const ENEMY_MOVE_INTERVAL = 1000;

    // --- DOM ÂÖÉÁ¥† ---
    const matchGridEl = document.getElementById('match-grid');
    const enemyGridEl = document.getElementById('enemy-grid');
    const scoreBoardEl = document.getElementById('score-board');
    const gameContainerEl = document.getElementById('game-container');
    const gameOverScreenEl = document.getElementById('game-over-screen');
    const finalScoreEl = document.getElementById('final-score');

    // --- Ê∏∏ÊàèÁä∂ÊÄÅ ---
    let score = 0;
    let playerHealth = 100;
    let money = 0;
    let bosses = [];
    let matchGrid = [];
    let enemyGrid = [];
    let selectedCell = null;
    let isSwapping = false;
    let isGameOver = false;
    let enemySpawnTimer, enemyMoveTimer;

    // --- ÂàùÂßãÂåñÊ∏∏Êàè ---
    function init() {
        for (let r = 0; r < MATCH_GRID_SIZE; r++) {
            matchGrid[r] = [];
            for (let c = 0; c < MATCH_GRID_SIZE; c++) {
                const cell = createCell(r, c);
                matchGridEl.appendChild(cell);
                matchGrid[r][c] = cell;
            }
        }

        for (let r = 0; r < ENEMY_GRID_HEIGHT; r++) {
            enemyGrid[r] = [];
            for (let c = 0; c < ENEMY_GRID_WIDTH; c++) {
                const cell = document.createElement('div');
                cell.classList.add('cell', 'enemy-cell');
                cell.dataset.r = r;
                cell.dataset.c = c;
                enemyGridEl.appendChild(cell);
                enemyGrid[r][c] = { el: cell, hasEnemy: false };
            }
        }

        populateGrid();
        addBoss(100);
        document.getElementById('money').textContent = money;
        startGameTimers();
    }
    
    function createCell(r, c) {
        const cell = document.createElement('div');
        cell.classList.add('cell');
        cell.dataset.r = r;
        cell.dataset.c = c;
        cell.style.backgroundColor = getRandomColor();
        cell.addEventListener('click', () => handleCellClick(r, c));
        return cell;
    }

    function getRandomColor() {
        return COLORS[Math.floor(Math.random() * COLORS.length)];
    }
    
    function populateGrid() {
        do {
            while(checkAndClearAllMatches(false).length > 0) {}
        } while (isGridEmpty());
    }
    
    function isGridEmpty() {
        for (let r = 0; r < MATCH_GRID_SIZE; r++) {
            for (let c = 0; c < MATCH_GRID_SIZE; c++) {
                if (!matchGrid[r][c].style.backgroundColor) return true;
            }
        }
        return false;
    }

    // --- Ê∏∏ÊàèÊ†∏ÂøÉÈÄªËæë ---
    function handleCellClick(r, c) {
        if (isSwapping || isGameOver) return;
        const clickedCell = matchGrid[r][c];
        if (!selectedCell) {
            selectedCell = clickedCell;
            selectedCell.classList.add('selected');
        } else {
            if (selectedCell === clickedCell) {
                selectedCell.classList.remove('selected');
                selectedCell = null;
            } else if (areAdjacent(selectedCell, clickedCell)) {
                swapAndCheck(selectedCell, clickedCell);
            } else {
                selectedCell.classList.remove('selected');
                selectedCell = clickedCell;
                selectedCell.classList.add('selected');
            }
        }
    }

    function areAdjacent(cell1, cell2) {
        const r1 = parseInt(cell1.dataset.r);
        const c1 = parseInt(cell1.dataset.c);
        const r2 = parseInt(cell2.dataset.r);
        const c2 = parseInt(cell2.dataset.c);
        return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
    }

    async function swapAndCheck(cell1, cell2) {
        isSwapping = true;
        if (selectedCell) selectedCell.classList.remove('selected');
        selectedCell = null;
        await swapCells(cell1, cell2);
        const matches = checkAndClearAllMatches(true);
        if (matches.length === 0) {
            await swapCells(cell1, cell2);
        }
        isSwapping = false;
    }
    
    function swapCells(cell1, cell2) {
        return new Promise(resolve => {
            const color1 = cell1.style.backgroundColor;
            cell1.style.backgroundColor = cell2.style.backgroundColor;
            cell2.style.backgroundColor = color1;
            setTimeout(resolve, 200);
        });
    }

    function checkAndClearAllMatches(shouldFireBullets = true) {
        const allMatches = [];
        for (let r = 0; r < MATCH_GRID_SIZE; r++) {
            for (let c = 0; c < MATCH_GRID_SIZE - 2; c++) {
                const cell1 = matchGrid[r][c];
                if (!cell1.style.backgroundColor) continue;
                const match = [cell1];
                let nextC = c + 1;
                while(nextC < MATCH_GRID_SIZE && matchGrid[r][nextC].style.backgroundColor === cell1.style.backgroundColor) {
                    match.push(matchGrid[r][nextC]);
                    nextC++;
                }
                if (match.length >= 3) {
                    allMatches.push(match);
                    c = nextC - 1;
                }
            }
        }
        for (let c = 0; c < MATCH_GRID_SIZE; c++) {
            for (let r = 0; r < MATCH_GRID_SIZE - 2; r++) {
                 const cell1 = matchGrid[r][c];
                 if (!cell1.style.backgroundColor) continue;
                 const match = [cell1];
                 let nextR = r + 1;
                 while(nextR < MATCH_GRID_SIZE && matchGrid[nextR][c].style.backgroundColor === cell1.style.backgroundColor) {
                    match.push(matchGrid[nextR][c]);
                    nextR++;
                 }
                 if (match.length >= 3) {
                    allMatches.push(match);
                    r = nextR - 1;
                 }
            }
        }
        if (allMatches.length > 0) {
            const uniqueCellsToClear = new Set(allMatches.flat());
            uniqueCellsToClear.forEach(cell => {
                if (shouldFireBullets) {
                    fireBullet(parseInt(cell.dataset.r), cell.style.backgroundColor);
                }
                cell.style.backgroundColor = '';
            });
            dropAndRefill(shouldFireBullets);
        }
        return allMatches;
    }
    
    function dropAndRefill(shouldFireBullets) {
        for (let c = 0; c < MATCH_GRID_SIZE; c++) {
            let emptyRow = MATCH_GRID_SIZE - 1;
            for (let r = MATCH_GRID_SIZE - 1; r >= 0; r--) {
                if (matchGrid[r][c].style.backgroundColor !== '') {
                    if (r !== emptyRow) {
                       swapCells(matchGrid[r][c], matchGrid[emptyRow][c]);
                    }
                    emptyRow--;
                }
            }
        }
        for (let r = 0; r < MATCH_GRID_SIZE; r++) {
            for (let c = 0; c < MATCH_GRID_SIZE; c++) {
                if (matchGrid[r][c].style.backgroundColor === '') {
                    matchGrid[r][c].style.backgroundColor = getRandomColor();
                }
            }
        }
        setTimeout(() => checkAndClearAllMatches(shouldFireBullets), 300);
    }
    
    // --- Â∞ÑÂáªÂíåÊïå‰∫∫ÈÄªËæë ---
    function fireBullet(row, color) {
        if (isGameOver) return;
        const bullet = document.createElement('div');
        bullet.classList.add('bullet');
        bullet.style.backgroundColor = color;
        const cellSizeWithGap = 44;
        const startY = row * cellSizeWithGap + (cellSizeWithGap / 2);
        const startX = MATCH_GRID_SIZE * cellSizeWithGap;
        bullet.style.top = `${startY}px`;
        bullet.style.left = `${startX}px`;
        gameContainerEl.appendChild(bullet);
        requestAnimationFrame(() => {
            bullet.style.left = `${gameContainerEl.offsetWidth}px`;
        });
        const checkCollisionInterval = setInterval(() => {
            const bulletRect = bullet.getBoundingClientRect();
            for (let i = 0; i < bosses.length; i++) {
                const bossRect = bosses[i].healthBar.getBoundingClientRect();
                if (bulletRect.right > bossRect.left && bulletRect.left < bossRect.right && bulletRect.top > bossRect.top && bulletRect.bottom < bossRect.bottom) {
                    updateBossHealth(i, 10); // Assuming each bullet does 10 damage
                    bullet.remove();
                    clearInterval(checkCollisionInterval);
                    return;
                }
            }
        }, 16);
        setTimeout(() => {
            bullet.remove();
            clearInterval(checkCollisionInterval);
        }, 500);
    }

    function spawnEnemy() {
        if (isGameOver) return;
        const r = Math.floor(Math.random() * ENEMY_GRID_HEIGHT);
        const c = ENEMY_GRID_WIDTH - 1;
        if (!enemyGrid[r][c].hasEnemy) {
            enemyGrid[r][c].hasEnemy = true;
            enemyGrid[r][c].el.innerHTML = '<div class="enemy">üòà</div>';
        }
    }

    /******************************************************
     * 
     *  ‚Üì‚Üì‚Üì ËøôÊòØÊú¨Ê¨°‰øÆÊ≠£ÁöÑÊ†∏ÂøÉÂáΩÊï∞ ‚Üì‚Üì‚Üì
     * 
     ******************************************************/
    function moveEnemies() {
        if (isGameOver) return;
        for (let r = 0; r < ENEMY_GRID_HEIGHT; r++) {
            // **‰øÆÊ≠£**: ‰ªéÂ∑¶ÂêëÂè≥ÈÅçÂéÜ (c ‰ªé 0 ÂºÄÂßã)
            // ËøôÊ†∑ÂèØ‰ª•Èò≤Ê≠¢‰∏Ä‰∏™Êïå‰∫∫Âú®‰∏ÄÊ¨°ÂáΩÊï∞Ë∞ÉÁî®‰∏≠ÁßªÂä®Â§öÊ¨°
            for (let c = 0; c < ENEMY_GRID_WIDTH; c++) {
                if (enemyGrid[r][c].hasEnemy) {
                    if (c === 0) {
                        // Êïå‰∫∫Âà∞ËææÁªàÁÇπÔºåÊ∏∏ÊàèÁªìÊùü
                        updatePlayerHealth(10); // Assuming each enemy does 10 damage
                        enemyGrid[r][c].hasEnemy = false;
                        enemyGrid[r][c].el.innerHTML = '';
                        return; // Á´ãÂàªÈÄÄÂá∫ÂáΩÊï∞ÔºåÈò≤Ê≠¢ÂêéÁª≠Êìç‰Ωú
                    }
                    // Ê£ÄÊü•Â∑¶Ëæπ‰∏ÄÊ†ºÊòØÂê¶‰∏∫Á©∫
                    if (!enemyGrid[r][c - 1].hasEnemy) {
                        // ÂêëÂ∑¶ÁßªÂä®
                        enemyGrid[r][c].hasEnemy = false;
                        enemyGrid[r][c].el.innerHTML = '';
                        enemyGrid[r][c - 1].hasEnemy = true;
                        enemyGrid[r][c - 1].el.innerHTML = '<div class="enemy">üòà</div>';
                    }
                }
            }
        }
    }

    // --- Ê∏∏ÊàèÁä∂ÊÄÅÁÆ°ÁêÜ ---
    """    function updateScore(points) {
        score += points;
        scoreBoardEl.textContent = `ÂæóÂàÜ: ${score}`;
    }

    function updatePlayerHealth(damage) {
        playerHealth -= damage;
        if (playerHealth < 0) playerHealth = 0;
        document.getElementById('health-bar').style.height = `${playerHealth}%`;
        if (playerHealth === 0) {
            endGame();
        }
    }

    function addBoss(health) {
        const boss = {
            health: health,
            maxHealth: health,
            healthBar: document.createElement('div')
        };
        boss.healthBar.style.height = '100px';
        boss.healthBar.style.backgroundColor = '#555';
        boss.healthBar.style.border = '1px solid #fff';
        boss.healthBar.style.marginBottom = '5px';
        const innerBar = document.createElement('div');
        innerBar.style.width = '100%';
        innerBar.style.height = '100%';
        innerBar.style.backgroundColor = 'green';
        boss.healthBar.appendChild(innerBar);
        bosses.push(boss);
        document.getElementById('boss-health-bars').appendChild(boss.healthBar);
    }

    function updateBossHealth(bossIndex, damage) {
        const boss = bosses[bossIndex];
        boss.health -= damage;
        if (boss.health < 0) boss.health = 0;
        const innerBar = boss.healthBar.querySelector('div');
        innerBar.style.height = `${(boss.health / boss.maxHealth) * 100}%`;
        if (boss.health === 0) {
            boss.healthBar.remove();
            bosses.splice(bossIndex, 1);
            increaseBossHealth();
        }
    }

    function increaseBossHealth() {
        const healthIncrease = Math.floor(Math.random() * 71) + 30;
        addBoss(100 + healthIncrease);
    }
    
    function startGameTimers() {""
        enemySpawnTimer = setInterval(spawnEnemy, ENEMY_SPAWN_INTERVAL);
        enemyMoveTimer = setInterval(moveEnemies, ENEMY_MOVE_INTERVAL);
    }
    
    function stopGameTimers() {
        clearInterval(enemySpawnTimer);
        clearInterval(enemyMoveTimer);
    }

    function endGame() {
        if (isGameOver) return;
        isGameOver = true;
        stopGameTimers();
        finalScoreEl.textContent = `‰Ω†ÁöÑÊúÄÁªàÂæóÂàÜÊòØ: ${score}`;
        gameOverScreenEl.style.display = 'flex';
    }

    // --- ÂêØÂä®Ê∏∏Êàè ---
    init();
</script>

</body>
</html>